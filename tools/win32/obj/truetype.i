# 1 "../../../libs/freetype/src/truetype/truetype.c"
# 1 "<command-line>"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "../../../libs/freetype/src/truetype/truetype.c"
# 21 "../../../libs/freetype/src/truetype/truetype.c"
# 1 "../../../libs/freetype/include/ft2build.h" 1
# 37 "../../../libs/freetype/include/ft2build.h"
# 1 "../../../libs/freetype/include/freetype/config/ftheader.h" 1
# 827 "../../../libs/freetype/include/freetype/config/ftheader.h"
# 1 "../../../libs/freetype/include/freetype/internal/internal.h" 1
# 828 "../../../libs/freetype/include/freetype/config/ftheader.h" 2
# 38 "../../../libs/freetype/include/ft2build.h" 2
# 22 "../../../libs/freetype/src/truetype/truetype.c" 2
# 1 "../../../libs/freetype/src/truetype/ttpic.c" 1
# 20 "../../../libs/freetype/src/truetype/ttpic.c"
# 1 "../../../libs/freetype/include/freetype/freetype.h" 1
# 33 "../../../libs/freetype/include/freetype/freetype.h"
# 1 "../../../libs/freetype/include/freetype/config/ftconfig.h" 1
# 42 "../../../libs/freetype/include/freetype/config/ftconfig.h"
# 1 "../../../libs/freetype/include/freetype/config/ftoption.h" 1
# 26 "../../../libs/freetype/include/freetype/config/ftoption.h"

# 896 "../../../libs/freetype/include/freetype/config/ftoption.h"

# 43 "../../../libs/freetype/include/freetype/config/ftconfig.h" 2
# 1 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 1
# 36 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 147 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 212 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 324 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef unsigned int wchar_t;
# 37 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 60 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 1 3 4
# 34 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\syslimits.h" 1 3 4






# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 1 3 4
# 168 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 1 3 4
# 25 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 1 3 4
# 378 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 1 3 4
# 385 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 386 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 2 3 4
# 379 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 2 3 4
# 402 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 1 3 4
# 10 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs-hard.h" 1 3 4
# 11 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 2 3 4
# 403 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 2 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4
# 143 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 1 3 4
# 160 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 1 3 4
# 38 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\linux\\limits.h" 1 3 4
# 39 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 2 3 4
# 161 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 2 3 4
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4



# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix2_lim.h" 1 3 4
# 148 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4
# 169 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 2 3 4
# 8 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\syslimits.h" 2 3 4
# 35 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 2 3 4
# 61 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 78 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4





# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 2 3 4
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 127 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\xlocale.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 164 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4

# 236 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 282 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 427 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 445 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 534 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 644 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4

# 79 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 102 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 1 3 4
# 29 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4




# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4

# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 28 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 121 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\typesizes.h" 1 3 4
# 122 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;


__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t;


__extension__ typedef long int __syscall_slong_t;

__extension__ typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 36 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 1 3 4
# 15 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 16 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 2 3 4




# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\wchar.h" 1 3 4
# 82 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 2 3 4
# 49 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 1 3 4
# 40 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 2 3 4
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
  __off64_t _offset;
# 302 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef __off_t off_t;
# 102 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;




# 164 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\stdio_lim.h" 1 3 4
# 165 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 306 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 665 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 824 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sys_errlist.h" 1 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 913 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 103 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 120 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 1 3 4
# 32 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4








# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitflags.h" 1 3 4
# 42 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 1 3 4
# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 1 3 4
# 36 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\endian.h" 1 3 4
# 37 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 2 3 4
# 60 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 1 3 4
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap-16.h" 1 3 4
# 35 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 2 3 4
# 43 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 74 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 2 3 4
# 65 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 67 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __daddr_t daddr_t;

typedef __caddr_t caddr_t;







typedef __key_t key_t;
# 135 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 1 3 4
# 57 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4


typedef __clock_t clock_t;



# 73 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4


typedef __time_t time_t;



# 91 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
typedef __timer_t timer_t;
# 136 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4
# 149 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 150 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 197 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 222 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 1 3 4
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\select.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 1 3 4
# 22 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 1 3 4
# 120 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4

# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\time.h" 1 3 4
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4

# 106 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4

# 223 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 1 3 4
# 24 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 3 4

# 226 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 1 3 4
# 37 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 3 4
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;

    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 274 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4



# 315 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 1 3 4
# 24 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 25 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 513 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 530 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4





extern int system (const char *__command) ;

# 734 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 752 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 812 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 899 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 951 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\stdlib-float.h" 1 3 4
# 956 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 968 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4

# 121 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 198 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\setjmp.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\setjmp.h" 3 4
typedef int __jmp_buf[64] __attribute__((__aligned__ (8)));
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));










extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 102 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 112 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4

# 199 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 211 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 1 3 4
# 212 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 44 "../../../libs/freetype/include/freetype/config/ftconfig.h" 2



# 162 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef signed short FT_Int16;
# 173 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef unsigned short FT_UInt16;
# 233 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef signed int FT_Int32;
  typedef unsigned int FT_UInt32;
# 249 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef int FT_Fast;
  typedef unsigned int FT_UFast;
# 461 "../../../libs/freetype/include/freetype/config/ftconfig.h"

# 34 "../../../libs/freetype/include/freetype/freetype.h" 2
# 1 "../../../libs/freetype/include/freetype/fttypes.h" 1
# 25 "../../../libs/freetype/include/freetype/fttypes.h"
# 1 "../../../libs/freetype/include/freetype/ftsystem.h" 1
# 26 "../../../libs/freetype/include/freetype/ftsystem.h"

# 66 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_MemoryRec_* FT_Memory;
# 88 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void*
  (*FT_Alloc_Func)( FT_Memory memory,
                    long size );
# 109 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void
  (*FT_Free_Func)( FT_Memory memory,
                   void* block );
# 142 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void*
  (*FT_Realloc_Func)( FT_Memory memory,
                      long cur_size,
                      long new_size,
                      void* block );
# 171 "../../../libs/freetype/include/freetype/ftsystem.h"
  struct FT_MemoryRec_
  {
    void* user;
    FT_Alloc_Func alloc;
    FT_Free_Func free;
    FT_Realloc_Func realloc;
  };
# 200 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_* FT_Stream;
# 213 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef union FT_StreamDesc_
  {
    long value;
    void* pointer;

  } FT_StreamDesc;
# 251 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream stream,
                       unsigned long offset,
                       unsigned char* buffer,
                       unsigned long count );
# 271 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream stream );
# 330 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_
  {
    unsigned char* base;
    unsigned long size;
    unsigned long pos;

    FT_StreamDesc descriptor;
    FT_StreamDesc pathname;
    FT_Stream_IoFunc read;
    FT_Stream_CloseFunc close;

    FT_Memory memory;
    unsigned char* cursor;
    unsigned char* limit;

  } FT_StreamRec;





# 26 "../../../libs/freetype/include/freetype/fttypes.h" 2
# 1 "../../../libs/freetype/include/freetype/ftimage.h" 1
# 37 "../../../libs/freetype/include/freetype/ftimage.h"

# 58 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef signed long FT_Pos;
# 74 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Vector_
  {
    FT_Pos x;
    FT_Pos y;

  } FT_Vector;
# 115 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_BBox_
  {
    FT_Pos xMin, yMin;
    FT_Pos xMax, yMax;

  } FT_BBox;
# 180 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef enum FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,

    FT_PIXEL_MODE_MAX

  } FT_Pixel_Mode;
# 261 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Bitmap_
  {
    unsigned int rows;
    unsigned int width;
    int pitch;
    unsigned char* buffer;
    unsigned short num_grays;
    unsigned char pixel_mode;
    unsigned char palette_mode;
    void* palette;

  } FT_Bitmap;
# 334 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_
  {
    short n_contours;
    short n_points;

    FT_Vector* points;
    char* tags;
    short* contours;

    int flags;

  } FT_Outline;
# 492 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector* to,
                            void* user );
# 519 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector* to,
                            void* user );
# 550 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector* control,
                             const FT_Vector* to,
                             void* user );
# 582 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector* control1,
                             const FT_Vector* control2,
                             const FT_Vector* to,
                             void* user );
# 628 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc move_to;
    FT_Outline_LineToFunc line_to;
    FT_Outline_ConicToFunc conic_to;
    FT_Outline_CubicToFunc cubic_to;

    int shift;
    FT_Pos delta;

  } FT_Outline_Funcs;
# 715 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef enum FT_Glyph_Format_
  {
    FT_GLYPH_FORMAT_NONE = ( ( (unsigned long)0 << 24 ) | ( (unsigned long)0 << 16 ) | ( (unsigned long)0 << 8 ) | (unsigned long)0 ),

    FT_GLYPH_FORMAT_COMPOSITE = ( ( (unsigned long)'c' << 24 ) | ( (unsigned long)'o' << 16 ) | ( (unsigned long)'m' << 8 ) | (unsigned long)'p' ),
    FT_GLYPH_FORMAT_BITMAP = ( ( (unsigned long)'b' << 24 ) | ( (unsigned long)'i' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'s' ),
    FT_GLYPH_FORMAT_OUTLINE = ( ( (unsigned long)'o' << 24 ) | ( (unsigned long)'u' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'l' ),
    FT_GLYPH_FORMAT_PLOTTER = ( ( (unsigned long)'p' << 24 ) | ( (unsigned long)'l' << 16 ) | ( (unsigned long)'o' << 8 ) | (unsigned long)'t' )

  } FT_Glyph_Format;
# 800 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_RasterRec_* FT_Raster;
# 828 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Span_
  {
    short x;
    unsigned short len;
    unsigned char coverage;

  } FT_Span;
# 873 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_SpanFunc)( int y,
                  int count,
                  const FT_Span* spans,
                  void* user );
# 890 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_BitTest_Func)( int y,
                             int x,
                             void* user );
# 904 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_BitSet_Func)( int y,
                            int x,
                            void* user );
# 1007 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Params_
  {
    const FT_Bitmap* target;
    const void* source;
    int flags;
    FT_SpanFunc gray_spans;
    FT_SpanFunc black_spans;
    FT_Raster_BitTest_Func bit_test;
    FT_Raster_BitSet_Func bit_set;
    void* user;
    FT_BBox clip_box;

  } FT_Raster_Params;
# 1046 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_NewFunc)( void* memory,
                        FT_Raster* raster );
# 1064 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster raster );
# 1096 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster raster,
                          unsigned char* pool_base,
                          unsigned long pool_size );
# 1122 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster raster,
                            unsigned long mode,
                            void* args );
# 1164 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster raster,
                           const FT_Raster_Params* params );
# 1190 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Funcs_
  {
    FT_Glyph_Format glyph_format;
    FT_Raster_NewFunc raster_new;
    FT_Raster_ResetFunc raster_reset;
    FT_Raster_SetModeFunc raster_set_mode;
    FT_Raster_RenderFunc raster_render;
    FT_Raster_DoneFunc raster_done;

  } FT_Raster_Funcs;





# 27 "../../../libs/freetype/include/freetype/fttypes.h" 2

# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 29 "../../../libs/freetype/include/freetype/fttypes.h" 2



# 108 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Bool;
# 120 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_FWord;
# 132 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UFWord;
# 143 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed char FT_Char;
# 154 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Byte;
# 165 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef const FT_Byte* FT_Bytes;
# 176 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef FT_UInt32 FT_Tag;
# 187 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef char FT_String;
# 198 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_Short;
# 209 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UShort;
# 220 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed int FT_Int;
# 231 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned int FT_UInt;
# 242 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Long;
# 253 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned long FT_ULong;
# 264 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_F2Dot14;
# 276 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_F26Dot6;
# 288 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Fixed;
# 300 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef int FT_Error;
# 311 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef void* FT_Pointer;
# 324 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef size_t FT_Offset;
# 337 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef ptrdiff_t FT_PtrDist;
# 354 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_UnitVector_
  {
    FT_F2Dot14 x;
    FT_F2Dot14 y;

  } FT_UnitVector;
# 385 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Matrix_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;

  } FT_Matrix;
# 406 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Data_
  {
    const FT_Byte* pointer;
    FT_Int length;

  } FT_Data;
# 428 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef void (*FT_Generic_Finalizer)(void* object);
# 459 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Generic_
  {
    void* data;
    FT_Generic_Finalizer finalizer;

  } FT_Generic;
# 515 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_* FT_ListNode;
# 526 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_* FT_List;
# 544 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_
  {
    FT_ListNode prev;
    FT_ListNode next;
    void* data;

  } FT_ListNodeRec;
# 567 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_
  {
    FT_ListNode head;
    FT_ListNode tail;

  } FT_ListRec;
# 597 "../../../libs/freetype/include/freetype/fttypes.h"

# 35 "../../../libs/freetype/include/freetype/freetype.h" 2
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 107 "../../../libs/freetype/include/freetype/fterrors.h"
# 1 "../../../libs/freetype/include/freetype/ftmoderr.h" 1
# 138 "../../../libs/freetype/include/freetype/ftmoderr.h"
  enum {



  FT_Mod_Err_Base = 0,
  FT_Mod_Err_Autofit = 0,
  FT_Mod_Err_BDF = 0,
  FT_Mod_Err_Bzip2 = 0,
  FT_Mod_Err_Cache = 0,
  FT_Mod_Err_CFF = 0,
  FT_Mod_Err_CID = 0,
  FT_Mod_Err_Gzip = 0,
  FT_Mod_Err_LZW = 0,
  FT_Mod_Err_OTvalid = 0,
  FT_Mod_Err_PCF = 0,
  FT_Mod_Err_PFR = 0,
  FT_Mod_Err_PSaux = 0,
  FT_Mod_Err_PShinter = 0,
  FT_Mod_Err_PSnames = 0,
  FT_Mod_Err_Raster = 0,
  FT_Mod_Err_SFNT = 0,
  FT_Mod_Err_Smooth = 0,
  FT_Mod_Err_TrueType = 0,
  FT_Mod_Err_Type1 = 0,
  FT_Mod_Err_Type42 = 0,
  FT_Mod_Err_Winfonts = 0,
  FT_Mod_Err_GXvalid = 0,



  FT_Mod_Err_Max };
# 108 "../../../libs/freetype/include/freetype/fterrors.h" 2
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  FT_Err_Ok = 0x00,


  FT_Err_Cannot_Open_Resource = 0x01 + 0,

  FT_Err_Unknown_File_Format = 0x02 + 0,

  FT_Err_Invalid_File_Format = 0x03 + 0,

  FT_Err_Invalid_Version = 0x04 + 0,

  FT_Err_Lower_Module_Version = 0x05 + 0,

  FT_Err_Invalid_Argument = 0x06 + 0,

  FT_Err_Unimplemented_Feature = 0x07 + 0,

  FT_Err_Invalid_Table = 0x08 + 0,

  FT_Err_Invalid_Offset = 0x09 + 0,

  FT_Err_Array_Too_Large = 0x0A + 0,

  FT_Err_Missing_Module = 0x0B + 0,

  FT_Err_Missing_Property = 0x0C + 0,




  FT_Err_Invalid_Glyph_Index = 0x10 + 0,

  FT_Err_Invalid_Character_Code = 0x11 + 0,

  FT_Err_Invalid_Glyph_Format = 0x12 + 0,

  FT_Err_Cannot_Render_Glyph = 0x13 + 0,

  FT_Err_Invalid_Outline = 0x14 + 0,

  FT_Err_Invalid_Composite = 0x15 + 0,

  FT_Err_Too_Many_Hints = 0x16 + 0,

  FT_Err_Invalid_Pixel_Size = 0x17 + 0,




  FT_Err_Invalid_Handle = 0x20 + 0,

  FT_Err_Invalid_Library_Handle = 0x21 + 0,

  FT_Err_Invalid_Driver_Handle = 0x22 + 0,

  FT_Err_Invalid_Face_Handle = 0x23 + 0,

  FT_Err_Invalid_Size_Handle = 0x24 + 0,

  FT_Err_Invalid_Slot_Handle = 0x25 + 0,

  FT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  FT_Err_Invalid_Cache_Handle = 0x27 + 0,

  FT_Err_Invalid_Stream_Handle = 0x28 + 0,




  FT_Err_Too_Many_Drivers = 0x30 + 0,

  FT_Err_Too_Many_Extensions = 0x31 + 0,




  FT_Err_Out_Of_Memory = 0x40 + 0,

  FT_Err_Unlisted_Object = 0x41 + 0,




  FT_Err_Cannot_Open_Stream = 0x51 + 0,

  FT_Err_Invalid_Stream_Seek = 0x52 + 0,

  FT_Err_Invalid_Stream_Skip = 0x53 + 0,

  FT_Err_Invalid_Stream_Read = 0x54 + 0,

  FT_Err_Invalid_Stream_Operation = 0x55 + 0,

  FT_Err_Invalid_Frame_Operation = 0x56 + 0,

  FT_Err_Nested_Frame_Access = 0x57 + 0,

  FT_Err_Invalid_Frame_Read = 0x58 + 0,




  FT_Err_Raster_Uninitialized = 0x60 + 0,

  FT_Err_Raster_Corrupted = 0x61 + 0,

  FT_Err_Raster_Overflow = 0x62 + 0,

  FT_Err_Raster_Negative_Height = 0x63 + 0,




  FT_Err_Too_Many_Caches = 0x70 + 0,




  FT_Err_Invalid_Opcode = 0x80 + 0,

  FT_Err_Too_Few_Arguments = 0x81 + 0,

  FT_Err_Stack_Overflow = 0x82 + 0,

  FT_Err_Code_Overflow = 0x83 + 0,

  FT_Err_Bad_Argument = 0x84 + 0,

  FT_Err_Divide_By_Zero = 0x85 + 0,

  FT_Err_Invalid_Reference = 0x86 + 0,

  FT_Err_Debug_OpCode = 0x87 + 0,

  FT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  FT_Err_Nested_DEFS = 0x89 + 0,

  FT_Err_Invalid_CodeRange = 0x8A + 0,

  FT_Err_Execution_Too_Long = 0x8B + 0,

  FT_Err_Too_Many_Function_Defs = 0x8C + 0,

  FT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  FT_Err_Table_Missing = 0x8E + 0,

  FT_Err_Horiz_Header_Missing = 0x8F + 0,

  FT_Err_Locations_Missing = 0x90 + 0,

  FT_Err_Name_Table_Missing = 0x91 + 0,

  FT_Err_CMap_Table_Missing = 0x92 + 0,

  FT_Err_Hmtx_Table_Missing = 0x93 + 0,

  FT_Err_Post_Table_Missing = 0x94 + 0,

  FT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  FT_Err_Invalid_CharMap_Format = 0x96 + 0,

  FT_Err_Invalid_PPem = 0x97 + 0,

  FT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  FT_Err_Could_Not_Find_Context = 0x99 + 0,

  FT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  FT_Err_Invalid_Post_Table = 0x9B + 0,




  FT_Err_Syntax_Error = 0xA0 + 0,

  FT_Err_Stack_Underflow = 0xA1 + 0,

  FT_Err_Ignore = 0xA2 + 0,

  FT_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  FT_Err_Glyph_Too_Big = 0xA4 + 0,




  FT_Err_Missing_Startfont_Field = 0xB0 + 0,

  FT_Err_Missing_Font_Field = 0xB1 + 0,

  FT_Err_Missing_Size_Field = 0xB2 + 0,

  FT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  FT_Err_Missing_Chars_Field = 0xB4 + 0,

  FT_Err_Missing_Startchar_Field = 0xB5 + 0,

  FT_Err_Missing_Encoding_Field = 0xB6 + 0,

  FT_Err_Missing_Bbx_Field = 0xB7 + 0,

  FT_Err_Bbx_Too_Big = 0xB8 + 0,

  FT_Err_Corrupted_Font_Header = 0xB9 + 0,

  FT_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  FT_Err_Max };
# 36 "../../../libs/freetype/include/freetype/freetype.h" 2



# 309 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Glyph_Metrics_
  {
    FT_Pos width;
    FT_Pos height;

    FT_Pos horiBearingX;
    FT_Pos horiBearingY;
    FT_Pos horiAdvance;

    FT_Pos vertBearingX;
    FT_Pos vertBearingY;
    FT_Pos vertAdvance;

  } FT_Glyph_Metrics;
# 363 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Bitmap_Size_
  {
    FT_Short height;
    FT_Short width;

    FT_Pos size;

    FT_Pos x_ppem;
    FT_Pos y_ppem;

  } FT_Bitmap_Size;
# 409 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_LibraryRec_ *FT_Library;
# 429 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_ModuleRec_* FT_Module;
# 441 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_DriverRec_* FT_Driver;
# 455 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_RendererRec_* FT_Renderer;
# 495 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_* FT_Face;
# 526 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_* FT_Size;
# 547 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_* FT_GlyphSlot;
# 579 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_* FT_CharMap;
# 757 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Encoding_
  {
    FT_ENCODING_NONE = ( ( (FT_UInt32)(0) << 24 ) | ( (FT_UInt32)(0) << 16 ) | ( (FT_UInt32)(0) << 8 ) | (FT_UInt32)(0) ),

    FT_ENCODING_MS_SYMBOL = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('y') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('b') ),
    FT_ENCODING_UNICODE = ( ( (FT_UInt32)('u') << 24 ) | ( (FT_UInt32)('n') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('c') ),

    FT_ENCODING_SJIS = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('j') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_GB2312 = ( ( (FT_UInt32)('g') << 24 ) | ( (FT_UInt32)('b') << 16 ) | ( (FT_UInt32)(' ') << 8 ) | (FT_UInt32)(' ') ),
    FT_ENCODING_BIG5 = ( ( (FT_UInt32)('b') << 24 ) | ( (FT_UInt32)('i') << 16 ) | ( (FT_UInt32)('g') << 8 ) | (FT_UInt32)('5') ),
    FT_ENCODING_WANSUNG = ( ( (FT_UInt32)('w') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('n') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_JOHAB = ( ( (FT_UInt32)('j') << 24 ) | ( (FT_UInt32)('o') << 16 ) | ( (FT_UInt32)('h') << 8 ) | (FT_UInt32)('a') ),


    FT_ENCODING_MS_SJIS = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312 = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5 = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB = FT_ENCODING_JOHAB,

    FT_ENCODING_ADOBE_STANDARD = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('O') << 8 ) | (FT_UInt32)('B') ),
    FT_ENCODING_ADOBE_EXPERT = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('E') ),
    FT_ENCODING_ADOBE_CUSTOM = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('C') ),
    FT_ENCODING_ADOBE_LATIN_1 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('1') ),

    FT_ENCODING_OLD_LATIN_2 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('2') ),

    FT_ENCODING_APPLE_ROMAN = ( ( (FT_UInt32)('a') << 24 ) | ( (FT_UInt32)('r') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('n') )

  } FT_Encoding;
# 831 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_
  {
    FT_Face face;
    FT_Encoding encoding;
    FT_UShort platform_id;
    FT_UShort encoding_id;

  } FT_CharMapRec;
# 862 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Face_InternalRec_* FT_Face_Internal;
# 1034 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_
  {
    FT_Long num_faces;
    FT_Long face_index;

    FT_Long face_flags;
    FT_Long style_flags;

    FT_Long num_glyphs;

    FT_String* family_name;
    FT_String* style_name;

    FT_Int num_fixed_sizes;
    FT_Bitmap_Size* available_sizes;

    FT_Int num_charmaps;
    FT_CharMap* charmaps;

    FT_Generic generic;




    FT_BBox bbox;

    FT_UShort units_per_EM;
    FT_Short ascender;
    FT_Short descender;
    FT_Short height;

    FT_Short max_advance_width;
    FT_Short max_advance_height;

    FT_Short underline_position;
    FT_Short underline_thickness;

    FT_GlyphSlot glyph;
    FT_Size size;
    FT_CharMap charmap;



    FT_Driver driver;
    FT_Memory memory;
    FT_Stream stream;

    FT_ListRec sizes_list;

    FT_Generic autohint;
    void* extensions;

    FT_Face_Internal internal;



  } FT_FaceRec;
# 1443 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_InternalRec_* FT_Size_Internal;
# 1501 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_Metrics_
  {
    FT_UShort x_ppem;
    FT_UShort y_ppem;

    FT_Fixed x_scale;
    FT_Fixed y_scale;

    FT_Pos ascender;
    FT_Pos descender;
    FT_Pos height;
    FT_Pos max_advance;

  } FT_Size_Metrics;
# 1536 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_
  {
    FT_Face face;
    FT_Generic generic;
    FT_Size_Metrics metrics;
    FT_Size_Internal internal;

  } FT_SizeRec;
# 1562 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SubGlyphRec_* FT_SubGlyph;
# 1574 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Slot_InternalRec_* FT_Slot_Internal;
# 1745 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_
  {
    FT_Library library;
    FT_Face face;
    FT_GlyphSlot next;
    FT_UInt reserved;
    FT_Generic generic;

    FT_Glyph_Metrics metrics;
    FT_Fixed linearHoriAdvance;
    FT_Fixed linearVertAdvance;
    FT_Vector advance;

    FT_Glyph_Format format;

    FT_Bitmap bitmap;
    FT_Int bitmap_left;
    FT_Int bitmap_top;

    FT_Outline outline;

    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

    void* control_data;
    long control_len;

    FT_Pos lsb_delta;
    FT_Pos rsb_delta;

    void* other;

    FT_Slot_Internal internal;

  } FT_GlyphSlotRec;
# 1817 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Init_FreeType( FT_Library *alibrary );
# 1836 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Done_FreeType( FT_Library library );
# 1899 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Parameter_
  {
    FT_ULong tag;
    FT_Pointer data;

  } FT_Parameter;
# 1965 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Open_Args_
  {
    FT_UInt flags;
    const FT_Byte* memory_base;
    FT_Long memory_size;
    FT_String* pathname;
    FT_Stream stream;
    FT_Module driver;
    FT_Int num_params;
    FT_Parameter* params;

  } FT_Open_Args;
# 2007 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_New_Face( FT_Library library,
               const char* filepathname,
               FT_Long face_index,
               FT_Face *aface );
# 2044 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_New_Memory_Face( FT_Library library,
                      const FT_Byte* file_base,
                      FT_Long file_size,
                      FT_Long face_index,
                      FT_Face *aface );
# 2192 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Open_Face( FT_Library library,
                const FT_Open_Args* args,
                FT_Long face_index,
                FT_Face *aface );
# 2216 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Attach_File( FT_Face face,
                  const char* filepathname );
# 2251 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Attach_Stream( FT_Face face,
                    FT_Open_Args* parameters );
# 2279 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Reference_Face( FT_Face face );
# 2302 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Done_Face( FT_Face face );
# 2324 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Select_Size( FT_Face face,
                  FT_Int strike_index );
# 2371 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;
# 2411 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_
  {
    FT_Size_Request_Type type;
    FT_Long width;
    FT_Long height;
    FT_UInt horiResolution;
    FT_UInt vertResolution;

  } FT_Size_RequestRec;
# 2430 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_ *FT_Size_Request;
# 2464 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Request_Size( FT_Face face,
                   FT_Size_Request req );
# 2505 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Char_Size( FT_Face face,
                    FT_F26Dot6 char_width,
                    FT_F26Dot6 char_height,
                    FT_UInt horz_resolution,
                    FT_UInt vert_resolution );
# 2540 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Pixel_Sizes( FT_Face face,
                      FT_UInt pixel_width,
                      FT_UInt pixel_height );
# 2582 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Load_Glyph( FT_Face face,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );
# 2617 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Load_Char( FT_Face face,
                FT_ULong char_code,
                FT_Int32 load_flags );
# 2925 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Set_Transform( FT_Face face,
                    FT_Matrix* matrix,
                    FT_Vector* delta );
# 2989 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;
# 3111 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Render_Glyph( FT_GlyphSlot slot,
                   FT_Render_Mode render_mode );
# 3142 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;
# 3192 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Kerning( FT_Face face,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_UInt kern_mode,
                  FT_Vector *akerning );
# 3233 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Track_Kerning( FT_Face face,
                        FT_Fixed point_size,
                        FT_Int degree,
                        FT_Fixed* akerning );
# 3279 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Glyph_Name( FT_Face face,
                     FT_UInt glyph_index,
                     FT_Pointer buffer,
                     FT_UInt buffer_max );
# 3305 "../../../libs/freetype/include/freetype/freetype.h"
  extern const char*
  FT_Get_Postscript_Name( FT_Face face );
# 3337 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Select_Charmap( FT_Face face,
                     FT_Encoding encoding );
# 3366 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Charmap( FT_Face face,
                  FT_CharMap charmap );
# 3388 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Int
  FT_Get_Charmap_Index( FT_CharMap charmap );
# 3422 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Get_Char_Index( FT_Face face,
                     FT_ULong charcode );
# 3477 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_ULong
  FT_Get_First_Char( FT_Face face,
                     FT_UInt *agindex );
# 3511 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_ULong
  FT_Get_Next_Char( FT_Face face,
                    FT_ULong char_code,
                    FT_UInt *agindex );
# 3534 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Get_Name_Index( FT_Face face,
                     FT_String* glyph_name );
# 3610 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_SubGlyph_Info( FT_GlyphSlot glyph,
                        FT_UInt sub_index,
                        FT_Int *p_index,
                        FT_UInt *p_flags,
                        FT_Int *p_arg1,
                        FT_Int *p_arg2,
                        FT_Matrix *p_transform );
# 3705 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UShort
  FT_Get_FSType_Flags( FT_Face face );
# 3791 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Face_GetCharVariantIndex( FT_Face face,
                               FT_ULong charcode,
                               FT_ULong variantSelector );
# 3827 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Int
  FT_Face_GetCharVariantIsDefault( FT_Face face,
                                   FT_ULong charcode,
                                   FT_ULong variantSelector );
# 3858 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetVariantSelectors( FT_Face face );
# 3891 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetVariantsOfChar( FT_Face face,
                             FT_ULong charcode );
# 3925 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetCharsOfVariant( FT_Face face,
                             FT_ULong variantSelector );
# 3982 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_MulDiv( FT_Long a,
             FT_Long b,
             FT_Long c );
# 4017 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_MulFix( FT_Long a,
             FT_Long b );
# 4039 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_DivFix( FT_Long a,
             FT_Long b );
# 4059 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_RoundFix( FT_Fixed a );
# 4078 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_CeilFix( FT_Fixed a );
# 4097 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_FloorFix( FT_Fixed a );
# 4118 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Vector_Transform( FT_Vector* vec,
                       const FT_Matrix* matrix );
# 4208 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Library_Version( FT_Library library,
                      FT_Int *amajor,
                      FT_Int *aminor,
                      FT_Int *apatch );
# 4242 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Bool
  FT_Face_CheckTrueTypePatents( FT_Face face );
# 4272 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Bool
  FT_Face_SetUnpatentedHinting( FT_Face face,
                                FT_Bool value );





# 21 "../../../libs/freetype/src/truetype/ttpic.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
# 1 "../../../libs/freetype/include/freetype/ftrender.h" 1
# 24 "../../../libs/freetype/include/freetype/ftrender.h"
# 1 "../../../libs/freetype/include/freetype/ftmodapi.h" 1
# 33 "../../../libs/freetype/include/freetype/ftmodapi.h"

# 136 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Pointer FT_Module_Interface;
# 150 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Error
  (*FT_Module_Constructor)( FT_Module module );
# 165 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef void
  (*FT_Module_Destructor)( FT_Module module );
# 182 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Module_Interface
  (*FT_Module_Requester)( FT_Module module,
                          const char* name );
# 216 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef struct FT_Module_Class_
  {
    FT_ULong module_flags;
    FT_Long module_size;
    const FT_String* module_name;
    FT_Fixed module_version;
    FT_Fixed module_requires;

    const void* module_interface;

    FT_Module_Constructor module_init;
    FT_Module_Destructor module_done;
    FT_Module_Requester get_interface;

  } FT_Module_Class;
# 254 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Add_Module( FT_Library library,
                 const FT_Module_Class* clazz );
# 279 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Module
  FT_Get_Module( FT_Library library,
                 const char* module_name );
# 304 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Remove_Module( FT_Library library,
                    FT_Module module );
# 369 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Property_Set( FT_Library library,
                   const FT_String* module_name,
                   const FT_String* property_name,
                   const void* value );
# 433 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Property_Get( FT_Library library,
                   const FT_String* module_name,
                   const FT_String* property_name,
                   void* value );
# 463 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Reference_Library( FT_Library library );
# 499 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_New_Library( FT_Memory memory,
                  FT_Library *alibrary );
# 523 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Done_Library( FT_Library library );



  typedef void
  (*FT_DebugHook_Func)( void* arg );
# 559 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern void
  FT_Set_Debug_Hook( FT_Library library,
                     FT_UInt hook_index,
                     FT_DebugHook_Func debug_hook );
# 578 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern void
  FT_Add_Default_Modules( FT_Library library );
# 632 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef enum FT_TrueTypeEngineType_
  {
    FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED,
    FT_TRUETYPE_ENGINE_TYPE_PATENTED

  } FT_TrueTypeEngineType;
# 661 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_TrueTypeEngineType
  FT_Get_TrueType_Engine_Type( FT_Library library );





# 25 "../../../libs/freetype/include/freetype/ftrender.h" 2
# 1 "../../../libs/freetype/include/freetype/ftglyph.h" 1
# 46 "../../../libs/freetype/include/freetype/ftglyph.h"

# 69 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_Glyph_Class_ FT_Glyph_Class;
# 87 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_* FT_Glyph;
# 108 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_
  {
    FT_Library library;
    const FT_Glyph_Class* clazz;
    FT_Glyph_Format format;
    FT_Vector advance;

  } FT_GlyphRec;
# 127 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_* FT_BitmapGlyph;
# 160 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_
  {
    FT_GlyphRec root;
    FT_Int left;
    FT_Int top;
    FT_Bitmap bitmap;

  } FT_BitmapGlyphRec;
# 179 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_* FT_OutlineGlyph;
# 208 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_
  {
    FT_GlyphRec root;
    FT_Outline outline;

  } FT_OutlineGlyphRec;
# 234 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Get_Glyph( FT_GlyphSlot slot,
                FT_Glyph *aglyph );
# 258 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_Copy( FT_Glyph source,
                 FT_Glyph *target );
# 287 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_Transform( FT_Glyph glyph,
                      FT_Matrix* matrix,
                      FT_Vector* delta );
# 317 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef enum FT_Glyph_BBox_Mode_
  {
    FT_GLYPH_BBOX_UNSCALED = 0,
    FT_GLYPH_BBOX_SUBPIXELS = 0,
    FT_GLYPH_BBOX_GRIDFIT = 1,
    FT_GLYPH_BBOX_TRUNCATE = 2,
    FT_GLYPH_BBOX_PIXELS = 3

  } FT_Glyph_BBox_Mode;
# 406 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Glyph_Get_CBox( FT_Glyph glyph,
                     FT_UInt bbox_mode,
                     FT_BBox *acbox );
# 518 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_To_Bitmap( FT_Glyph* the_glyph,
                      FT_Render_Mode render_mode,
                      FT_Vector* origin,
                      FT_Bool destroy );
# 536 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Done_Glyph( FT_Glyph glyph );
# 569 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Matrix_Multiply( const FT_Matrix* a,
                      FT_Matrix* b );
# 589 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Matrix_Invert( FT_Matrix* matrix );





# 26 "../../../libs/freetype/include/freetype/ftrender.h" 2



# 40 "../../../libs/freetype/include/freetype/ftrender.h"
  typedef FT_Error
  (*FT_Glyph_InitFunc)( FT_Glyph glyph,
                        FT_GlyphSlot slot );


  typedef void
  (*FT_Glyph_DoneFunc)( FT_Glyph glyph );

  typedef void
  (*FT_Glyph_TransformFunc)( FT_Glyph glyph,
                             const FT_Matrix* matrix,
                             const FT_Vector* delta );

  typedef void
  (*FT_Glyph_GetBBoxFunc)( FT_Glyph glyph,
                           FT_BBox* abbox );

  typedef FT_Error
  (*FT_Glyph_CopyFunc)( FT_Glyph source,
                        FT_Glyph target );

  typedef FT_Error
  (*FT_Glyph_PrepareFunc)( FT_Glyph glyph,
                           FT_GlyphSlot slot );
# 74 "../../../libs/freetype/include/freetype/ftrender.h"
  struct FT_Glyph_Class_
  {
    FT_Long glyph_size;
    FT_Glyph_Format glyph_format;
    FT_Glyph_InitFunc glyph_init;
    FT_Glyph_DoneFunc glyph_done;
    FT_Glyph_CopyFunc glyph_copy;
    FT_Glyph_TransformFunc glyph_transform;
    FT_Glyph_GetBBoxFunc glyph_bbox;
    FT_Glyph_PrepareFunc glyph_prepare;
  };


  typedef FT_Error
  (*FT_Renderer_RenderFunc)( FT_Renderer renderer,
                             FT_GlyphSlot slot,
                             FT_UInt mode,
                             const FT_Vector* origin );

  typedef FT_Error
  (*FT_Renderer_TransformFunc)( FT_Renderer renderer,
                                FT_GlyphSlot slot,
                                const FT_Matrix* matrix,
                                const FT_Vector* delta );


  typedef void
  (*FT_Renderer_GetCBoxFunc)( FT_Renderer renderer,
                              FT_GlyphSlot slot,
                              FT_BBox* cbox );


  typedef FT_Error
  (*FT_Renderer_SetModeFunc)( FT_Renderer renderer,
                              FT_ULong mode_tag,
                              FT_Pointer mode_ptr );
# 144 "../../../libs/freetype/include/freetype/ftrender.h"
  typedef struct FT_Renderer_Class_
  {
    FT_Module_Class root;

    FT_Glyph_Format glyph_format;

    FT_Renderer_RenderFunc render_glyph;
    FT_Renderer_TransformFunc transform_glyph;
    FT_Renderer_GetCBoxFunc get_glyph_cbox;
    FT_Renderer_SetModeFunc set_mode;

    FT_Raster_Funcs* raster_class;

  } FT_Renderer_Class;
# 183 "../../../libs/freetype/include/freetype/ftrender.h"
  extern FT_Renderer
  FT_Get_Renderer( FT_Library library,
                   FT_Glyph_Format format );
# 218 "../../../libs/freetype/include/freetype/ftrender.h"
  extern FT_Error
  FT_Set_Renderer( FT_Library library,
                   FT_Renderer renderer,
                   FT_UInt num_params,
                   FT_Parameter* parameters );





# 31 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/ftsizes.h" 1
# 42 "../../../libs/freetype/include/freetype/ftsizes.h"

# 99 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_New_Size( FT_Face face,
               FT_Size* size );
# 120 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_Done_Size( FT_Size size );
# 148 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_Activate_Size( FT_Size size );





# 32 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/ftlcdfil.h" 1
# 33 "../../../libs/freetype/include/freetype/ftlcdfil.h"

# 173 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  typedef enum FT_LcdFilter_
  {
    FT_LCD_FILTER_NONE = 0,
    FT_LCD_FILTER_DEFAULT = 1,
    FT_LCD_FILTER_LIGHT = 2,
    FT_LCD_FILTER_LEGACY1 = 3,
    FT_LCD_FILTER_LEGACY = 16,

    FT_LCD_FILTER_MAX

  } FT_LcdFilter;
# 240 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  extern FT_Error
  FT_Library_SetLcdFilter( FT_Library library,
                           FT_LcdFilter filter );
# 281 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  extern FT_Error
  FT_Library_SetLcdFilterWeights( FT_Library library,
                                  unsigned char *weights );





# 33 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftmemory.h" 1
# 28 "../../../libs/freetype/include/freetype/internal/ftmemory.h"

# 113 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_alloc( FT_Memory memory,
                FT_Long size,
                FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qalloc( FT_Memory memory,
                 FT_Long size,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_realloc( FT_Memory memory,
                  FT_Long item_size,
                  FT_Long cur_count,
                  FT_Long new_count,
                  void* block,
                  FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qrealloc( FT_Memory memory,
                   FT_Long item_size,
                   FT_Long cur_count,
                   FT_Long new_count,
                   void* block,
                   FT_Error *p_error );

  extern void
  ft_mem_free( FT_Memory memory,
               const void* P );
# 342 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_strdup( FT_Memory memory,
                 const char* str,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_dup( FT_Memory memory,
              const void* address,
              FT_ULong size,
              FT_Error *p_error );
# 370 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Int
  ft_mem_strcpyn( char* dst,
                  const char* src,
                  FT_ULong size );








# 34 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftgloadr.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"

# 43 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_GlyphLoaderRec_* FT_GlyphLoader ;
# 57 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_SubGlyphRec_
  {
    FT_Int index;
    FT_UShort flags;
    FT_Int arg1;
    FT_Int arg2;
    FT_Matrix transform;

  } FT_SubGlyphRec;


  typedef struct FT_GlyphLoadRec_
  {
    FT_Outline outline;
    FT_Vector* extra_points;
    FT_Vector* extra_points2;
    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

  } FT_GlyphLoadRec, *FT_GlyphLoad;


  typedef struct FT_GlyphLoaderRec_
  {
    FT_Memory memory;
    FT_UInt max_points;
    FT_UInt max_contours;
    FT_UInt max_subglyphs;
    FT_Bool use_extra;

    FT_GlyphLoadRec base;
    FT_GlyphLoadRec current;

    void* other;

  } FT_GlyphLoaderRec;



  extern FT_Error
  FT_GlyphLoader_New( FT_Memory memory,
                      FT_GlyphLoader *aloader );


  extern FT_Error
  FT_GlyphLoader_CreateExtra( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Done( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Reset( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Rewind( FT_GlyphLoader loader );



  extern FT_Error
  FT_GlyphLoader_CheckPoints( FT_GlyphLoader loader,
                              FT_UInt n_points,
                              FT_UInt n_contours );
# 147 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  extern FT_Error
  FT_GlyphLoader_CheckSubGlyphs( FT_GlyphLoader loader,
                                 FT_UInt n_subs );


  extern void
  FT_GlyphLoader_Prepare( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Add( FT_GlyphLoader loader );


  extern FT_Error
  FT_GlyphLoader_CopyPoints( FT_GlyphLoader target,
                             FT_GlyphLoader source );





# 35 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftdriver.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftdriver.h"



  typedef FT_Error
  (*FT_Face_InitFunc)( FT_Stream stream,
                       FT_Face face,
                       FT_Int typeface_index,
                       FT_Int num_params,
                       FT_Parameter* parameters );

  typedef void
  (*FT_Face_DoneFunc)( FT_Face face );


  typedef FT_Error
  (*FT_Size_InitFunc)( FT_Size size );

  typedef void
  (*FT_Size_DoneFunc)( FT_Size size );


  typedef FT_Error
  (*FT_Slot_InitFunc)( FT_GlyphSlot slot );

  typedef void
  (*FT_Slot_DoneFunc)( FT_GlyphSlot slot );


  typedef FT_Error
  (*FT_Size_RequestFunc)( FT_Size size,
                          FT_Size_Request req );

  typedef FT_Error
  (*FT_Size_SelectFunc)( FT_Size size,
                         FT_ULong size_index );

  typedef FT_Error
  (*FT_Slot_LoadFunc)( FT_GlyphSlot slot,
                       FT_Size size,
                       FT_UInt glyph_index,
                       FT_Int32 load_flags );


  typedef FT_UInt
  (*FT_CharMap_CharIndexFunc)( FT_CharMap charmap,
                               FT_Long charcode );

  typedef FT_Long
  (*FT_CharMap_CharNextFunc)( FT_CharMap charmap,
                              FT_Long charcode );


  typedef FT_Error
  (*FT_Face_GetKerningFunc)( FT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph,
                             FT_Vector* kerning );


  typedef FT_Error
  (*FT_Face_AttachFunc)( FT_Face face,
                         FT_Stream stream );


  typedef FT_Error
  (*FT_Face_GetAdvancesFunc)( FT_Face face,
                              FT_UInt first,
                              FT_UInt count,
                              FT_Int32 flags,
                              FT_Fixed* advances );
# 166 "../../../libs/freetype/include/freetype/internal/ftdriver.h"
  typedef struct FT_Driver_ClassRec_
  {
    FT_Module_Class root;

    FT_Long face_object_size;
    FT_Long size_object_size;
    FT_Long slot_object_size;

    FT_Face_InitFunc init_face;
    FT_Face_DoneFunc done_face;

    FT_Size_InitFunc init_size;
    FT_Size_DoneFunc done_size;

    FT_Slot_InitFunc init_slot;
    FT_Slot_DoneFunc done_slot;

    FT_Slot_LoadFunc load_glyph;

    FT_Face_GetKerningFunc get_kerning;
    FT_Face_AttachFunc attach_file;
    FT_Face_GetAdvancesFunc get_advances;


    FT_Size_RequestFunc request_size;
    FT_Size_SelectFunc select_size;

  } FT_Driver_ClassRec, *FT_Driver_Class;
# 404 "../../../libs/freetype/include/freetype/internal/ftdriver.h"

# 36 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/autohint.h" 1
# 77 "../../../libs/freetype/include/freetype/internal/autohint.h"



  typedef struct FT_AutoHinterRec_ *FT_AutoHinter;
# 104 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalGetFunc)( FT_AutoHinter hinter,
                                  FT_Face face,
                                  void** global_hints,
                                  long* global_len );
# 126 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalDoneFunc)( FT_AutoHinter hinter,
                                   void* global );
# 146 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalResetFunc)( FT_AutoHinter hinter,
                                    FT_Face face );
# 174 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef FT_Error
  (*FT_AutoHinter_GlyphLoadFunc)( FT_AutoHinter hinter,
                                  FT_GlyphSlot slot,
                                  FT_Size size,
                                  FT_UInt glyph_index,
                                  FT_Int32 load_flags );
# 190 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef struct FT_AutoHinter_InterfaceRec_
  {
    FT_AutoHinter_GlobalResetFunc reset_face;
    FT_AutoHinter_GlobalGetFunc get_global_hints;
    FT_AutoHinter_GlobalDoneFunc done_global_hints;
    FT_AutoHinter_GlyphLoadFunc load_glyph;

  } FT_AutoHinter_InterfaceRec, *FT_AutoHinter_Interface;
# 239 "../../../libs/freetype/include/freetype/internal/autohint.h"

# 37 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftserv.h" 1
# 35 "../../../libs/freetype/include/freetype/internal/ftserv.h"

# 150 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceDescRec_
  {
    const char* serv_id;
    const void* serv_data;

  } FT_ServiceDescRec;

  typedef const FT_ServiceDescRec* FT_ServiceDesc;
# 608 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  extern FT_Pointer
  ft_service_list_lookup( FT_ServiceDesc service_descriptors,
                          const char* service_id );
# 634 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceCacheRec_
  {
    FT_Pointer service_POSTSCRIPT_FONT_NAME;
    FT_Pointer service_MULTI_MASTERS;
    FT_Pointer service_GLYPH_DICT;
    FT_Pointer service_PFR_METRICS;
    FT_Pointer service_WINFNT;

  } FT_ServiceCacheRec, *FT_ServiceCache;
# 758 "../../../libs/freetype/include/freetype/internal/ftserv.h"

# 38 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftpic.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/ftpic.h"

# 66 "../../../libs/freetype/include/freetype/internal/ftpic.h"

# 39 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2


# 1 "../../../libs/freetype/include/freetype/ftincrem.h" 1
# 32 "../../../libs/freetype/include/freetype/ftincrem.h"

# 84 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_IncrementalRec_* FT_Incremental;
# 115 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_MetricsRec_
  {
    FT_Long bearing_x;
    FT_Long bearing_y;
    FT_Long advance;
    FT_Long advance_v;

  } FT_Incremental_MetricsRec;
# 134 "../../../libs/freetype/include/freetype/ftincrem.h"
   typedef struct FT_Incremental_MetricsRec_* FT_Incremental_Metrics;
# 178 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Error
  (*FT_Incremental_GetGlyphDataFunc)( FT_Incremental incremental,
                                      FT_UInt glyph_index,
                                      FT_Data* adata );
# 203 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef void
  (*FT_Incremental_FreeGlyphDataFunc)( FT_Incremental incremental,
                                       FT_Data* data );
# 240 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Error
  (*FT_Incremental_GetGlyphMetricsFunc)
                      ( FT_Incremental incremental,
                        FT_UInt glyph_index,
                        FT_Bool vertical,
                        FT_Incremental_MetricsRec *ametrics );
# 269 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_FuncsRec_
  {
    FT_Incremental_GetGlyphDataFunc get_glyph_data;
    FT_Incremental_FreeGlyphDataFunc free_glyph_data;
    FT_Incremental_GetGlyphMetricsFunc get_glyph_metrics;

  } FT_Incremental_FuncsRec;
# 314 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_InterfaceRec_
  {
    const FT_Incremental_FuncsRec* funcs;
    FT_Incremental object;

  } FT_Incremental_InterfaceRec;
# 331 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Incremental_InterfaceRec* FT_Incremental_Interface;
# 349 "../../../libs/freetype/include/freetype/ftincrem.h"

# 42 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2




# 128 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_CMapRec_* FT_CMap;


  typedef const struct FT_CMap_ClassRec_* FT_CMap_Class;


  typedef struct FT_CMapRec_
  {
    FT_CharMapRec charmap;
    FT_CMap_Class clazz;

  } FT_CMapRec;
# 152 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef FT_Error
  (*FT_CMap_InitFunc)( FT_CMap cmap,
                       FT_Pointer init_data );

  typedef void
  (*FT_CMap_DoneFunc)( FT_CMap cmap );

  typedef FT_UInt
  (*FT_CMap_CharIndexFunc)( FT_CMap cmap,
                            FT_UInt32 char_code );

  typedef FT_UInt
  (*FT_CMap_CharNextFunc)( FT_CMap cmap,
                           FT_UInt32 *achar_code );

  typedef FT_UInt
  (*FT_CMap_CharVarIndexFunc)( FT_CMap cmap,
                               FT_CMap unicode_cmap,
                               FT_UInt32 char_code,
                               FT_UInt32 variant_selector );

  typedef FT_Bool
  (*FT_CMap_CharVarIsDefaultFunc)( FT_CMap cmap,
                                   FT_UInt32 char_code,
                                   FT_UInt32 variant_selector );

  typedef FT_UInt32 *
  (*FT_CMap_VariantListFunc)( FT_CMap cmap,
                              FT_Memory mem );

  typedef FT_UInt32 *
  (*FT_CMap_CharVariantListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 char_code );

  typedef FT_UInt32 *
  (*FT_CMap_VariantCharListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 variant_selector );


  typedef struct FT_CMap_ClassRec_
  {
    FT_ULong size;
    FT_CMap_InitFunc init;
    FT_CMap_DoneFunc done;
    FT_CMap_CharIndexFunc char_index;
    FT_CMap_CharNextFunc char_next;




    FT_CMap_CharVarIndexFunc char_var_index;
    FT_CMap_CharVarIsDefaultFunc char_var_default;
    FT_CMap_VariantListFunc variant_list;
    FT_CMap_CharVariantListFunc charvariant_list;
    FT_CMap_VariantCharListFunc variantchar_list;

  } FT_CMap_ClassRec;
# 286 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_CMap_New( FT_CMap_Class clazz,
               FT_Pointer init_data,
               FT_CharMap charmap,
               FT_CMap *acmap );


  extern void
  FT_CMap_Done( FT_CMap cmap );
# 356 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Face_InternalRec_
  {
    FT_Matrix transform_matrix;
    FT_Vector transform_delta;
    FT_Int transform_flags;

    FT_ServiceCacheRec services;


    FT_Incremental_InterfaceRec* incremental_interface;


    FT_Bool ignore_unpatented_hinter;
    FT_Int refcount;

  } FT_Face_InternalRec;
# 410 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Slot_InternalRec_
  {
    FT_GlyphLoader loader;
    FT_UInt flags;
    FT_Bool glyph_transformed;
    FT_Matrix glyph_matrix;
    FT_Vector glyph_delta;
    void* glyph_hints;

  } FT_GlyphSlot_InternalRec;
# 472 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_ModuleRec_
  {
    FT_Module_Class* clazz;
    FT_Library library;
    FT_Memory memory;

  } FT_ModuleRec;
# 534 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern const void*
  FT_Get_Module_Interface( FT_Library library,
                           const char* mod_name );

  extern FT_Pointer
  ft_module_get_service( FT_Module module,
                         const char* service_id );
# 595 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_New_GlyphSlot( FT_Face face,
                    FT_GlyphSlot *aslot );
# 613 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_GlyphSlot( FT_GlyphSlot slot );
# 630 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Select_Metrics( FT_Face face,
                     FT_ULong strike_index );



  extern void
  FT_Request_Metrics( FT_Face face,
                      FT_Size_Request req );



  extern FT_Error
  FT_Match_Size( FT_Face face,
                 FT_Size_Request req,
                 FT_Bool ignore_width,
                 FT_ULong* size_index );




  extern void
  ft_synthesize_vertical_metrics( FT_Glyph_Metrics* metrics,
                                  FT_Pos advance );




  extern void
  ft_glyphslot_free_bitmap( FT_GlyphSlot slot );



  extern FT_Error
  ft_glyphslot_alloc_bitmap( FT_GlyphSlot slot,
                             FT_ULong size );




  extern void
  ft_glyphslot_set_bitmap( FT_GlyphSlot slot,
                           FT_Byte* buffer );
# 694 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_RendererRec_
  {
    FT_ModuleRec root;
    FT_Renderer_Class* clazz;
    FT_Glyph_Format glyph_format;
    FT_Glyph_Class glyph_class;

    FT_Raster raster;
    FT_Raster_RenderFunc raster_render;
    FT_Renderer_RenderFunc render;

  } FT_RendererRec;
# 750 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_DriverRec_
  {
    FT_ModuleRec root;
    FT_Driver_Class clazz;
    FT_ListRec faces_list;
    FT_GlyphLoader glyph_loader;

  } FT_DriverRec;
# 785 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef void (*FT_Bitmap_LcdFilterFunc)( FT_Bitmap* bitmap,
                                            FT_Render_Mode render_mode,
                                            FT_Library library );
# 859 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_LibraryRec_
  {
    FT_Memory memory;

    FT_Int version_major;
    FT_Int version_minor;
    FT_Int version_patch;

    FT_UInt num_modules;
    FT_Module modules[32];

    FT_ListRec renderers;
    FT_Renderer cur_renderer;
    FT_Module auto_hinter;

    FT_Byte* raster_pool;

    FT_ULong raster_pool_size;

    FT_DebugHook_Func debug_hooks[4];


    FT_LcdFilter lcd_filter;
    FT_Int lcd_extra;
    FT_Byte lcd_weights[7];
    FT_Bitmap_LcdFilterFunc lcd_filter_func;






    FT_Int refcount;

  } FT_LibraryRec;


  extern FT_Renderer
  FT_Lookup_Renderer( FT_Library library,
                      FT_Glyph_Format format,
                      FT_ListNode* node );

  extern FT_Error
  FT_Render_Glyph_Internal( FT_Library library,
                            FT_GlyphSlot slot,
                            FT_Render_Mode render_mode );

  typedef const char*
  (*FT_Face_GetPostscriptNameFunc)( FT_Face face );

  typedef FT_Error
  (*FT_Face_GetGlyphNameFunc)( FT_Face face,
                               FT_UInt glyph_index,
                               FT_Pointer buffer,
                               FT_UInt buffer_max );

  typedef FT_UInt
  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face face,
                                    FT_String* glyph_name );
# 933 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Memory
  FT_New_Memory( void );
# 948 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_Memory( FT_Memory memory );
# 961 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Raster_Funcs ft_default_raster;
# 1569 "../../../libs/freetype/include/freetype/internal/ftobjs.h"

# 22 "../../../libs/freetype/src/truetype/ttpic.c" 2
# 1 "../../../libs/freetype/src/truetype/ttpic.h" 1
# 23 "../../../libs/freetype/src/truetype/ttpic.c" 2
# 1 "../../../libs/freetype/src/truetype/tterrors.h" 1
# 37 "../../../libs/freetype/src/truetype/tterrors.h"
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  TT_Err_Ok = 0x00,


  TT_Err_Cannot_Open_Resource = 0x01 + 0,

  TT_Err_Unknown_File_Format = 0x02 + 0,

  TT_Err_Invalid_File_Format = 0x03 + 0,

  TT_Err_Invalid_Version = 0x04 + 0,

  TT_Err_Lower_Module_Version = 0x05 + 0,

  TT_Err_Invalid_Argument = 0x06 + 0,

  TT_Err_Unimplemented_Feature = 0x07 + 0,

  TT_Err_Invalid_Table = 0x08 + 0,

  TT_Err_Invalid_Offset = 0x09 + 0,

  TT_Err_Array_Too_Large = 0x0A + 0,

  TT_Err_Missing_Module = 0x0B + 0,

  TT_Err_Missing_Property = 0x0C + 0,




  TT_Err_Invalid_Glyph_Index = 0x10 + 0,

  TT_Err_Invalid_Character_Code = 0x11 + 0,

  TT_Err_Invalid_Glyph_Format = 0x12 + 0,

  TT_Err_Cannot_Render_Glyph = 0x13 + 0,

  TT_Err_Invalid_Outline = 0x14 + 0,

  TT_Err_Invalid_Composite = 0x15 + 0,

  TT_Err_Too_Many_Hints = 0x16 + 0,

  TT_Err_Invalid_Pixel_Size = 0x17 + 0,




  TT_Err_Invalid_Handle = 0x20 + 0,

  TT_Err_Invalid_Library_Handle = 0x21 + 0,

  TT_Err_Invalid_Driver_Handle = 0x22 + 0,

  TT_Err_Invalid_Face_Handle = 0x23 + 0,

  TT_Err_Invalid_Size_Handle = 0x24 + 0,

  TT_Err_Invalid_Slot_Handle = 0x25 + 0,

  TT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  TT_Err_Invalid_Cache_Handle = 0x27 + 0,

  TT_Err_Invalid_Stream_Handle = 0x28 + 0,




  TT_Err_Too_Many_Drivers = 0x30 + 0,

  TT_Err_Too_Many_Extensions = 0x31 + 0,




  TT_Err_Out_Of_Memory = 0x40 + 0,

  TT_Err_Unlisted_Object = 0x41 + 0,




  TT_Err_Cannot_Open_Stream = 0x51 + 0,

  TT_Err_Invalid_Stream_Seek = 0x52 + 0,

  TT_Err_Invalid_Stream_Skip = 0x53 + 0,

  TT_Err_Invalid_Stream_Read = 0x54 + 0,

  TT_Err_Invalid_Stream_Operation = 0x55 + 0,

  TT_Err_Invalid_Frame_Operation = 0x56 + 0,

  TT_Err_Nested_Frame_Access = 0x57 + 0,

  TT_Err_Invalid_Frame_Read = 0x58 + 0,




  TT_Err_Raster_Uninitialized = 0x60 + 0,

  TT_Err_Raster_Corrupted = 0x61 + 0,

  TT_Err_Raster_Overflow = 0x62 + 0,

  TT_Err_Raster_Negative_Height = 0x63 + 0,




  TT_Err_Too_Many_Caches = 0x70 + 0,




  TT_Err_Invalid_Opcode = 0x80 + 0,

  TT_Err_Too_Few_Arguments = 0x81 + 0,

  TT_Err_Stack_Overflow = 0x82 + 0,

  TT_Err_Code_Overflow = 0x83 + 0,

  TT_Err_Bad_Argument = 0x84 + 0,

  TT_Err_Divide_By_Zero = 0x85 + 0,

  TT_Err_Invalid_Reference = 0x86 + 0,

  TT_Err_Debug_OpCode = 0x87 + 0,

  TT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  TT_Err_Nested_DEFS = 0x89 + 0,

  TT_Err_Invalid_CodeRange = 0x8A + 0,

  TT_Err_Execution_Too_Long = 0x8B + 0,

  TT_Err_Too_Many_Function_Defs = 0x8C + 0,

  TT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  TT_Err_Table_Missing = 0x8E + 0,

  TT_Err_Horiz_Header_Missing = 0x8F + 0,

  TT_Err_Locations_Missing = 0x90 + 0,

  TT_Err_Name_Table_Missing = 0x91 + 0,

  TT_Err_CMap_Table_Missing = 0x92 + 0,

  TT_Err_Hmtx_Table_Missing = 0x93 + 0,

  TT_Err_Post_Table_Missing = 0x94 + 0,

  TT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  TT_Err_Invalid_CharMap_Format = 0x96 + 0,

  TT_Err_Invalid_PPem = 0x97 + 0,

  TT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  TT_Err_Could_Not_Find_Context = 0x99 + 0,

  TT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  TT_Err_Invalid_Post_Table = 0x9B + 0,




  TT_Err_Syntax_Error = 0xA0 + 0,

  TT_Err_Stack_Underflow = 0xA1 + 0,

  TT_Err_Ignore = 0xA2 + 0,

  TT_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  TT_Err_Glyph_Too_Big = 0xA4 + 0,




  TT_Err_Missing_Startfont_Field = 0xB0 + 0,

  TT_Err_Missing_Font_Field = 0xB1 + 0,

  TT_Err_Missing_Size_Field = 0xB2 + 0,

  TT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  TT_Err_Missing_Chars_Field = 0xB4 + 0,

  TT_Err_Missing_Startchar_Field = 0xB5 + 0,

  TT_Err_Missing_Encoding_Field = 0xB6 + 0,

  TT_Err_Missing_Bbx_Field = 0xB7 + 0,

  TT_Err_Bbx_Too_Big = 0xB8 + 0,

  TT_Err_Corrupted_Font_Header = 0xB9 + 0,

  TT_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  TT_Err_Max };
# 38 "../../../libs/freetype/src/truetype/tterrors.h" 2
# 24 "../../../libs/freetype/src/truetype/ttpic.c" 2
# 23 "../../../libs/freetype/src/truetype/truetype.c" 2
# 1 "../../../libs/freetype/src/truetype/ttdriver.c" 1
# 20 "../../../libs/freetype/src/truetype/ttdriver.c"
# 1 "../../../libs/freetype/include/freetype/internal/ftdebug.h" 1
# 33 "../../../libs/freetype/include/freetype/internal/ftdebug.h"

# 116 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern FT_Int
  FT_Trace_Get_Count( void );
# 143 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern const char*
  FT_Trace_Get_Name( FT_Int idx );
# 247 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern void
  ft_debug_init( void );


# 21 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftstream.h" 1
# 28 "../../../libs/freetype/include/freetype/internal/ftstream.h"

# 57 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  typedef enum FT_Frame_Op_
  {
    ft_frame_end = 0,
    ft_frame_start = ( ( 1 << 2 ) | ( 0 << 1 ) | 0 ),

    ft_frame_byte = ( ( 2 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_schar = ( ( 2 << 2 ) | ( 0 << 1 ) | 1 ),

    ft_frame_ushort_be = ( ( 3 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_short_be = ( ( 3 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_ushort_le = ( ( 3 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_short_le = ( ( 3 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_ulong_be = ( ( 4 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_long_be = ( ( 4 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_ulong_le = ( ( 4 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_long_le = ( ( 4 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_uoff3_be = ( ( 5 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_off3_be = ( ( 5 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_uoff3_le = ( ( 5 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_off3_le = ( ( 5 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_bytes = ( ( 6 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_skip = ( ( 6 << 2 ) | ( 0 << 1 ) | 1 )

  } FT_Frame_Op;


  typedef struct FT_Frame_Field_
  {
    FT_Byte value;
    FT_Byte size;
    FT_UShort offset;

  } FT_Frame_Field;
# 324 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_Open( FT_Stream stream,
                  const char* filepathname );





  extern FT_Error
  FT_Stream_New( FT_Library library,
                 const FT_Open_Args* args,
                 FT_Stream *astream );


  extern void
  FT_Stream_Free( FT_Stream stream,
                  FT_Int external );


  extern void
  FT_Stream_OpenMemory( FT_Stream stream,
                        const FT_Byte* base,
                        FT_ULong size );


  extern void
  FT_Stream_Close( FT_Stream stream );



  extern FT_Error
  FT_Stream_Seek( FT_Stream stream,
                  FT_ULong pos );


  extern FT_Error
  FT_Stream_Skip( FT_Stream stream,
                  FT_Long distance );


  extern FT_ULong
  FT_Stream_Pos( FT_Stream stream );



  extern FT_Error
  FT_Stream_Read( FT_Stream stream,
                  FT_Byte* buffer,
                  FT_ULong count );


  extern FT_Error
  FT_Stream_ReadAt( FT_Stream stream,
                    FT_ULong pos,
                    FT_Byte* buffer,
                    FT_ULong count );



  extern FT_ULong
  FT_Stream_TryRead( FT_Stream stream,
                     FT_Byte* buffer,
                     FT_ULong count );
# 396 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_EnterFrame( FT_Stream stream,
                        FT_ULong count );


  extern void
  FT_Stream_ExitFrame( FT_Stream stream );
# 413 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_ExtractFrame( FT_Stream stream,
                          FT_ULong count,
                          FT_Byte** pbytes );


  extern void
  FT_Stream_ReleaseFrame( FT_Stream stream,
                          FT_Byte** pbytes );


  extern FT_Char
  FT_Stream_GetChar( FT_Stream stream );


  extern FT_UShort
  FT_Stream_GetUShort( FT_Stream stream );


  extern FT_ULong
  FT_Stream_GetUOffset( FT_Stream stream );


  extern FT_ULong
  FT_Stream_GetULong( FT_Stream stream );


  extern FT_UShort
  FT_Stream_GetUShortLE( FT_Stream stream );


  extern FT_ULong
  FT_Stream_GetULongLE( FT_Stream stream );



  extern FT_Char
  FT_Stream_ReadChar( FT_Stream stream,
                      FT_Error* error );


  extern FT_UShort
  FT_Stream_ReadUShort( FT_Stream stream,
                        FT_Error* error );


  extern FT_ULong
  FT_Stream_ReadUOffset( FT_Stream stream,
                         FT_Error* error );


  extern FT_ULong
  FT_Stream_ReadULong( FT_Stream stream,
                       FT_Error* error );


  extern FT_UShort
  FT_Stream_ReadUShortLE( FT_Stream stream,
                          FT_Error* error );


  extern FT_ULong
  FT_Stream_ReadULongLE( FT_Stream stream,
                         FT_Error* error );



  extern FT_Error
  FT_Stream_ReadFields( FT_Stream stream,
                        const FT_Frame_Field* fields,
                        void* structure );
# 531 "../../../libs/freetype/include/freetype/internal/ftstream.h"

# 22 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/sfnt.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/sfnt.h"
# 1 "../../../libs/freetype/include/freetype/internal/tttypes.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/tttypes.h"
# 1 "../../../libs/freetype/include/freetype/tttables.h" 1
# 34 "../../../libs/freetype/include/freetype/tttables.h"

# 82 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_Header_
  {
    FT_Fixed Table_Version;
    FT_Fixed Font_Revision;

    FT_Long CheckSum_Adjust;
    FT_Long Magic_Number;

    FT_UShort Flags;
    FT_UShort Units_Per_EM;

    FT_Long Created [2];
    FT_Long Modified[2];

    FT_Short xMin;
    FT_Short yMin;
    FT_Short xMax;
    FT_Short yMax;

    FT_UShort Mac_Style;
    FT_UShort Lowest_Rec_PPEM;

    FT_Short Font_Direction;
    FT_Short Index_To_Loc_Format;
    FT_Short Glyph_Data_Format;

  } TT_Header;
# 199 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_HoriHeader_
  {
    FT_Fixed Version;
    FT_Short Ascender;
    FT_Short Descender;
    FT_Short Line_Gap;

    FT_UShort advance_Width_Max;

    FT_Short min_Left_Side_Bearing;
    FT_Short min_Right_Side_Bearing;
    FT_Short xMax_Extent;
    FT_Short caret_Slope_Rise;
    FT_Short caret_Slope_Run;
    FT_Short caret_Offset;

    FT_Short Reserved[4];

    FT_Short metric_Data_Format;
    FT_UShort number_Of_HMetrics;





    void* long_metrics;
    void* short_metrics;

  } TT_HoriHeader;
# 325 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_VertHeader_
  {
    FT_Fixed Version;
    FT_Short Ascender;
    FT_Short Descender;
    FT_Short Line_Gap;

    FT_UShort advance_Height_Max;

    FT_Short min_Top_Side_Bearing;
    FT_Short min_Bottom_Side_Bearing;
    FT_Short yMax_Extent;
    FT_Short caret_Slope_Rise;
    FT_Short caret_Slope_Run;
    FT_Short caret_Offset;

    FT_Short Reserved[4];

    FT_Short metric_Data_Format;
    FT_UShort number_Of_VMetrics;





    void* long_metrics;
    void* short_metrics;

  } TT_VertHeader;
# 368 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_OS2_
  {
    FT_UShort version;
    FT_Short xAvgCharWidth;
    FT_UShort usWeightClass;
    FT_UShort usWidthClass;
    FT_UShort fsType;
    FT_Short ySubscriptXSize;
    FT_Short ySubscriptYSize;
    FT_Short ySubscriptXOffset;
    FT_Short ySubscriptYOffset;
    FT_Short ySuperscriptXSize;
    FT_Short ySuperscriptYSize;
    FT_Short ySuperscriptXOffset;
    FT_Short ySuperscriptYOffset;
    FT_Short yStrikeoutSize;
    FT_Short yStrikeoutPosition;
    FT_Short sFamilyClass;

    FT_Byte panose[10];

    FT_ULong ulUnicodeRange1;
    FT_ULong ulUnicodeRange2;
    FT_ULong ulUnicodeRange3;
    FT_ULong ulUnicodeRange4;

    FT_Char achVendID[4];

    FT_UShort fsSelection;
    FT_UShort usFirstCharIndex;
    FT_UShort usLastCharIndex;
    FT_Short sTypoAscender;
    FT_Short sTypoDescender;
    FT_Short sTypoLineGap;
    FT_UShort usWinAscent;
    FT_UShort usWinDescent;



    FT_ULong ulCodePageRange1;
    FT_ULong ulCodePageRange2;



    FT_Short sxHeight;
    FT_Short sCapHeight;
    FT_UShort usDefaultChar;
    FT_UShort usBreakChar;
    FT_UShort usMaxContext;



    FT_UShort usLowerOpticalPointSize;
    FT_UShort usUpperOpticalPointSize;

  } TT_OS2;
# 437 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_Postscript_
  {
    FT_Fixed FormatType;
    FT_Fixed italicAngle;
    FT_Short underlinePosition;
    FT_Short underlineThickness;
    FT_ULong isFixedPitch;
    FT_ULong minMemType42;
    FT_ULong maxMemType42;
    FT_ULong minMemType1;
    FT_ULong maxMemType1;




  } TT_Postscript;
# 464 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_PCLT_
  {
    FT_Fixed Version;
    FT_ULong FontNumber;
    FT_UShort Pitch;
    FT_UShort xHeight;
    FT_UShort Style;
    FT_UShort TypeFamily;
    FT_UShort CapHeight;
    FT_UShort SymbolSet;
    FT_Char TypeFace[16];
    FT_Char CharacterComplement[8];
    FT_Char FileName[6];
    FT_Char StrokeWeight;
    FT_Char WidthType;
    FT_Byte SerifStyle;
    FT_Byte Reserved;

  } TT_PCLT;
# 551 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_MaxProfile_
  {
    FT_Fixed version;
    FT_UShort numGlyphs;
    FT_UShort maxPoints;
    FT_UShort maxContours;
    FT_UShort maxCompositePoints;
    FT_UShort maxCompositeContours;
    FT_UShort maxZones;
    FT_UShort maxTwilightPoints;
    FT_UShort maxStorage;
    FT_UShort maxFunctionDefs;
    FT_UShort maxInstructionDefs;
    FT_UShort maxStackElements;
    FT_UShort maxSizeOfInstructions;
    FT_UShort maxComponentElements;
    FT_UShort maxComponentDepth;

  } TT_MaxProfile;
# 596 "../../../libs/freetype/include/freetype/tttables.h"
  typedef enum FT_Sfnt_Tag_
  {
    FT_SFNT_HEAD,
    FT_SFNT_MAXP,
    FT_SFNT_OS2,
    FT_SFNT_HHEA,
    FT_SFNT_VHEA,
    FT_SFNT_POST,
    FT_SFNT_PCLT,

    FT_SFNT_MAX

  } FT_Sfnt_Tag;
# 659 "../../../libs/freetype/include/freetype/tttables.h"
  extern void*
  FT_Get_Sfnt_Table( FT_Face face,
                     FT_Sfnt_Tag tag );
# 728 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_Error
  FT_Load_Sfnt_Table( FT_Face face,
                      FT_ULong tag,
                      FT_Long offset,
                      FT_Byte* buffer,
                      FT_ULong* length );
# 771 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_Error
  FT_Sfnt_Table_Info( FT_Face face,
                      FT_UInt table_index,
                      FT_ULong *tag,
                      FT_ULong *length );
# 798 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_ULong
  FT_Get_CMap_Language_ID( FT_CharMap charmap );
# 818 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_Long
  FT_Get_CMap_Format( FT_CharMap charmap );





# 26 "../../../libs/freetype/include/freetype/internal/tttypes.h" 2



# 1 "../../../libs/freetype/include/freetype/ftmm.h" 1
# 24 "../../../libs/freetype/include/freetype/ftmm.h"
# 1 "../../../libs/freetype/include/freetype/t1tables.h" 1
# 34 "../../../libs/freetype/include/freetype/t1tables.h"

# 89 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_FontInfoRec_
  {
    FT_String* version;
    FT_String* notice;
    FT_String* full_name;
    FT_String* family_name;
    FT_String* weight;
    FT_Long italic_angle;
    FT_Bool is_fixed_pitch;
    FT_Short underline_position;
    FT_UShort underline_thickness;

  } PS_FontInfoRec;
# 112 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_FontInfoRec_* PS_FontInfo;
# 125 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef PS_FontInfoRec T1_FontInfo;
# 138 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_PrivateRec_
  {
    FT_Int unique_id;
    FT_Int lenIV;

    FT_Byte num_blue_values;
    FT_Byte num_other_blues;
    FT_Byte num_family_blues;
    FT_Byte num_family_other_blues;

    FT_Short blue_values[14];
    FT_Short other_blues[10];

    FT_Short family_blues [14];
    FT_Short family_other_blues[10];

    FT_Fixed blue_scale;
    FT_Int blue_shift;
    FT_Int blue_fuzz;

    FT_UShort standard_width[1];
    FT_UShort standard_height[1];

    FT_Byte num_snap_widths;
    FT_Byte num_snap_heights;
    FT_Bool force_bold;
    FT_Bool round_stem_up;

    FT_Short snap_widths [13];
    FT_Short snap_heights[13];

    FT_Fixed expansion_factor;

    FT_Long language_group;
    FT_Long password;

    FT_Short min_feature[2];

  } PS_PrivateRec;
# 187 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_PrivateRec_* PS_Private;
# 200 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef PS_PrivateRec T1_Private;
# 229 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef enum T1_Blend_Flags_
  {

    T1_BLEND_UNDERLINE_POSITION = 0,
    T1_BLEND_UNDERLINE_THICKNESS,
    T1_BLEND_ITALIC_ANGLE,


    T1_BLEND_BLUE_VALUES,
    T1_BLEND_OTHER_BLUES,
    T1_BLEND_STANDARD_WIDTH,
    T1_BLEND_STANDARD_HEIGHT,
    T1_BLEND_STEM_SNAP_WIDTHS,
    T1_BLEND_STEM_SNAP_HEIGHTS,
    T1_BLEND_BLUE_SCALE,
    T1_BLEND_BLUE_SHIFT,
    T1_BLEND_FAMILY_BLUES,
    T1_BLEND_FAMILY_OTHER_BLUES,
    T1_BLEND_FORCE_BOLD,

    T1_BLEND_MAX

  } T1_Blend_Flags;
# 286 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_DesignMap_
  {
    FT_Byte num_points;
    FT_Long* design_points;
    FT_Fixed* blend_points;

  } PS_DesignMapRec, *PS_DesignMap;


  typedef PS_DesignMapRec T1_DesignMap;


  typedef struct PS_BlendRec_
  {
    FT_UInt num_designs;
    FT_UInt num_axis;

    FT_String* axis_names[4];
    FT_Fixed* design_pos[16];
    PS_DesignMapRec design_map[4];

    FT_Fixed* weight_vector;
    FT_Fixed* default_weight_vector;

    PS_FontInfo font_infos[16 + 1];
    PS_Private privates [16 + 1];

    FT_ULong blend_bitflags;

    FT_BBox* bboxes [16 + 1];







    FT_UInt default_design_vector[16];
    FT_UInt num_default_design_vector;

  } PS_BlendRec, *PS_Blend;



  typedef PS_BlendRec T1_Blend;
# 341 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceDictRec_
  {
    PS_PrivateRec private_dict;

    FT_UInt len_buildchar;
    FT_Fixed forcebold_threshold;
    FT_Pos stroke_width;
    FT_Fixed expansion_factor;

    FT_Byte paint_type;
    FT_Byte font_type;
    FT_Matrix font_matrix;
    FT_Vector font_offset;

    FT_UInt num_subrs;
    FT_ULong subrmap_offset;
    FT_Int sd_bytes;

  } CID_FaceDictRec;
# 370 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceDictRec_* CID_FaceDict;
# 383 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef CID_FaceDictRec CID_FontDict;
# 394 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceInfoRec_
  {
    FT_String* cid_font_name;
    FT_Fixed cid_version;
    FT_Int cid_font_type;

    FT_String* registry;
    FT_String* ordering;
    FT_Int supplement;

    PS_FontInfoRec font_info;
    FT_BBox font_bbox;
    FT_ULong uid_base;

    FT_Int num_xuid;
    FT_ULong xuid[16];

    FT_ULong cidmap_offset;
    FT_Int fd_bytes;
    FT_Int gd_bytes;
    FT_ULong cid_count;

    FT_Int num_dicts;
    CID_FaceDict font_dicts;

    FT_ULong data_offset;

  } CID_FaceInfoRec;
# 432 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceInfoRec_* CID_FaceInfo;
# 445 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef CID_FaceInfoRec CID_Info;
# 470 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Int
  FT_Has_PS_Glyph_Names( FT_Face face );
# 503 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Error
  FT_Get_PS_Font_Info( FT_Face face,
                       PS_FontInfo afont_info );
# 536 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Error
  FT_Get_PS_Font_Private( FT_Face face,
                          PS_Private afont_private );
# 557 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef enum T1_EncodingType_
  {
    T1_ENCODING_TYPE_NONE = 0,
    T1_ENCODING_TYPE_ARRAY,
    T1_ENCODING_TYPE_STANDARD,
    T1_ENCODING_TYPE_ISOLATIN1,
    T1_ENCODING_TYPE_EXPERT

  } T1_EncodingType;
# 625 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef enum PS_Dict_Keys_
  {

    PS_DICT_FONT_TYPE,
    PS_DICT_FONT_MATRIX,
    PS_DICT_FONT_BBOX,
    PS_DICT_PAINT_TYPE,
    PS_DICT_FONT_NAME,
    PS_DICT_UNIQUE_ID,
    PS_DICT_NUM_CHAR_STRINGS,
    PS_DICT_CHAR_STRING_KEY,
    PS_DICT_CHAR_STRING,
    PS_DICT_ENCODING_TYPE,
    PS_DICT_ENCODING_ENTRY,


    PS_DICT_NUM_SUBRS,
    PS_DICT_SUBR,
    PS_DICT_STD_HW,
    PS_DICT_STD_VW,
    PS_DICT_NUM_BLUE_VALUES,
    PS_DICT_BLUE_VALUE,
    PS_DICT_BLUE_FUZZ,
    PS_DICT_NUM_OTHER_BLUES,
    PS_DICT_OTHER_BLUE,
    PS_DICT_NUM_FAMILY_BLUES,
    PS_DICT_FAMILY_BLUE,
    PS_DICT_NUM_FAMILY_OTHER_BLUES,
    PS_DICT_FAMILY_OTHER_BLUE,
    PS_DICT_BLUE_SCALE,
    PS_DICT_BLUE_SHIFT,
    PS_DICT_NUM_STEM_SNAP_H,
    PS_DICT_STEM_SNAP_H,
    PS_DICT_NUM_STEM_SNAP_V,
    PS_DICT_STEM_SNAP_V,
    PS_DICT_FORCE_BOLD,
    PS_DICT_RND_STEM_UP,
    PS_DICT_MIN_FEATURE,
    PS_DICT_LEN_IV,
    PS_DICT_PASSWORD,
    PS_DICT_LANGUAGE_GROUP,


    PS_DICT_VERSION,
    PS_DICT_NOTICE,
    PS_DICT_FULL_NAME,
    PS_DICT_FAMILY_NAME,
    PS_DICT_WEIGHT,
    PS_DICT_IS_FIXED_PITCH,
    PS_DICT_UNDERLINE_POSITION,
    PS_DICT_UNDERLINE_THICKNESS,
    PS_DICT_FS_TYPE,
    PS_DICT_ITALIC_ANGLE,

    PS_DICT_MAX = PS_DICT_ITALIC_ANGLE

  } PS_Dict_Keys;
# 747 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Long
  FT_Get_PS_Font_Value( FT_Face face,
                        PS_Dict_Keys key,
                        FT_UInt idx,
                        void *value,
                        FT_Long value_len );




# 25 "../../../libs/freetype/include/freetype/ftmm.h" 2



# 73 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_MM_Axis_
  {
    FT_String* name;
    FT_Long minimum;
    FT_Long maximum;

  } FT_MM_Axis;
# 103 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_Multi_Master_
  {
    FT_UInt num_axis;
    FT_UInt num_designs;
    FT_MM_Axis axis[4];

  } FT_Multi_Master;
# 140 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_Var_Axis_
  {
    FT_String* name;

    FT_Fixed minimum;
    FT_Fixed def;
    FT_Fixed maximum;

    FT_ULong tag;
    FT_UInt strid;

  } FT_Var_Axis;
# 170 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_Var_Named_Style_
  {
    FT_Fixed* coords;
    FT_UInt strid;

  } FT_Var_Named_Style;
# 214 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_MM_Var_
  {
    FT_UInt num_axis;
    FT_UInt num_designs;
    FT_UInt num_namedstyles;
    FT_Var_Axis* axis;
    FT_Var_Named_Style* namedstyle;

  } FT_MM_Var;
# 244 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Get_Multi_Master( FT_Face face,
                       FT_Multi_Master *amaster );
# 268 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Get_MM_Var( FT_Face face,
                 FT_MM_Var* *amaster );
# 298 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_MM_Design_Coordinates( FT_Face face,
                                FT_UInt num_coords,
                                FT_Long* coords );
# 327 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_Var_Design_Coordinates( FT_Face face,
                                 FT_UInt num_coords,
                                 FT_Fixed* coords );
# 357 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_MM_Blend_Coordinates( FT_Face face,
                               FT_UInt num_coords,
                               FT_Fixed* coords );
# 371 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_Var_Blend_Coordinates( FT_Face face,
                                FT_UInt num_coords,
                                FT_Fixed* coords );





# 30 "../../../libs/freetype/include/freetype/internal/tttypes.h" 2




# 70 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TTC_HeaderRec_
  {
    FT_ULong tag;
    FT_Fixed version;
    FT_Long count;
    FT_ULong* offsets;

  } TTC_HeaderRec;
# 99 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct SFNT_HeaderRec_
  {
    FT_ULong format_tag;
    FT_UShort num_tables;
    FT_UShort search_range;
    FT_UShort entry_selector;
    FT_UShort range_shift;

    FT_ULong offset;

  } SFNT_HeaderRec, *SFNT_Header;
# 130 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_TableRec_
  {
    FT_ULong Tag;
    FT_ULong CheckSum;
    FT_ULong Offset;
    FT_ULong Length;

  } TT_TableRec, *TT_Table;
# 153 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct WOFF_HeaderRec_
  {
    FT_ULong signature;
    FT_ULong flavor;
    FT_ULong length;
    FT_UShort num_tables;
    FT_UShort reserved;
    FT_ULong totalSfntSize;
    FT_UShort majorVersion;
    FT_UShort minorVersion;
    FT_ULong metaOffset;
    FT_ULong metaLength;
    FT_ULong metaOrigLength;
    FT_ULong privOffset;
    FT_ULong privLength;

  } WOFF_HeaderRec, *WOFF_Header;
# 196 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct WOFF_TableRec_
  {
    FT_ULong Tag;
    FT_ULong Offset;
    FT_ULong CompLength;
    FT_ULong OrigLength;
    FT_ULong CheckSum;

    FT_ULong OrigOffset;

  } WOFF_TableRec, *WOFF_Table;
# 223 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_LongMetricsRec_
  {
    FT_UShort advance;
    FT_Short bearing;

  } TT_LongMetricsRec, *TT_LongMetrics;
# 240 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Short TT_ShortMetrics;
# 270 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_NameEntryRec_
  {
    FT_UShort platformID;
    FT_UShort encodingID;
    FT_UShort languageID;
    FT_UShort nameID;
    FT_UShort stringLength;
    FT_ULong stringOffset;




    FT_Byte* string;

  } TT_NameEntryRec, *TT_NameEntry;
# 307 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_NameTableRec_
  {
    FT_UShort format;
    FT_UInt numNameRecords;
    FT_UInt storageOffset;
    TT_NameEntryRec* names;
    FT_Stream stream;

  } TT_NameTableRec, *TT_NameTable;
# 346 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_GaspRangeRec_
  {
    FT_UShort maxPPEM;
    FT_UShort gaspFlag;

  } TT_GaspRangeRec, *TT_GaspRange;
# 374 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Gasp_
  {
    FT_UShort version;
    FT_UShort numRanges;
    TT_GaspRange gaspRanges;

  } TT_GaspRec;
# 423 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_MetricsRec_
  {
    FT_UShort height;
    FT_UShort width;

    FT_Short horiBearingX;
    FT_Short horiBearingY;
    FT_UShort horiAdvance;

    FT_Short vertBearingX;
    FT_Short vertBearingY;
    FT_UShort vertAdvance;

  } TT_SBit_MetricsRec, *TT_SBit_Metrics;
# 460 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_Small_Metrics_
  {
    FT_Byte height;
    FT_Byte width;

    FT_Char bearingX;
    FT_Char bearingY;
    FT_Byte advance;

  } TT_SBit_SmallMetricsRec, *TT_SBit_SmallMetrics;
# 523 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_LineMetricsRec_
  {
    FT_Char ascender;
    FT_Char descender;
    FT_Byte max_width;
    FT_Char caret_slope_numerator;
    FT_Char caret_slope_denominator;
    FT_Char caret_offset;
    FT_Char min_origin_SB;
    FT_Char min_advance_SB;
    FT_Char max_before_BL;
    FT_Char min_after_BL;
    FT_Char pads[2];

  } TT_SBit_LineMetricsRec, *TT_SBit_LineMetrics;
# 577 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_RangeRec_
  {
    FT_UShort first_glyph;
    FT_UShort last_glyph;

    FT_UShort index_format;
    FT_UShort image_format;
    FT_ULong image_offset;

    FT_ULong image_size;
    TT_SBit_MetricsRec metrics;
    FT_ULong num_glyphs;

    FT_ULong* glyph_offsets;
    FT_UShort* glyph_codes;

    FT_ULong table_offset;

  } TT_SBit_RangeRec, *TT_SBit_Range;
# 639 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_StrikeRec_
  {
    FT_Int num_ranges;
    TT_SBit_Range sbit_ranges;
    FT_ULong ranges_offset;

    FT_ULong color_ref;

    TT_SBit_LineMetricsRec hori;
    TT_SBit_LineMetricsRec vert;

    FT_UShort start_glyph;
    FT_UShort end_glyph;

    FT_Byte x_ppem;
    FT_Byte y_ppem;

    FT_Byte bit_depth;
    FT_Char flags;

  } TT_SBit_StrikeRec, *TT_SBit_Strike;
# 677 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_ComponentRec_
  {
    FT_UShort glyph_code;
    FT_Char x_offset;
    FT_Char y_offset;

  } TT_SBit_ComponentRec, *TT_SBit_Component;
# 708 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_ScaleRec_
  {
    TT_SBit_LineMetricsRec hori;
    TT_SBit_LineMetricsRec vert;

    FT_Byte x_ppem;
    FT_Byte y_ppem;

    FT_Byte x_ppem_substitute;
    FT_Byte y_ppem_substitute;

  } TT_SBit_ScaleRec, *TT_SBit_Scale;
# 753 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_20Rec_
  {
    FT_UShort num_glyphs;
    FT_UShort num_names;
    FT_UShort* glyph_indices;
    FT_Char** glyph_names;

  } TT_Post_20Rec, *TT_Post_20;
# 778 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_25_
  {
    FT_UShort num_glyphs;
    FT_Char* offsets;

  } TT_Post_25Rec, *TT_Post_25;
# 801 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_NamesRec_
  {
    FT_Bool loaded;

    union
    {
      TT_Post_20Rec format_20;
      TT_Post_25Rec format_25;

    } names;

  } TT_Post_NamesRec, *TT_Post_Names;
# 829 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct GX_BlendRec_ *GX_Blend;
# 886 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_BDFRec_
  {
    FT_Byte* table;
    FT_Byte* table_end;
    FT_Byte* strings;
    FT_ULong strings_size;
    FT_UInt num_strikes;
    FT_Bool loaded;

  } TT_BDFRec, *TT_BDF;
# 937 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_FaceRec_* TT_Face;



  typedef FT_Error
  (*TT_Interpreter)( void* exec_context );


  typedef struct TT_LoaderRec_* TT_Loader;
# 973 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_GotoTableFunc)( TT_Face face,
                              FT_ULong tag,
                              FT_Stream stream,
                              FT_ULong* length );
# 1008 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_StartGlyphFunc)( TT_Loader loader,
                               FT_UInt glyph_index,
                               FT_ULong offset,
                               FT_UInt byte_count );
# 1030 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_ReadGlyphFunc)( TT_Loader loader );
# 1045 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef void
  (*TT_Loader_EndGlyphFunc)( TT_Loader loader );


  typedef enum TT_SbitTableType_
  {
    TT_SBIT_TABLE_TYPE_NONE = 0,
    TT_SBIT_TABLE_TYPE_EBLC,

    TT_SBIT_TABLE_TYPE_CBLC,
    TT_SBIT_TABLE_TYPE_SBIX,


    TT_SBIT_TABLE_TYPE_MAX

  } TT_SbitTableType;
# 1251 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_FaceRec_
  {
    FT_FaceRec root;

    TTC_HeaderRec ttc_header;

    FT_ULong format_tag;
    FT_UShort num_tables;
    TT_Table dir_tables;

    TT_Header header;
    TT_HoriHeader horizontal;

    TT_MaxProfile max_profile;

    FT_Bool vertical_info;
    TT_VertHeader vertical;

    FT_UShort num_names;
    TT_NameTableRec name_table;

    TT_OS2 os2;
    TT_Postscript postscript;

    FT_Byte* cmap_table;
    FT_ULong cmap_size;

    TT_Loader_GotoTableFunc goto_table;

    TT_Loader_StartGlyphFunc access_glyph_frame;
    TT_Loader_EndGlyphFunc forget_glyph_frame;
    TT_Loader_ReadGlyphFunc read_glyph_header;
    TT_Loader_ReadGlyphFunc read_simple_glyph;
    TT_Loader_ReadGlyphFunc read_composite_glyph;



    void* sfnt;



    void* psnames;
# 1302 "../../../libs/freetype/include/freetype/internal/tttypes.h"
    TT_GaspRec gasp;


    TT_PCLT pclt;


    FT_ULong num_sbit_scales;
    TT_SBit_Scale sbit_scales;


    TT_Post_NamesRec postscript_names;
# 1322 "../../../libs/freetype/include/freetype/internal/tttypes.h"
    FT_ULong font_program_size;
    FT_Byte* font_program;


    FT_ULong cvt_program_size;
    FT_Byte* cvt_program;


    FT_ULong cvt_size;
    FT_Short* cvt;



    TT_Interpreter interpreter;
# 1349 "../../../libs/freetype/include/freetype/internal/tttypes.h"
    FT_Generic extra;

    const char* postscript_name;

    FT_ULong glyf_len;


    FT_Bool doblend;
    GX_Blend blend;




    FT_Byte* horz_metrics;
    FT_ULong horz_metrics_size;

    FT_Byte* vert_metrics;
    FT_ULong vert_metrics_size;

    FT_ULong num_locations;
    FT_Byte* glyph_locations;

    FT_Byte* hdmx_table;
    FT_ULong hdmx_table_size;
    FT_UInt hdmx_record_count;
    FT_ULong hdmx_record_size;
    FT_Byte* hdmx_record_sizes;

    FT_Byte* sbit_table;
    FT_ULong sbit_table_size;
    TT_SbitTableType sbit_table_type;
    FT_UInt sbit_num_strikes;

    FT_Byte* kern_table;
    FT_ULong kern_table_size;
    FT_UInt num_kern_tables;
    FT_UInt32 kern_avail_bits;
    FT_UInt32 kern_order_bits;


    TT_BDFRec bdf;



    FT_ULong horz_metrics_offset;
    FT_ULong vert_metrics_offset;



    FT_ULong sph_found_func_flags;

    FT_Bool sph_compatibility_mode;


  } TT_FaceRec;
# 1437 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_GlyphZoneRec_
  {
    FT_Memory memory;
    FT_UShort max_points;
    FT_Short max_contours;
    FT_UShort n_points;
    FT_Short n_contours;

    FT_Vector* org;
    FT_Vector* cur;
    FT_Vector* orus;

    FT_Byte* tags;
    FT_UShort* contours;

    FT_UShort first_point;

  } TT_GlyphZoneRec, *TT_GlyphZone;



  typedef struct TT_ExecContextRec_* TT_ExecContext;
# 1469 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SizeRec_* TT_Size;



  typedef struct TT_LoaderRec_
  {
    TT_Face face;
    TT_Size size;
    FT_GlyphSlot glyph;
    FT_GlyphLoader gloader;

    FT_ULong load_flags;
    FT_UInt glyph_index;

    FT_Stream stream;
    FT_Int byte_len;

    FT_Short n_contours;
    FT_BBox bbox;
    FT_Int left_bearing;
    FT_Int advance;
    FT_Int linear;
    FT_Bool linear_def;
    FT_Vector pp1;
    FT_Vector pp2;

    FT_ULong glyf_offset;


    TT_GlyphZoneRec base;
    TT_GlyphZoneRec zone;

    TT_ExecContext exec;
    FT_Byte* instructions;
    FT_ULong ins_pos;


    void* other;


    FT_Int top_bearing;
    FT_Int vadvance;
    FT_Vector pp3;
    FT_Vector pp4;


    FT_Byte* cursor;
    FT_Byte* limit;


    FT_ListRec composites;

  } TT_LoaderRec;



# 26 "../../../libs/freetype/include/freetype/internal/sfnt.h" 2



# 68 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Init_Face_Func)( FT_Stream stream,
                        TT_Face face,
                        FT_Int face_index,
                        FT_Int num_params,
                        FT_Parameter* params );
# 106 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Face_Func)( FT_Stream stream,
                        TT_Face face,
                        FT_Int face_index,
                        FT_Int num_params,
                        FT_Parameter* params );
# 128 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef void
  (*TT_Done_Face_Func)( TT_Face face );
# 172 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Any_Func)( TT_Face face,
                       FT_ULong tag,
                       FT_Long offset,
                       FT_Byte *buffer,
                       FT_ULong* length );
# 208 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Find_SBit_Image_Func)( TT_Face face,
                              FT_UInt glyph_index,
                              FT_ULong strike_index,
                              TT_SBit_Range *arange,
                              TT_SBit_Strike *astrike,
                              FT_ULong *aglyph_offset );
# 244 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SBit_Metrics_Func)( FT_Stream stream,
                                TT_SBit_Range range,
                                TT_SBit_Metrics metrics );
# 289 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SBit_Image_Func)( TT_Face face,
                              FT_ULong strike_index,
                              FT_UInt glyph_index,
                              FT_UInt load_flags,
                              FT_Stream stream,
                              FT_Bitmap *amap,
                              TT_SBit_MetricsRec *ametrics );
# 319 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Set_SBit_Strike_Func)( TT_Face face,
                              FT_Size_Request req,
                              FT_ULong* astrike_index );
# 345 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Strike_Metrics_Func)( TT_Face face,
                                  FT_ULong strike_index,
                                  FT_Size_Metrics* metrics );
# 370 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Get_PS_Name_Func)( TT_Face face,
                          FT_UInt idx,
                          FT_String** PSname );
# 395 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Metrics_Func)( TT_Face face,
                           FT_Stream stream,
                           FT_Bool vertical );
# 423 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef void
  (*TT_Get_Metrics_Func)( TT_Face face,
                          FT_Bool vertical,
                          FT_UInt gindex,
                          FT_Short* abearing,
                          FT_UShort* aadvance );
# 452 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Get_Name_Func)( TT_Face face,
                       FT_UShort nameid,
                       FT_String** name );
# 478 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Table_Func)( TT_Face face,
                         FT_Stream stream );
# 494 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef void
  (*TT_Free_Table_Func)( TT_Face face );
# 513 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Int
  (*TT_Face_GetKerningFunc)( TT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph );
# 531 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef struct SFNT_Interface_
  {
    TT_Loader_GotoTableFunc goto_table;

    TT_Init_Face_Func init_face;
    TT_Load_Face_Func load_face;
    TT_Done_Face_Func done_face;
    FT_Module_Requester get_interface;

    TT_Load_Any_Func load_any;



    TT_Load_Table_Func load_head;
    TT_Load_Metrics_Func load_hhea;
    TT_Load_Table_Func load_cmap;
    TT_Load_Table_Func load_maxp;
    TT_Load_Table_Func load_os2;
    TT_Load_Table_Func load_post;

    TT_Load_Table_Func load_name;
    TT_Free_Table_Func free_name;


    TT_Load_Table_Func load_kern;

    TT_Load_Table_Func load_gasp;
    TT_Load_Table_Func load_pclt;



    TT_Load_Table_Func load_bhed;

    TT_Load_SBit_Image_Func load_sbit_image;


    TT_Get_PS_Name_Func get_psname;
    TT_Free_Table_Func free_psnames;




    TT_Face_GetKerningFunc get_kerning;





    TT_Load_Table_Func load_font_dir;
    TT_Load_Metrics_Func load_hmtx;

    TT_Load_Table_Func load_eblc;
    TT_Free_Table_Func free_eblc;

    TT_Set_SBit_Strike_Func set_sbit_strike;
    TT_Load_Strike_Metrics_Func load_strike_metrics;

    TT_Get_Metrics_Func get_metrics;

    TT_Get_Name_Func get_name;

  } SFNT_Interface;



  typedef SFNT_Interface* SFNT_Service;
# 743 "../../../libs/freetype/include/freetype/internal/sfnt.h"

# 23 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svfntfmt.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svfntfmt.h"

# 49 "../../../libs/freetype/include/freetype/internal/services/svfntfmt.h"

# 24 "../../../libs/freetype/src/truetype/ttdriver.c" 2



# 1 "../../../libs/freetype/include/freetype/internal/services/svmm.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svmm.h"

# 38 "../../../libs/freetype/include/freetype/internal/services/svmm.h"
  typedef FT_Error
  (*FT_Get_MM_Func)( FT_Face face,
                     FT_Multi_Master* master );

  typedef FT_Error
  (*FT_Get_MM_Var_Func)( FT_Face face,
                         FT_MM_Var* *master );

  typedef FT_Error
  (*FT_Set_MM_Design_Func)( FT_Face face,
                            FT_UInt num_coords,
                            FT_Long* coords );

  typedef FT_Error
  (*FT_Set_Var_Design_Func)( FT_Face face,
                             FT_UInt num_coords,
                             FT_Fixed* coords );

  typedef FT_Error
  (*FT_Set_MM_Blend_Func)( FT_Face face,
                           FT_UInt num_coords,
                           FT_Long* coords );


  typedef struct FT_Service_MultiMastersRec_ FT_Service_MultiMastersRec ; typedef struct FT_Service_MultiMastersRec_ const * FT_Service_MultiMasters ; struct FT_Service_MultiMastersRec_
  {
    FT_Get_MM_Func get_mm;
    FT_Set_MM_Design_Func set_mm_design;
    FT_Set_MM_Blend_Func set_mm_blend;
    FT_Get_MM_Var_Func get_mm_var;
    FT_Set_Var_Design_Func set_var_design;
  };
# 108 "../../../libs/freetype/include/freetype/internal/services/svmm.h"

# 28 "../../../libs/freetype/src/truetype/ttdriver.c" 2


# 1 "../../../libs/freetype/include/freetype/internal/services/svtteng.h" 1
# 26 "../../../libs/freetype/include/freetype/internal/services/svtteng.h"

# 39 "../../../libs/freetype/include/freetype/internal/services/svtteng.h"
  typedef struct FT_Service_TrueTypeEngineRec_ FT_Service_TrueTypeEngineRec ; typedef struct FT_Service_TrueTypeEngineRec_ const * FT_Service_TrueTypeEngine ; struct FT_Service_TrueTypeEngineRec_
  {
    FT_TrueTypeEngineType engine_type;
  };





# 31 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svttglyf.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svttglyf.h"






  typedef FT_ULong
  (*TT_Glyf_GetLocationFunc)( FT_Face face,
                              FT_UInt gindex,
                              FT_ULong *psize );

  typedef struct FT_Service_TTGlyfRec_ FT_Service_TTGlyfRec ; typedef struct FT_Service_TTGlyfRec_ const * FT_Service_TTGlyf ; struct FT_Service_TTGlyfRec_
  {
    TT_Glyf_GetLocationFunc get_location;
  };
# 64 "../../../libs/freetype/include/freetype/internal/services/svttglyf.h"

# 32 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svprop.h" 1
# 23 "../../../libs/freetype/include/freetype/internal/services/svprop.h"






  typedef FT_Error
  (*FT_Properties_SetFunc)( FT_Module module,
                            const char* property_name,
                            const void* value );

  typedef FT_Error
  (*FT_Properties_GetFunc)( FT_Module module,
                            const char* property_name,
                            void* value );


  typedef struct FT_Service_PropertiesRec_ FT_Service_PropertiesRec ; typedef struct FT_Service_PropertiesRec_ const * FT_Service_Properties ; struct FT_Service_PropertiesRec_
  {
    FT_Properties_SetFunc set_property;
    FT_Properties_GetFunc get_property;
  };
# 75 "../../../libs/freetype/include/freetype/internal/services/svprop.h"

# 33 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/include/freetype/ftttdrv.h" 1
# 33 "../../../libs/freetype/include/freetype/ftttdrv.h"

# 304 "../../../libs/freetype/include/freetype/ftttdrv.h"

# 34 "../../../libs/freetype/src/truetype/ttdriver.c" 2

# 1 "../../../libs/freetype/src/truetype/ttdriver.h" 1
# 27 "../../../libs/freetype/src/truetype/ttdriver.h"



  extern const FT_Driver_ClassRec tt_driver_class;



# 36 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/src/truetype/ttgload.h" 1
# 24 "../../../libs/freetype/src/truetype/ttgload.h"
# 1 "../../../libs/freetype/src/truetype/ttobjs.h" 1
# 28 "../../../libs/freetype/src/truetype/ttobjs.h"

# 39 "../../../libs/freetype/src/truetype/ttobjs.h"
  typedef struct TT_DriverRec_* TT_Driver;
# 54 "../../../libs/freetype/src/truetype/ttobjs.h"
  typedef FT_GlyphSlot TT_GlyphSlot;
# 65 "../../../libs/freetype/src/truetype/ttobjs.h"
  typedef struct TT_GraphicsState_
  {
    FT_UShort rp0;
    FT_UShort rp1;
    FT_UShort rp2;

    FT_UnitVector dualVector;
    FT_UnitVector projVector;
    FT_UnitVector freeVector;





    FT_Long loop;
    FT_F26Dot6 minimum_distance;
    FT_Int round_state;

    FT_Bool auto_flip;
    FT_F26Dot6 control_value_cutin;
    FT_F26Dot6 single_width_cutin;
    FT_F26Dot6 single_width_value;
    FT_UShort delta_base;
    FT_UShort delta_shift;

    FT_Byte instruct_control;




    FT_Bool scan_control;
    FT_Int scan_type;

    FT_UShort gep0;
    FT_UShort gep1;
    FT_UShort gep2;

  } TT_GraphicsState;




  static void
  tt_glyphzone_done( TT_GlyphZone zone );

  static FT_Error
  tt_glyphzone_new( FT_Memory memory,
                    FT_UShort maxPoints,
                    FT_Short maxContours,
                    TT_GlyphZone zone );
# 139 "../../../libs/freetype/src/truetype/ttobjs.h"
  typedef enum TT_CodeRange_Tag_
  {
    tt_coderange_none = 0,
    tt_coderange_font,
    tt_coderange_cvt,
    tt_coderange_glyph

  } TT_CodeRange_Tag;


  typedef struct TT_CodeRange_
  {
    FT_Byte* base;
    FT_Long size;

  } TT_CodeRange;

  typedef TT_CodeRange TT_CodeRangeTable[3];






  typedef struct TT_DefRecord_
  {
    FT_Int range;
    FT_Long start;
    FT_Long end;
    FT_UInt opc;
    FT_Bool active;
    FT_Bool inline_delta;
    FT_ULong sph_fdef_flags;

  } TT_DefRecord, *TT_DefArray;






  typedef struct TT_Transform_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;
    FT_F26Dot6 ox, oy;

  } TT_Transform;
# 255 "../../../libs/freetype/src/truetype/ttobjs.h"
  typedef struct TT_Size_Metrics_
  {

    FT_Long x_ratio;
    FT_Long y_ratio;

    FT_UShort ppem;
    FT_Long ratio;
    FT_Fixed scale;

    FT_F26Dot6 compensations[4];

    FT_Bool valid;

    FT_Bool rotated;
    FT_Bool stretched;

  } TT_Size_Metrics;






  typedef struct TT_SizeRec_
  {
    FT_SizeRec root;



    FT_Size_Metrics metrics;

    TT_Size_Metrics ttmetrics;

    FT_ULong strike_index;



    FT_UInt num_function_defs;
    FT_UInt max_function_defs;
    TT_DefArray function_defs;

    FT_UInt num_instruction_defs;
    FT_UInt max_instruction_defs;
    TT_DefArray instruction_defs;

    FT_UInt max_func;
    FT_UInt max_ins;

    TT_CodeRangeTable codeRangeTable;

    TT_GraphicsState GS;

    FT_ULong cvt_size;
    FT_Long* cvt;

    FT_UShort storage_size;
    FT_Long* storage;

    TT_GlyphZoneRec twilight;

    TT_ExecContext context;



    FT_Error bytecode_ready;
    FT_Error cvt_ready;



  } TT_SizeRec;






  typedef struct TT_DriverRec_
  {
    FT_DriverRec root;

    TT_GlyphZoneRec zone;

    FT_UInt interpreter_version;

  } TT_DriverRec;
# 356 "../../../libs/freetype/src/truetype/ttobjs.h"
  static FT_Error
  tt_face_init( FT_Stream stream,
                FT_Face ttface,
                FT_Int face_index,
                FT_Int num_params,
                FT_Parameter* params );

  static void
  tt_face_done( FT_Face ttface );






  static FT_Error
  tt_size_init( FT_Size ttsize );

  static void
  tt_size_done( FT_Size ttsize );



  static FT_Error
  tt_size_run_fpgm( TT_Size size,
                    FT_Bool pedantic );

  static FT_Error
  tt_size_run_prep( TT_Size size,
                    FT_Bool pedantic );

  static FT_Error
  tt_size_ready_bytecode( TT_Size size,
                          FT_Bool pedantic );



  static FT_Error
  tt_size_reset( TT_Size size );






  static FT_Error
  tt_driver_init( FT_Module ttdriver );

  static void
  tt_driver_done( FT_Module ttdriver );






  static FT_Error
  tt_slot_init( FT_GlyphSlot slot );







# 25 "../../../libs/freetype/src/truetype/ttgload.h" 2


# 1 "../../../libs/freetype/src/truetype/ttinterp.h" 1
# 26 "../../../libs/freetype/src/truetype/ttinterp.h"

# 52 "../../../libs/freetype/src/truetype/ttinterp.h"
  typedef FT_F26Dot6
  (*TT_Round_Func)( TT_ExecContext exc,
                    FT_F26Dot6 distance,
                    FT_F26Dot6 compensation );


  typedef void
  (*TT_Move_Func)( TT_ExecContext exc,
                   TT_GlyphZone zone,
                   FT_UShort point,
                   FT_F26Dot6 distance );


  typedef FT_F26Dot6
  (*TT_Project_Func)( TT_ExecContext exc,
                      FT_Pos dx,
                      FT_Pos dy );


  typedef FT_Long
  (*TT_Cur_Ppem_Func)( TT_ExecContext exc );


  typedef FT_F26Dot6
  (*TT_Get_CVT_Func)( TT_ExecContext exc,
                      FT_ULong idx );



  typedef void
  (*TT_Set_CVT_Func)( TT_ExecContext exc,
                      FT_ULong idx,
                      FT_F26Dot6 value );






  typedef struct TT_CallRec_
  {
    FT_Int Caller_Range;
    FT_Long Caller_IP;
    FT_Long Cur_Count;

    TT_DefRecord *Def;

  } TT_CallRec, *TT_CallStack;
# 113 "../../../libs/freetype/src/truetype/ttinterp.h"
  typedef struct SPH_TweakRule_
  {
    const char family[32];
    const FT_UInt ppem;
    const char style[32];
    const FT_ULong glyph;

  } SPH_TweakRule;


  typedef struct SPH_ScaleRule_
  {
    const char family[32];
    const FT_UInt ppem;
    const char style[32];
    const FT_ULong glyph;
    const FT_ULong scale;

  } SPH_ScaleRule;


  typedef struct SPH_Font_Class_
  {
    const char name[32];
    const char member[100][32];

  } SPH_Font_Class;
# 149 "../../../libs/freetype/src/truetype/ttinterp.h"
  typedef struct TT_ExecContextRec_
  {
    TT_Face face;
    TT_Size size;
    FT_Memory memory;



    FT_Error error;

    FT_Long top;

    FT_Long stackSize;
    FT_Long* stack;

    FT_Long args;
    FT_Long new_top;

    TT_GlyphZoneRec zp0,
                       zp1,
                       zp2,
                       pts,
                       twilight;

    FT_Size_Metrics metrics;
    TT_Size_Metrics tt_metrics;

    TT_GraphicsState GS;

    FT_Int curRange;
    FT_Byte* code;
    FT_Long IP;
    FT_Long codeSize;

    FT_Byte opcode;
    FT_Int length;

    FT_Bool step_ins;

    FT_ULong cvtSize;
    FT_Long* cvt;

    FT_UInt glyphSize;
    FT_Byte* glyphIns;

    FT_UInt numFDefs;
    FT_UInt maxFDefs;
    TT_DefArray FDefs;

    FT_UInt numIDefs;
    FT_UInt maxIDefs;
    TT_DefArray IDefs;

    FT_UInt maxFunc;
    FT_UInt maxIns;

    FT_Int callTop,
                       callSize;
    TT_CallStack callStack;

    FT_UShort maxPoints;
    FT_Short maxContours;


    TT_CodeRangeTable codeRangeTable;


    FT_UShort storeSize;
    FT_Long* storage;

    FT_F26Dot6 period;
    FT_F26Dot6 phase;
    FT_F26Dot6 threshold;

    FT_Bool instruction_trap;


    TT_GraphicsState default_GS;

    FT_Bool is_composite;
    FT_Bool pedantic_hinting;



    FT_Long F_dot_P;

    TT_Round_Func func_round;

    TT_Project_Func func_project,
                       func_dualproj,
                       func_freeProj;

    TT_Move_Func func_move;
    TT_Move_Func func_move_orig;

    TT_Cur_Ppem_Func func_cur_ppem;

    TT_Get_CVT_Func func_read_cvt;
    TT_Set_CVT_Func func_write_cvt;
    TT_Set_CVT_Func func_move_cvt;

    FT_Bool grayscale;


    TT_Round_Func func_round_sphn;

    FT_Bool subpixel_hinting;
    FT_Bool ignore_x_mode;





    FT_Bool compatible_widths;
    FT_Bool symmetrical_smoothing;
    FT_Bool bgr;
    FT_Bool vertical_lcd;

    FT_Bool subpixel_positioned;

    FT_Bool gray_cleartype;


    FT_Int rasterizer_version;

    FT_Bool iup_called;

    FT_ULong sph_tweak_flags;


    FT_ULong sph_in_func_flags;




  } TT_ExecContextRec;


  extern const TT_GraphicsState tt_default_graphics_state;



  static void
  TT_Goto_CodeRange( TT_ExecContext exec,
                     FT_Int range,
                     FT_Long IP );

  static void
  TT_Set_CodeRange( TT_ExecContext exec,
                    FT_Int range,
                    void* base,
                    FT_Long length );

  static void
  TT_Clear_CodeRange( TT_ExecContext exec,
                      FT_Int range );


  static FT_Error
  Update_Max( FT_Memory memory,
              FT_ULong* size,
              FT_ULong multiplier,
              void* _pbuff,
              FT_ULong new_max );
# 336 "../../../libs/freetype/src/truetype/ttinterp.h"
  extern TT_ExecContext
  TT_New_Context( TT_Driver driver );



  static void
  TT_Done_Context( TT_ExecContext exec );

  static FT_Error
  TT_Load_Context( TT_ExecContext exec,
                   TT_Face face,
                   TT_Size size );

  static void
  TT_Save_Context( TT_ExecContext exec,
                   TT_Size ins );

  static FT_Error
  TT_Run_Context( TT_ExecContext exec );
# 379 "../../../libs/freetype/src/truetype/ttinterp.h"
  extern FT_Error
  TT_RunIns( TT_ExecContext exec );



# 28 "../../../libs/freetype/src/truetype/ttgload.h" 2






  static void
  TT_Init_Glyph_Loading( TT_Face face );

  static void
  TT_Get_HMetrics( TT_Face face,
                   FT_UInt idx,
                   FT_Short* lsb,
                   FT_UShort* aw );

  static void
  TT_Get_VMetrics( TT_Face face,
                   FT_UInt idx,
                   FT_Pos yMax,
                   FT_Short* tsb,
                   FT_UShort* ah );

  static FT_Error
  TT_Load_Glyph( TT_Size size,
                 TT_GlyphSlot glyph,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );



# 37 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 1 "../../../libs/freetype/src/truetype/ttpload.h" 1
# 27 "../../../libs/freetype/src/truetype/ttpload.h"



  static FT_Error
  tt_face_load_loca( TT_Face face,
                     FT_Stream stream );

  static FT_ULong
  tt_face_get_location( TT_Face face,
                        FT_UInt gindex,
                        FT_UInt *asize );

  static void
  tt_face_done_loca( TT_Face face );

  static FT_Error
  tt_face_load_cvt( TT_Face face,
                    FT_Stream stream );

  static FT_Error
  tt_face_load_fpgm( TT_Face face,
                     FT_Stream stream );


  static FT_Error
  tt_face_load_prep( TT_Face face,
                     FT_Stream stream );


  static FT_Error
  tt_face_load_hdmx( TT_Face face,
                     FT_Stream stream );


  static void
  tt_face_free_hdmx( TT_Face face );


  static FT_Byte*
  tt_face_get_device_metrics( TT_Face face,
                              FT_UInt ppem,
                              FT_UInt gindex );


# 38 "../../../libs/freetype/src/truetype/ttdriver.c" 2


# 1 "../../../libs/freetype/src/truetype/ttgxvar.h" 1
# 27 "../../../libs/freetype/src/truetype/ttgxvar.h"

# 39 "../../../libs/freetype/src/truetype/ttgxvar.h"
  typedef struct GX_AVarCorrespondenceRec_
  {
    FT_Fixed fromCoord;
    FT_Fixed toCoord;

  } GX_AVarCorrespondenceRec_, *GX_AVarCorrespondence;
# 56 "../../../libs/freetype/src/truetype/ttgxvar.h"
  typedef struct GX_AVarSegmentRec_
  {
    FT_UShort pairCount;
    GX_AVarCorrespondence correspondence;

  } GX_AVarSegmentRec, *GX_AVarSegment;
# 81 "../../../libs/freetype/src/truetype/ttgxvar.h"
  typedef struct GX_BlendRec_
  {
    FT_UInt num_axis;
    FT_Fixed* normalizedcoords;

    FT_MM_Var* mmvar;
    FT_Offset mmvar_len;

    FT_Bool avar_checked;
    GX_AVarSegment avar_segment;

    FT_UInt tuplecount;
    FT_Fixed* tuplecoords;

    FT_UInt gv_glyphcnt;
    FT_ULong* glyphoffsets;

    FT_ULong gvar_size;

  } GX_BlendRec;
# 111 "../../../libs/freetype/src/truetype/ttgxvar.h"
  typedef enum GX_TupleCountFlags_
  {
    GX_TC_TUPLES_SHARE_POINT_NUMBERS = 0x8000,
    GX_TC_RESERVED_TUPLE_FLAGS = 0x7000,
    GX_TC_TUPLE_COUNT_MASK = 0x0FFF

  } GX_TupleCountFlags;
# 129 "../../../libs/freetype/src/truetype/ttgxvar.h"
  typedef enum GX_TupleIndexFlags_
  {
    GX_TI_EMBEDDED_TUPLE_COORD = 0x8000,
    GX_TI_INTERMEDIATE_TUPLE = 0x4000,
    GX_TI_PRIVATE_POINT_NUMBERS = 0x2000,
    GX_TI_RESERVED_TUPLE_FLAG = 0x1000,
    GX_TI_TUPLE_INDEX_MASK = 0x0FFF

  } GX_TupleIndexFlags;
# 146 "../../../libs/freetype/src/truetype/ttgxvar.h"
  static FT_Error
  TT_Set_MM_Blend( TT_Face face,
                   FT_UInt num_coords,
                   FT_Fixed* coords );

  static FT_Error
  TT_Set_Var_Design( TT_Face face,
                     FT_UInt num_coords,
                     FT_Fixed* coords );

  static FT_Error
  TT_Get_MM_Var( TT_Face face,
                 FT_MM_Var* *master );


  static FT_Error
  tt_face_vary_cvt( TT_Face face,
                    FT_Stream stream );


  static FT_Error
  TT_Vary_Apply_Glyph_Deltas( TT_Face face,
                              FT_UInt glyph_index,
                              FT_Outline* outline,
                              FT_UInt n_points );


  static void
  tt_done_blend( FT_Memory memory,
                 GX_Blend blend );



# 41 "../../../libs/freetype/src/truetype/ttdriver.c" 2
# 61 "../../../libs/freetype/src/truetype/ttdriver.c"
  static FT_Error
  tt_property_set( FT_Module module,
                   const char* property_name,
                   const void* value )
  {
    FT_Error error = FT_Err_Ok;
    TT_Driver driver = (TT_Driver)module;


    if ( !strcmp( property_name, "interpreter-version" ) )
    {
      FT_UInt* interpreter_version = (FT_UInt*)value;







        driver->interpreter_version = *interpreter_version;

      return error;
    }

    do { } while ( 0 )
                                ;
    return TT_Err_Missing_Property;
  }


  static FT_Error
  tt_property_get( FT_Module module,
                   const char* property_name,
                   const void* value )
  {
    FT_Error error = FT_Err_Ok;
    TT_Driver driver = (TT_Driver)module;

    FT_UInt interpreter_version = driver->interpreter_version;


    if ( !strcmp( property_name, "interpreter-version" ) )
    {
      FT_UInt* val = (FT_UInt*)value;


      *val = interpreter_version;

      return error;
    }

    do { } while ( 0 )
                                ;
    return TT_Err_Missing_Property;
  }


  static const FT_Service_PropertiesRec tt_service_properties = { (FT_Properties_SetFunc)tt_property_set, (FT_Properties_GetFunc)tt_property_get };
# 169 "../../../libs/freetype/src/truetype/ttdriver.c"
  static FT_Error
  tt_get_kerning( FT_Face ttface,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_Vector* kerning )
  {
    TT_Face face = (TT_Face)ttface;
    SFNT_Service sfnt = (SFNT_Service)face->sfnt;


    kerning->x = 0;
    kerning->y = 0;

    if ( sfnt )
      kerning->x = sfnt->get_kerning( face, left_glyph, right_glyph );

    return 0;
  }


  static FT_Error
  tt_get_advances( FT_Face ttface,
                   FT_UInt start,
                   FT_UInt count,
                   FT_Int32 flags,
                   FT_Fixed *advances )
  {
    FT_UInt nn;
    TT_Face face = (TT_Face) ttface;




    if ( flags & ( 1L << 4 ) )
    {
      for ( nn = 0; nn < count; nn++ )
      {
        FT_Short tsb;
        FT_UShort ah;



        TT_Get_VMetrics( face, start + nn, 0, &tsb, &ah );
        advances[nn] = ah;
      }
    }
    else
    {
      for ( nn = 0; nn < count; nn++ )
      {
        FT_Short lsb;
        FT_UShort aw;


        TT_Get_HMetrics( face, start + nn, &lsb, &aw );
        advances[nn] = aw;
      }
    }

    return FT_Err_Ok;
  }
# 246 "../../../libs/freetype/src/truetype/ttdriver.c"
  static FT_Error
  tt_size_select( FT_Size size,
                  FT_ULong strike_index )
  {
    TT_Face ttface = (TT_Face)size->face;
    TT_Size ttsize = (TT_Size)size;
    FT_Error error = FT_Err_Ok;


    ttsize->strike_index = strike_index;

    if ( ( size->face->face_flags & ( 1L << 0 ) ) )
    {

      FT_Select_Metrics( size->face, strike_index );

      tt_size_reset( ttsize );
    }
    else
    {
      SFNT_Service sfnt = (SFNT_Service) ttface->sfnt;
      FT_Size_Metrics* metrics = &size->metrics;


      error = sfnt->load_strike_metrics( ttface, strike_index, metrics );
      if ( error )
        ttsize->strike_index = 0xFFFFFFFFUL;
    }

    return error;
  }




  static FT_Error
  tt_size_request( FT_Size size,
                   FT_Size_Request req )
  {
    TT_Size ttsize = (TT_Size)size;
    FT_Error error = FT_Err_Ok;




    if ( ( size->face->face_flags & ( 1L << 1 ) ) )
    {
      TT_Face ttface = (TT_Face)size->face;
      SFNT_Service sfnt = (SFNT_Service) ttface->sfnt;
      FT_ULong strike_index;


      error = sfnt->set_sbit_strike( ttface, req, &strike_index );

      if ( error )
        ttsize->strike_index = 0xFFFFFFFFUL;
      else
        return tt_size_select( size, strike_index );
    }



    FT_Request_Metrics( size->face, req );

    if ( ( size->face->face_flags & ( 1L << 0 ) ) )
    {
      error = tt_size_reset( ttsize );
      ttsize->root.metrics = ttsize->metrics;
    }

    return error;
  }
# 346 "../../../libs/freetype/src/truetype/ttdriver.c"
  static FT_Error
  tt_glyph_load( FT_GlyphSlot ttslot,
                 FT_Size ttsize,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags )
  {
    TT_GlyphSlot slot = (TT_GlyphSlot)ttslot;
    TT_Size size = (TT_Size)ttsize;
    FT_Face face = ttslot->face;
    FT_Error error;


    if ( !slot )
      return TT_Err_Invalid_Slot_Handle;

    if ( !size )
      return TT_Err_Invalid_Size_Handle;

    if ( !face )
      return TT_Err_Invalid_Face_Handle;


    if ( glyph_index >= (FT_UInt)face->num_glyphs &&
         !face->internal->incremental_interface )



      return TT_Err_Invalid_Argument;

    if ( load_flags & ( 1L << 1 ) )
    {



      if ( ( face->face_flags & ( 1L << 13 ) ) )
        load_flags &= ~( 1L << 1 );

      if ( load_flags & ( 1L << 15 ) )
        load_flags |= ( 1L << 1 );
    }

    if ( load_flags & ( ( 1L << 10 ) | ( 1L << 0 ) ) )
    {
      load_flags |= ( 1L << 3 ) | ( 1L << 0 );

      if ( !( face->face_flags & ( 1L << 13 ) ) )
        load_flags |= ( 1L << 1 );
    }


    error = TT_Load_Glyph( size, slot, glyph_index, load_flags );




    return error;
  }
# 418 "../../../libs/freetype/src/truetype/ttdriver.c"
  static const FT_Service_MultiMastersRec tt_service_gx_multi_masters = { (FT_Get_MM_Func) ((void *)0), (FT_Set_MM_Design_Func) ((void *)0), (FT_Set_MM_Blend_Func) TT_Set_MM_Blend, (FT_Get_MM_Var_Func) TT_Get_MM_Var, (FT_Set_Var_Design_Func)TT_Set_Var_Design };
# 428 "../../../libs/freetype/src/truetype/ttdriver.c"
  static const FT_Service_TrueTypeEngineRec tt_service_truetype_engine =
  {





    FT_TRUETYPE_ENGINE_TYPE_PATENTED







  };


  static const FT_Service_TTGlyfRec tt_service_truetype_glyf = { (TT_Glyf_GetLocationFunc)tt_face_get_location };





  static const FT_ServiceDescRec tt_services[] = { { "font-format", "TrueType" }, { "multi-masters", &tt_service_gx_multi_masters }, { "truetype-engine", &tt_service_truetype_engine }, { "tt-glyf", &tt_service_truetype_glyf }, { "properties", &tt_service_properties }, { ((void *)0), ((void *)0) } };
# 469 "../../../libs/freetype/src/truetype/ttdriver.c"
  static FT_Module_Interface
  tt_get_interface( FT_Module driver,
                    const char* tt_interface )
  {
    FT_Library library;
    FT_Module_Interface result;
    FT_Module sfntd;
    SFNT_Service sfnt;
# 488 "../../../libs/freetype/src/truetype/ttdriver.c"
    result = ft_service_list_lookup( tt_services, tt_interface );
    if ( result != ((void *)0) )
      return result;


    if ( !driver )
      return ((void *)0);
    library = driver->library;
    if ( !library )
      return ((void *)0);



    sfntd = FT_Get_Module( library, "sfnt" );
    if ( sfntd )
    {
      sfnt = (SFNT_Service)( sfntd->clazz->module_interface );
      if ( sfnt )
        return sfnt->get_interface( driver, tt_interface );
    }

    return 0;
  }
# 527 "../../../libs/freetype/src/truetype/ttdriver.c"
  const FT_Driver_ClassRec tt_driver_class = { { 1 | 0x100 | 0x400, sizeof ( TT_DriverRec ), "truetype", 0x10000L, 0x20000L, 0, tt_driver_init, tt_driver_done, tt_get_interface, }, sizeof ( TT_FaceRec ), sizeof ( TT_SizeRec ), sizeof ( FT_GlyphSlotRec ), tt_face_init, tt_face_done, tt_size_init, tt_size_done, tt_slot_init, 0, tt_glyph_load, tt_get_kerning, 0, tt_get_advances, tt_size_request, tt_size_select };
# 24 "../../../libs/freetype/src/truetype/truetype.c" 2
# 1 "../../../libs/freetype/src/truetype/ttpload.c" 1
# 23 "../../../libs/freetype/src/truetype/ttpload.c"
# 1 "../../../libs/freetype/include/freetype/tttags.h" 1
# 33 "../../../libs/freetype/include/freetype/tttags.h"

# 106 "../../../libs/freetype/include/freetype/tttags.h"

# 24 "../../../libs/freetype/src/truetype/ttpload.c" 2
# 61 "../../../libs/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_loca( TT_Face face,
                     FT_Stream stream )
  {
    FT_Error error;
    FT_ULong table_len;
    FT_Int shift;



    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'l' << 16 ) | ( (FT_ULong)'y' << 8 ) | (FT_ULong)'f' ), stream, &face->glyf_len );



    if ( ( ( (error) & 0xFF ) == ( (TT_Err_Table_Missing) & 0xFF ) ) )
      face->glyf_len = 0;
    else if ( error )
      goto Exit;

    do { } while ( 0 );
    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'l' << 24 ) | ( (FT_ULong)'o' << 16 ) | ( (FT_ULong)'c' << 8 ) | (FT_ULong)'a' ), stream, &table_len );
    if ( error )
    {
      error = TT_Err_Locations_Missing;
      goto Exit;
    }

    if ( face->header.Index_To_Loc_Format != 0 )
    {
      shift = 2;

      if ( table_len >= 0x40000L )
      {
        do { } while ( 0 );
        error = TT_Err_Invalid_Table;
        goto Exit;
      }
      face->num_locations = table_len >> shift;
    }
    else
    {
      shift = 1;

      if ( table_len >= 0x20000L )
      {
        do { } while ( 0 );
        error = TT_Err_Invalid_Table;
        goto Exit;
      }
      face->num_locations = table_len >> shift;
    }

    if ( face->num_locations != (FT_ULong)face->root.num_glyphs + 1 )
    {
      do { } while ( 0 )
                                                                   ;


      if ( face->num_locations <= (FT_ULong)face->root.num_glyphs )
      {
        FT_ULong new_loca_len =
                    ( (FT_ULong)face->root.num_glyphs + 1 ) << shift;

        TT_Table entry = face->dir_tables;
        TT_Table limit = entry + face->num_tables;

        FT_Long pos = (FT_Long)FT_Stream_Pos( stream );
        FT_Long dist = 0x7FFFFFFFL;
        FT_Bool found = 0;



        for ( ; entry < limit; entry++ )
        {
          FT_Long diff = (FT_Long)entry->Offset - pos;


          if ( diff > 0 && diff < dist )
          {
            dist = diff;
            found = 1;
          }
        }

        if ( !found )
        {

          dist = (FT_Long)stream->size - pos;
        }

        if ( new_loca_len <= (FT_ULong)dist )
        {
          face->num_locations = (FT_ULong)face->root.num_glyphs + 1;
          table_len = new_loca_len;

          do { } while ( 0 )
                                            ;
        }
        else
        {
          face->root.num_glyphs = face->num_locations
                                    ? (FT_Long)face->num_locations - 1 : 0;

          do { } while ( 0 )
                                              ;
        }
      }
    }





    if ( ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(table_len), (FT_Byte**)&(face->glyph_locations) ))) ) != 0 ) )
      goto Exit;

    do { } while ( 0 );

  Exit:
    return error;
  }


  static FT_ULong
  tt_face_get_location( TT_Face face,
                        FT_UInt gindex,
                        FT_UInt *asize )
  {
    FT_ULong pos1, pos2;
    FT_Byte* p;
    FT_Byte* p_limit;


    pos1 = pos2 = 0;

    if ( gindex < face->num_locations )
    {
      if ( face->header.Index_To_Loc_Format != 0 )
      {
        p = face->glyph_locations + gindex * 4;
        p_limit = face->glyph_locations + face->num_locations * 4;

        pos1 = ( (unsigned long)( p += 4, ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(3)] )) ) << (0) )) ) ) );
        pos2 = pos1;

        if ( p + 4 <= p_limit )
          pos2 = ( (unsigned long)( p += 4, ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(3)] )) ) << (0) )) ) ) );
      }
      else
      {
        p = face->glyph_locations + gindex * 2;
        p_limit = face->glyph_locations + face->num_locations * 2;

        pos1 = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
        pos2 = pos1;

        if ( p + 2 <= p_limit )
          pos2 = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

        pos1 <<= 1;
        pos2 <<= 1;
      }
    }


    if ( pos1 > face->glyf_len )
    {
      do { } while ( 0 )



                                                 ;
      *asize = 0;
      return 0;
    }

    if ( pos2 > face->glyf_len )
    {
      do { } while ( 0 )



                                                     ;
      pos2 = face->glyf_len;
    }
# 255 "../../../libs/freetype/src/truetype/ttpload.c"
    if ( pos2 >= pos1 )
      *asize = (FT_UInt)( pos2 - pos1 );
    else
      *asize = (FT_UInt)( face->glyf_len - pos1 );

    return pos1;
  }


  static void
  tt_face_done_loca( TT_Face face )
  {
    FT_Stream stream = face->root.stream;


    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->glyph_locations) ));
    face->num_locations = 0;
  }
# 293 "../../../libs/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_cvt( TT_Face face,
                    FT_Stream stream )
  {


    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_ULong table_len;


    do { } while ( 0 );

    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'c' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'t' << 8 ) | (FT_ULong)' ' ), stream, &table_len );
    if ( error )
    {
      do { } while ( 0 );

      face->cvt_size = 0;
      face->cvt = ((void *)0);
      error = FT_Err_Ok;

      goto Exit;
    }

    face->cvt_size = table_len / 2;

    if ( ( ((face->cvt) = (ft_mem_realloc( memory, sizeof ( *(face->cvt) ), 0, (FT_Long)(face->cvt_size), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(face->cvt_size * 2L) ))) ) != 0 ) )
      goto Exit;

    {
      FT_Short* cur = face->cvt;
      FT_Short* limit = cur + face->cvt_size;


      for ( ; cur < limit; cur++ )
        *cur = ( (FT_Short)FT_Stream_GetUShort( stream ) );
    }

    (FT_Stream_ExitFrame( stream ));
    do { } while ( 0 );


    if ( face->doblend )
      error = tt_face_vary_cvt( face, stream );


  Exit:
    return error;
# 354 "../../../libs/freetype/src/truetype/ttpload.c"
  }
# 374 "../../../libs/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_fpgm( TT_Face face,
                     FT_Stream stream )
  {


    FT_Error error;
    FT_ULong table_len;


    do { } while ( 0 );


    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'f' << 24 ) | ( (FT_ULong)'p' << 16 ) | ( (FT_ULong)'g' << 8 ) | (FT_ULong)'m' ), stream, &table_len );
    if ( error )
    {
      face->font_program = ((void *)0);
      face->font_program_size = 0;
      error = FT_Err_Ok;

      do { } while ( 0 );
    }
    else
    {
      face->font_program_size = table_len;
      if ( ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(table_len), (FT_Byte**)&(face->font_program) ))) ) != 0 ) )
        goto Exit;

      do { } while ( 0 );
    }

  Exit:
    return error;
# 416 "../../../libs/freetype/src/truetype/ttpload.c"
  }
# 436 "../../../libs/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_prep( TT_Face face,
                     FT_Stream stream )
  {


    FT_Error error;
    FT_ULong table_len;


    do { } while ( 0 );

    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'p' << 24 ) | ( (FT_ULong)'r' << 16 ) | ( (FT_ULong)'e' << 8 ) | (FT_ULong)'p' ), stream, &table_len );
    if ( error )
    {
      face->cvt_program = ((void *)0);
      face->cvt_program_size = 0;
      error = FT_Err_Ok;

      do { } while ( 0 );
    }
    else
    {
      face->cvt_program_size = table_len;
      if ( ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(table_len), (FT_Byte**)&(face->cvt_program) ))) ) != 0 ) )
        goto Exit;

      do { } while ( 0 );
    }

  Exit:
    return error;
# 477 "../../../libs/freetype/src/truetype/ttpload.c"
  }
# 497 "../../../libs/freetype/src/truetype/ttpload.c"
  static FT_Error
  tt_face_load_hdmx( TT_Face face,
                     FT_Stream stream )
  {
    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_UInt version, nn, num_records;
    FT_ULong table_size, record_size;
    FT_Byte* p;
    FT_Byte* limit;



    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'h' << 24 ) | ( (FT_ULong)'d' << 16 ) | ( (FT_ULong)'m' << 8 ) | (FT_ULong)'x' ), stream, &table_size );
    if ( error || table_size < 8 )
      return FT_Err_Ok;

    if ( ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(table_size), (FT_Byte**)&(face->hdmx_table) ))) ) != 0 ) )
      goto Exit;

    p = face->hdmx_table;
    limit = p + table_size;

    version = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    num_records = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    record_size = ( (unsigned long)( p += 4, ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p - 4))[(3)] )) ) << (0) )) ) ) );
# 535 "../../../libs/freetype/src/truetype/ttpload.c"
    if ( record_size >= 0xFFFF0000UL )
      record_size &= 0xFFFFU;


    if ( version != 0 ||
         num_records > 255 ||
         record_size > 0x10001L ||
         record_size < 4 )
    {
      error = TT_Err_Invalid_File_Format;
      goto Fail;
    }

    if ( ( ((face->hdmx_record_sizes) = (ft_mem_realloc( memory, sizeof ( *(face->hdmx_record_sizes) ), 0, (FT_Long)(num_records), ((void *)0), &error ))), error != 0 ) )
      goto Fail;

    for ( nn = 0; nn < num_records; nn++ )
    {
      if ( p + record_size > limit )
        break;

      face->hdmx_record_sizes[nn] = p[0];
      p += record_size;
    }

    face->hdmx_record_count = nn;
    face->hdmx_table_size = table_size;
    face->hdmx_record_size = record_size;

  Exit:
    return error;

  Fail:
    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->hdmx_table) ));
    face->hdmx_table_size = 0;
    goto Exit;
  }


  static void
  tt_face_free_hdmx( TT_Face face )
  {
    FT_Stream stream = face->root.stream;
    FT_Memory memory = stream->memory;


    do { ft_mem_free( memory, (face->hdmx_record_sizes) ); (face->hdmx_record_sizes) = ((void *)0); } while ( 0 );
    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->hdmx_table) ));
  }







  static FT_Byte*
  tt_face_get_device_metrics( TT_Face face,
                              FT_UInt ppem,
                              FT_UInt gindex )
  {
    FT_UInt nn;
    FT_Byte* result = ((void *)0);
    FT_ULong record_size = face->hdmx_record_size;
    FT_Byte* record = face->hdmx_table + 8;


    for ( nn = 0; nn < face->hdmx_record_count; nn++ )
      if ( face->hdmx_record_sizes[nn] == ppem )
      {
        gindex += 2;
        if ( gindex < record_size )
          result = record + nn * record_size + gindex;
        break;
      }

    return result;
  }
# 25 "../../../libs/freetype/src/truetype/truetype.c" 2
# 1 "../../../libs/freetype/src/truetype/ttgload.c" 1
# 21 "../../../libs/freetype/src/truetype/ttgload.c"
# 1 "../../../libs/freetype/include/freetype/internal/ftcalc.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftcalc.h"

# 79 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  static __inline__ FT_Int32
  FT_MulFix_arm( FT_Int32 a,
                 FT_Int32 b )
  {
    FT_Int32 t, t2;


    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"
      "mov    %0, %2, asr #31\n\t"



      "add    %0, %0, #0x8000\n\t"

      "adds   %1, %1, %0\n\t"
      "adc    %2, %2, #0\n\t"
      "mov    %0, %1, lsr #16\n\t"
      "orr    %0, %0, %2, lsl #16\n\t"
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );
    return a;
  }
# 272 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Long
  FT_MulDiv_No_Round( FT_Long a,
                      FT_Long b,
                      FT_Long c );
# 286 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern void
  FT_Matrix_Multiply_Scaled( const FT_Matrix* a,
                             FT_Matrix *b,
                             FT_Long scaling );






  extern void
  FT_Vector_Transform_Scaled( FT_Vector* vector,
                              const FT_Matrix* matrix,
                              FT_Long scaling );
# 310 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_UInt32
  FT_Vector_NormLen( FT_Vector* vector );
# 320 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Int
  ft_corner_orientation( FT_Pos in_x,
                         FT_Pos in_y,
                         FT_Pos out_x,
                         FT_Pos out_y );







  extern FT_Int
  ft_corner_is_flat( FT_Pos in_x,
                     FT_Pos in_y,
                     FT_Pos out_x,
                     FT_Pos out_y );
# 372 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Fixed
  FT_Hypot( FT_Fixed x,
            FT_Fixed y );
# 413 "../../../libs/freetype/include/freetype/internal/ftcalc.h"

# 22 "../../../libs/freetype/src/truetype/ttgload.c" 2



# 1 "../../../libs/freetype/include/freetype/ftoutln.h" 1
# 34 "../../../libs/freetype/include/freetype/ftoutln.h"

# 118 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Decompose( FT_Outline* outline,
                        const FT_Outline_Funcs* func_interface,
                        void* user );
# 154 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_New( FT_Library library,
                  FT_UInt numPoints,
                  FT_Int numContours,
                  FT_Outline *anoutline );


  extern FT_Error
  FT_Outline_New_Internal( FT_Memory memory,
                           FT_UInt numPoints,
                           FT_Int numContours,
                           FT_Outline *anoutline );
# 192 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Done( FT_Library library,
                   FT_Outline* outline );


  extern FT_Error
  FT_Outline_Done_Internal( FT_Memory memory,
                            FT_Outline* outline );
# 216 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Check( FT_Outline* outline );
# 246 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Get_CBox( const FT_Outline* outline,
                       FT_BBox *acbox );
# 267 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Translate( const FT_Outline* outline,
                        FT_Pos xOffset,
                        FT_Pos yOffset );
# 292 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Copy( const FT_Outline* source,
                   FT_Outline *target );
# 316 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Transform( const FT_Outline* outline,
                        const FT_Matrix* matrix );
# 364 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Embolden( FT_Outline* outline,
                       FT_Pos strength );
# 380 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_EmboldenXY( FT_Outline* outline,
                         FT_Pos xstrength,
                         FT_Pos ystrength );
# 405 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Reverse( FT_Outline* outline );
# 440 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Get_Bitmap( FT_Library library,
                         FT_Outline* outline,
                         const FT_Bitmap *abitmap );
# 482 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Render( FT_Library library,
                     FT_Outline* outline,
                     FT_Raster_Params* params );
# 523 "../../../libs/freetype/include/freetype/ftoutln.h"
  typedef enum FT_Orientation_
  {
    FT_ORIENTATION_TRUETYPE = 0,
    FT_ORIENTATION_POSTSCRIPT = 1,
    FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE,
    FT_ORIENTATION_FILL_LEFT = FT_ORIENTATION_POSTSCRIPT,
    FT_ORIENTATION_NONE

  } FT_Orientation;
# 558 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Orientation
  FT_Outline_Get_Orientation( FT_Outline* outline );





# 26 "../../../libs/freetype/src/truetype/ttgload.c" 2

# 1 "../../../libs/freetype/include/freetype/ftlist.h" 1
# 41 "../../../libs/freetype/include/freetype/ftlist.h"

# 93 "../../../libs/freetype/include/freetype/ftlist.h"
  extern FT_ListNode
  FT_List_Find( FT_List list,
                void* data );
# 110 "../../../libs/freetype/include/freetype/ftlist.h"
  extern void
  FT_List_Add( FT_List list,
               FT_ListNode node );
# 127 "../../../libs/freetype/include/freetype/ftlist.h"
  extern void
  FT_List_Insert( FT_List list,
                  FT_ListNode node );
# 147 "../../../libs/freetype/include/freetype/ftlist.h"
  extern void
  FT_List_Remove( FT_List list,
                  FT_ListNode node );
# 165 "../../../libs/freetype/include/freetype/ftlist.h"
  extern void
  FT_List_Up( FT_List list,
              FT_ListNode node );
# 185 "../../../libs/freetype/include/freetype/ftlist.h"
  typedef FT_Error
  (*FT_List_Iterator)( FT_ListNode node,
                       void* user );
# 209 "../../../libs/freetype/include/freetype/ftlist.h"
  extern FT_Error
  FT_List_Iterate( FT_List list,
                   FT_List_Iterator iterator,
                   void* user );
# 233 "../../../libs/freetype/include/freetype/ftlist.h"
  typedef void
  (*FT_List_Destructor)( FT_Memory memory,
                         void* data,
                         void* user );
# 262 "../../../libs/freetype/include/freetype/ftlist.h"
  extern void
  FT_List_Finalize( FT_List list,
                    FT_List_Destructor destroy,
                    FT_Memory memory,
                    void* user );





# 28 "../../../libs/freetype/src/truetype/ttgload.c" 2
# 37 "../../../libs/freetype/src/truetype/ttgload.c"
# 1 "../../../libs/freetype/src/truetype/ttsubpix.h" 1
# 27 "../../../libs/freetype/src/truetype/ttsubpix.h"

# 75 "../../../libs/freetype/src/truetype/ttsubpix.h"
  static FT_Bool
  sph_test_tweak( TT_Face face,
                  const FT_String* family,
                  FT_UInt ppem,
                  const FT_String* style,
                  FT_UInt glyph_index,
                  const SPH_TweakRule* rule,
                  FT_UInt num_rules );

  static FT_UInt
  sph_test_tweak_x_scaling( TT_Face face,
                            const FT_String* family,
                            FT_UInt ppem,
                            const FT_String* style,
                            FT_UInt glyph_index );

  static void
  sph_set_tweaks( TT_Loader loader,
                  FT_UInt glyph_index );
# 106 "../../../libs/freetype/src/truetype/ttsubpix.h"

# 38 "../../../libs/freetype/src/truetype/ttgload.c" 2
# 73 "../../../libs/freetype/src/truetype/ttgload.c"
  static void
  TT_Get_HMetrics( TT_Face face,
                   FT_UInt idx,
                   FT_Short* lsb,
                   FT_UShort* aw )
  {
    ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );

    do { } while ( 0 );
    do { } while ( 0 );
  }







  static void
  TT_Get_VMetrics( TT_Face face,
                   FT_UInt idx,
                   FT_Pos yMax,
                   FT_Short* tsb,
                   FT_UShort* ah )
  {
    if ( face->vertical_info )
      ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );

    else if ( face->os2.version != 0xFFFFU )
    {
      *tsb = (FT_Short)( face->os2.sTypoAscender - yMax );
      *ah = (FT_UShort)( (face->os2.sTypoAscender - face->os2.sTypoDescender) < 0 ? -(face->os2.sTypoAscender - face->os2.sTypoDescender) : (face->os2.sTypoAscender - face->os2.sTypoDescender) )
                                                          ;
    }

    else
    {
      *tsb = (FT_Short)( face->horizontal.Ascender - yMax );
      *ah = (FT_UShort)( (face->horizontal.Ascender - face->horizontal.Descender) < 0 ? -(face->horizontal.Ascender - face->horizontal.Descender) : (face->horizontal.Ascender - face->horizontal.Descender) )
                                                            ;
    }

    do { } while ( 0 );
    do { } while ( 0 );
  }


  static FT_Error
  tt_get_metrics( TT_Loader loader,
                  FT_UInt glyph_index )
  {
    TT_Face face = loader->face;

    TT_Driver driver = (TT_Driver)((FT_Face)(face))->driver;


    FT_Error error;
    FT_Stream stream = loader->stream;

    FT_Short left_bearing = 0, top_bearing = 0;
    FT_UShort advance_width = 0, advance_height = 0;



    FT_ULong pos = FT_Stream_Pos( stream );


    TT_Get_HMetrics( face, glyph_index,
                     &left_bearing,
                     &advance_width );
    TT_Get_VMetrics( face, glyph_index,
                     loader->bbox.yMax,
                     &top_bearing,
                     &advance_height );

    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(pos) )) ) != 0 ) )
      return error;

    loader->left_bearing = left_bearing;
    loader->advance = advance_width;
    loader->top_bearing = top_bearing;
    loader->vadvance = advance_height;


    if ( driver->interpreter_version == 38 &&
         loader->exec )
    {
      loader->exec->sph_tweak_flags = 0;





      sph_set_tweaks( loader, glyph_index );
    }


    if ( !loader->linear_def )
    {
      loader->linear_def = 1;
      loader->linear = advance_width;
    }

    return FT_Err_Ok;
  }




  static void
  tt_get_metrics_incr_overrides( TT_Loader loader,
                                 FT_UInt glyph_index )
  {
    TT_Face face = loader->face;

    FT_Short left_bearing = 0, top_bearing = 0;
    FT_UShort advance_width = 0, advance_height = 0;




    if ( face->root.internal->incremental_interface &&
         face->root.internal->incremental_interface->funcs->get_glyph_metrics )
    {
      FT_Incremental_MetricsRec metrics;
      FT_Error error;


      metrics.bearing_x = loader->left_bearing;
      metrics.bearing_y = 0;
      metrics.advance = loader->advance;
      metrics.advance_v = 0;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, 0, &metrics );
      if ( error )
        goto Exit;

      left_bearing = (FT_Short)metrics.bearing_x;
      advance_width = (FT_UShort)metrics.advance;
# 233 "../../../libs/freetype/src/truetype/ttgload.c"
      loader->left_bearing = left_bearing;
      loader->advance = advance_width;
      loader->top_bearing = top_bearing;
      loader->vadvance = advance_height;

      if ( !loader->linear_def )
      {
        loader->linear_def = 1;
        loader->linear = advance_width;
      }
    }

  Exit:
    return;
  }
# 260 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Access_Glyph_Frame( TT_Loader loader,
                         FT_UInt glyph_index,
                         FT_ULong offset,
                         FT_UInt byte_count )
  {
    FT_Error error;
    FT_Stream stream = loader->stream;


    ( (glyph_index) = (glyph_index) );


    do { } while ( 0 );


    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(offset) )) ) != 0 ) || ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(byte_count) ))) ) != 0 ) )
      return error;

    loader->cursor = stream->cursor;
    loader->limit = stream->limit;

    return FT_Err_Ok;
  }


  static void
  TT_Forget_Glyph_Frame( TT_Loader loader )
  {
    FT_Stream stream = loader->stream;


    (FT_Stream_ExitFrame( stream ));
  }


  static FT_Error
  TT_Load_Glyph_Header( TT_Loader loader )
  {
    FT_Byte* p = loader->cursor;
    FT_Byte* limit = loader->limit;


    if ( p + 10 > limit )
      return TT_Err_Invalid_Outline;

    loader->n_contours = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    loader->bbox.xMin = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    loader->bbox.yMin = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    loader->bbox.xMax = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
    loader->bbox.yMax = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    do { } while ( 0 );
    do { } while ( 0 )
                                                                ;
    do { } while ( 0 )
                                                                ;
    loader->cursor = p;

    return FT_Err_Ok;
  }


  static FT_Error
  TT_Load_Simple_Glyph( TT_Loader load )
  {
    FT_Error error;
    FT_Byte* p = load->cursor;
    FT_Byte* limit = load->limit;
    FT_GlyphLoader gloader = load->gloader;
    FT_Int n_contours = load->n_contours;
    FT_Outline* outline;
    FT_UShort n_ins;
    FT_Int n_points;
    FT_ULong tmp;

    FT_Byte *flag, *flag_limit;
    FT_Byte c, count;
    FT_Vector *vec, *vec_limit;
    FT_Pos x;
    FT_Short *cont, *cont_limit, prev_cont;
    FT_Int xy_size = 0;



    error = ( ( ( (0) == 0 || ( (FT_UInt)(gloader)->base.outline.n_points + (FT_UInt)(gloader)->current.outline.n_points + (FT_UInt)(0) ) <= (gloader)->max_points ) && ( (n_contours) == 0 || ( (FT_UInt)(gloader)->base.outline.n_contours + (FT_UInt)(gloader)->current.outline.n_contours + (FT_UInt)(n_contours) ) <= (gloader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (gloader), (FT_UInt)(0), (FT_UInt)(n_contours) ) );
    if ( error )
      goto Fail;


    cont = gloader->current.outline.contours;
    cont_limit = cont + n_contours;


    if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
      goto Invalid_Outline;

    prev_cont = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    if ( n_contours > 0 )
      cont[0] = prev_cont;

    if ( prev_cont < 0 )
      goto Invalid_Outline;

    for ( cont++; cont < cont_limit; cont++ )
    {
      cont[0] = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      if ( cont[0] <= prev_cont )
      {

        goto Invalid_Outline;
      }
      prev_cont = cont[0];
    }

    n_points = 0;
    if ( n_contours > 0 )
    {
      n_points = cont[-1] + 1;
      if ( n_points < 0 )
        goto Invalid_Outline;
    }


    error = ( ( ( (n_points + 4) == 0 || ( (FT_UInt)(gloader)->base.outline.n_points + (FT_UInt)(gloader)->current.outline.n_points + (FT_UInt)(n_points + 4) ) <= (gloader)->max_points ) && ( (0) == 0 || ( (FT_UInt)(gloader)->base.outline.n_contours + (FT_UInt)(gloader)->current.outline.n_contours + (FT_UInt)(0) ) <= (gloader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (gloader), (FT_UInt)(n_points + 4), (FT_UInt)(0) ) );
    if ( error )
      goto Fail;


    load->glyph->control_len = 0;
    load->glyph->control_data = ((void *)0);

    if ( p + 2 > limit )
      goto Invalid_Outline;

    n_ins = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

    do { } while ( 0 );


    if ( ( limit - p ) < n_ins )
    {
      do { } while ( 0 );
      error = TT_Err_Too_Many_Hints;
      goto Fail;
    }



    if ( ( ( load->load_flags & ( 1L << 1 ) ) == 0 ) )
    {



      tmp = load->exec->glyphSize;
      error = Update_Max( load->exec->memory,
                          &tmp,
                          sizeof ( FT_Byte ),
                          (void*)&load->exec->glyphIns,
                          n_ins );

      load->exec->glyphSize = (FT_UShort)tmp;
      if ( error )
        return error;

      load->glyph->control_len = n_ins;
      load->glyph->control_data = load->exec->glyphIns;

      memcpy( load->exec->glyphIns, p, (FT_Offset)((FT_Long)n_ins) );
    }



    p += n_ins;

    outline = &gloader->current.outline;


    flag = (FT_Byte*)outline->tags;
    flag_limit = flag + n_points;

    do { } while ( 0 );

    while ( flag < flag_limit )
    {
      if ( p + 1 > limit )
        goto Invalid_Outline;

      *flag++ = c = ( (unsigned char)*p++ );
      if ( c & 8 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        count = ( (unsigned char)*p++ );
        if ( flag + (FT_Int)count > flag_limit )
          goto Invalid_Outline;

        for ( ; count > 0; count-- )
          *flag++ = c;
      }
    }



    vec = outline->points;
    vec_limit = vec + n_points;
    flag = (FT_Byte*)outline->tags;
    x = 0;

    if ( p + xy_size > limit )
      goto Invalid_Outline;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos y = 0;
      FT_Byte f = *flag;


      if ( f & 2 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (unsigned char)*p++ );
        if ( ( f & 16 ) == 0 )
          y = -y;
      }
      else if ( ( f & 16 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      }

      x += y;
      vec->x = x;

      *flag = (FT_Byte)( f & ~( 2 | 16 ) );
    }



    vec = gloader->current.outline.points;
    vec_limit = vec + n_points;
    flag = (FT_Byte*)outline->tags;
    x = 0;

    for ( ; vec < vec_limit; vec++, flag++ )
    {
      FT_Pos y = 0;
      FT_Byte f = *flag;


      if ( f & 4 )
      {
        if ( p + 1 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (unsigned char)*p++ );
        if ( ( f & 32 ) == 0 )
          y = -y;
      }
      else if ( ( f & 32 ) == 0 )
      {
        if ( p + 2 > limit )
          goto Invalid_Outline;

        y = (FT_Pos)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      }

      x += y;
      vec->y = x;

      *flag = (FT_Byte)( f & 1 );
    }

    outline->n_points = (FT_Short)n_points;
    outline->n_contours = (FT_Short)n_contours;

    load->cursor = p;

  Fail:
    return error;

  Invalid_Outline:
    error = TT_Err_Invalid_Outline;
    goto Fail;
  }


  static FT_Error
  TT_Load_Composite_Glyph( TT_Loader loader )
  {
    FT_Error error;
    FT_Byte* p = loader->cursor;
    FT_Byte* limit = loader->limit;
    FT_GlyphLoader gloader = loader->gloader;
    FT_SubGlyph subglyph;
    FT_UInt num_subglyphs;


    num_subglyphs = 0;

    do
    {
      FT_Fixed xx, xy, yy, yx;
      FT_UInt count;



      error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
      if ( error )
        goto Fail;


      if ( p + 4 > limit )
        goto Invalid_Composite;

      subglyph = gloader->current.subglyphs + num_subglyphs;

      subglyph->arg1 = subglyph->arg2 = 0;

      subglyph->flags = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
      subglyph->index = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );


      count = 2;
      if ( subglyph->flags & 0x0001 )
        count += 2;
      if ( subglyph->flags & 0x0008 )
        count += 2;
      else if ( subglyph->flags & 0x0040 )
        count += 4;
      else if ( subglyph->flags & 0x0080 )
        count += 8;

      if ( p + count > limit )
        goto Invalid_Composite;


      if ( subglyph->flags & 0x0002 )
      {
        if ( subglyph->flags & 0x0001 )
        {
          subglyph->arg1 = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
          subglyph->arg2 = ( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
        }
        else
        {
          subglyph->arg1 = ( (signed char)*p++ );
          subglyph->arg2 = ( (signed char)*p++ );
        }
      }
      else
      {
        if ( subglyph->flags & 0x0001 )
        {
          subglyph->arg1 = (FT_Int)( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
          subglyph->arg2 = (FT_Int)( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
        }
        else
        {
          subglyph->arg1 = (FT_Int)( (unsigned char)*p++ );
          subglyph->arg2 = (FT_Int)( (unsigned char)*p++ );
        }
      }


      xx = yy = 0x10000L;
      xy = yx = 0;

      if ( subglyph->flags & 0x0008 )
      {
        xx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
        yy = xx;
      }
      else if ( subglyph->flags & 0x0040 )
      {
        xx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
        yy = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
      }
      else if ( subglyph->flags & 0x0080 )
      {
        xx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
        yx = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
        xy = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
        yy = (FT_Fixed)( (short)( p += 2, ( (FT_Int16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) ) * 4;
      }

      subglyph->transform.xx = xx;
      subglyph->transform.xy = xy;
      subglyph->transform.yx = yx;
      subglyph->transform.yy = yy;

      num_subglyphs++;

    } while ( subglyph->flags & 0x0020 );

    gloader->current.num_subglyphs = num_subglyphs;
    do { } while ( 0 );



    {
      FT_Stream stream = loader->stream;






      loader->ins_pos = (FT_ULong)( FT_Stream_Pos( stream ) +
                                    p - limit );
    }



    loader->cursor = p;

  Fail:
    return error;

  Invalid_Composite:
    error = TT_Err_Invalid_Composite;
    goto Fail;
  }


  static void
  TT_Init_Glyph_Loading( TT_Face face )
  {
    face->access_glyph_frame = TT_Access_Glyph_Frame;
    face->read_glyph_header = TT_Load_Glyph_Header;
    face->read_simple_glyph = TT_Load_Simple_Glyph;
    face->read_composite_glyph = TT_Load_Composite_Glyph;
    face->forget_glyph_frame = TT_Forget_Glyph_Frame;
  }


  static void
  tt_prepare_zone( TT_GlyphZone zone,
                   FT_GlyphLoad load,
                   FT_UInt start_point,
                   FT_UInt start_contour )
  {
    zone->n_points = (FT_UShort)load->outline.n_points -
                          (FT_UShort)start_point;
    zone->n_contours = load->outline.n_contours -
                          (FT_Short)start_contour;
    zone->org = load->extra_points + start_point;
    zone->cur = load->outline.points + start_point;
    zone->orus = load->extra_points2 + start_point;
    zone->tags = (FT_Byte*)load->outline.tags + start_point;
    zone->contours = (FT_UShort*)load->outline.contours + start_contour;
    zone->first_point = (FT_UShort)start_point;
  }
# 731 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Hint_Glyph( TT_Loader loader,
                 FT_Bool is_composite )
  {

    TT_Face face = loader->face;
    TT_Driver driver = (TT_Driver)((FT_Face)(face))->driver;


    TT_GlyphZone zone = &loader->zone;


    FT_Long n_ins;






    if ( loader->glyph->control_len > 0xFFFFL )
    {
      do { } while ( 0 );
      do { } while ( 0 )
                                              ;
    }
    n_ins = loader->glyph->control_len;


    if ( n_ins > 0 )
      memcpy( zone->org, zone->cur, (FT_Offset)((FT_Offset)(zone->n_points) * sizeof ( *(zone->org) )) );


    loader->exec->GS = loader->size->GS;



    if ( is_composite )
    {
      loader->exec->metrics.x_scale = 1 << 16;
      loader->exec->metrics.y_scale = 1 << 16;

      memcpy( zone->orus, zone->cur, (FT_Offset)((FT_Offset)(zone->n_points) * sizeof ( *(zone->orus) )) );
    }
    else
    {
      loader->exec->metrics.x_scale = loader->size->metrics.x_scale;
      loader->exec->metrics.y_scale = loader->size->metrics.y_scale;
    }



    zone->cur[zone->n_points - 4].x =
      ( ((zone->cur[zone->n_points - 4].x) + 32) & ~(__typeof__ ((zone->cur[zone->n_points - 4].x) + 32))63 );
    zone->cur[zone->n_points - 3].x =
      ( ((zone->cur[zone->n_points - 3].x) + 32) & ~(__typeof__ ((zone->cur[zone->n_points - 3].x) + 32))63 );
    zone->cur[zone->n_points - 2].y =
      ( ((zone->cur[zone->n_points - 2].y) + 32) & ~(__typeof__ ((zone->cur[zone->n_points - 2].y) + 32))63 );
    zone->cur[zone->n_points - 1].y =
      ( ((zone->cur[zone->n_points - 1].y) + 32) & ~(__typeof__ ((zone->cur[zone->n_points - 1].y) + 32))63 );



    if ( n_ins > 0 )
    {
      FT_Error error;

      FT_GlyphLoader gloader = loader->gloader;
      FT_Outline current_outline = gloader->current.outline;


      TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                        loader->exec->glyphIns, n_ins );

      loader->exec->is_composite = is_composite;
      loader->exec->pts = *zone;

      error = TT_Run_Context( loader->exec );
      if ( error && loader->exec->pedantic_hinting )
        return error;


      current_outline.tags[0] |=
        ( loader->exec->GS.scan_type << 5 ) | 4;
    }




    loader->pp1 = zone->cur[zone->n_points - 4];
    loader->pp2 = zone->cur[zone->n_points - 3];
    loader->pp3 = zone->cur[zone->n_points - 2];
    loader->pp4 = zone->cur[zone->n_points - 1];


    if ( driver->interpreter_version == 38 )
    {
      if ( loader->exec->sph_tweak_flags & 0x0000010UL )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );

      else if ( loader->exec->sph_tweak_flags & 0x0000040UL )
        FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
    }


    return FT_Err_Ok;
  }
# 849 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Process_Simple_Glyph( TT_Loader loader )
  {
    FT_GlyphLoader gloader = loader->gloader;
    FT_Error error = FT_Err_Ok;
    FT_Outline* outline;
    FT_Int n_points;


    outline = &gloader->current.outline;
    n_points = outline->n_points;



    outline->points[n_points ] = loader->pp1;
    outline->points[n_points + 1] = loader->pp2;
    outline->points[n_points + 2] = loader->pp3;
    outline->points[n_points + 3] = loader->pp4;

    outline->tags[n_points ] = 0;
    outline->tags[n_points + 1] = 0;
    outline->tags[n_points + 2] = 0;
    outline->tags[n_points + 3] = 0;

    n_points += 4;



    if ( loader->face->doblend )
    {

      error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                          loader->glyph_index,
                                          outline,
                                          (FT_UInt)n_points );
      if ( error )
        return error;
    }



    if ( ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) )
    {
      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );

      memcpy( loader->zone.orus, loader->zone.cur, (FT_Offset)((FT_Offset)(loader->zone.n_points + 4) * sizeof ( *(loader->zone.orus) )) )
                                                ;
    }

    {

      TT_Face face = loader->face;
      TT_Driver driver = (TT_Driver)((FT_Face)(face))->driver;

      FT_String* family = face->root.family_name;
      FT_UInt ppem = loader->size->metrics.x_ppem;
      FT_String* style = face->root.style_name;
      FT_UInt x_scale_factor = 1000;


      FT_Vector* vec = outline->points;
      FT_Vector* limit = outline->points + n_points;

      FT_Fixed x_scale = 0;
      FT_Fixed y_scale = 0;

      FT_Bool do_scale = 0;




      if ( driver->interpreter_version == 38 )
      {

        if ( ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) )
          x_scale_factor = sph_test_tweak_x_scaling( face,
                                                     family,
                                                     ppem,
                                                     style,
                                                     loader->glyph_index );

        if ( ( loader->load_flags & ( 1L << 0 ) ) == 0 ||
             x_scale_factor != 1000 )
        {
          x_scale = FT_MulDiv( loader->size->metrics.x_scale,
                               (FT_Long)x_scale_factor, 1000 );
          y_scale = loader->size->metrics.y_scale;



          if ( x_scale_factor != 1000 && ppem > 11 )
            FT_Outline_EmboldenXY( outline,
                                   FT_MulFix_arm( (FT_Int32)(1280 * ppem), (FT_Int32)(1000 - x_scale_factor) )
                                                                     ,
                                   0 );
          do_scale = 1;
        }
      }
      else



      {

        if ( ( loader->load_flags & ( 1L << 0 ) ) == 0 )
        {
          x_scale = loader->size->metrics.x_scale;
          y_scale = loader->size->metrics.y_scale;

          do_scale = 1;
        }
      }

      if ( do_scale )
      {
        for ( ; vec < limit; vec++ )
        {
          vec->x = FT_MulFix_arm( (FT_Int32)(vec->x), (FT_Int32)(x_scale) );
          vec->y = FT_MulFix_arm( (FT_Int32)(vec->y), (FT_Int32)(y_scale) );
        }

        loader->pp1 = outline->points[n_points - 4];
        loader->pp2 = outline->points[n_points - 3];
        loader->pp3 = outline->points[n_points - 2];
        loader->pp4 = outline->points[n_points - 1];
      }
    }

    if ( ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) )
    {
      loader->zone.n_points += 4;

      error = TT_Hint_Glyph( loader, 0 );
    }

    return error;
  }
# 997 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Process_Composite_Component( TT_Loader loader,
                                  FT_SubGlyph subglyph,
                                  FT_UInt start_point,
                                  FT_UInt num_base_points )
  {
    FT_GlyphLoader gloader = loader->gloader;
    FT_Outline current;
    FT_Bool have_scale;
    FT_Pos x, y;


    current.points = gloader->base.outline.points +
                         num_base_points;
    current.n_points = gloader->base.outline.n_points -
                         (short)num_base_points;

    have_scale = ( (FT_Bool)( subglyph->flags & ( 0x0008 | 0x0040 | 0x0080 ) ) )

                                                                     ;


    if ( have_scale )
      FT_Outline_Transform( &current, &subglyph->transform );


    if ( !( subglyph->flags & 0x0002 ) )
    {
      FT_UInt num_points = (FT_UInt)gloader->base.outline.n_points;
      FT_UInt k = (FT_UInt)subglyph->arg1;
      FT_UInt l = (FT_UInt)subglyph->arg2;
      FT_Vector* p1;
      FT_Vector* p2;






      k += start_point;
      l += num_base_points;
      if ( k >= num_base_points ||
           l >= num_points )
        return TT_Err_Invalid_Composite;

      p1 = gloader->base.outline.points + k;
      p2 = gloader->base.outline.points + l;

      x = p1->x - p2->x;
      y = p1->y - p2->y;
    }
    else
    {
      x = subglyph->arg1;
      y = subglyph->arg2;

      if ( !x && !y )
        return FT_Err_Ok;





      if ( have_scale &&



            ( subglyph->flags & 0x0800 ) )

      {
# 1099 "../../../libs/freetype/src/truetype/ttgload.c"
        FT_Fixed mac_xscale = FT_Hypot( subglyph->transform.xx,
                                         subglyph->transform.xy );
        FT_Fixed mac_yscale = FT_Hypot( subglyph->transform.yy,
                                         subglyph->transform.yx );


        x = FT_MulFix_arm( (FT_Int32)(x), (FT_Int32)(mac_xscale) );
        y = FT_MulFix_arm( (FT_Int32)(y), (FT_Int32)(mac_yscale) );



      }

      if ( !( loader->load_flags & ( 1L << 0 ) ) )
      {
        FT_Fixed x_scale = loader->size->metrics.x_scale;
        FT_Fixed y_scale = loader->size->metrics.y_scale;


        x = FT_MulFix_arm( (FT_Int32)(x), (FT_Int32)(x_scale) );
        y = FT_MulFix_arm( (FT_Int32)(y), (FT_Int32)(y_scale) );

        if ( subglyph->flags & 0x0004 )
        {
          x = ( ((x) + 32) & ~(__typeof__ ((x) + 32))63 );
          y = ( ((y) + 32) & ~(__typeof__ ((y) + 32))63 );
        }
      }
    }

    if ( x || y )
      FT_Outline_Translate( &current, x, y );

    return FT_Err_Ok;
  }
# 1146 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Process_Composite_Glyph( TT_Loader loader,
                              FT_UInt start_point,
                              FT_UInt start_contour )
  {
    FT_Error error;
    FT_Outline* outline;
    FT_UInt i;


    outline = &loader->gloader->base.outline;


    error = ( ( ( (outline->n_points + 4) == 0 || ( (FT_UInt)(loader->gloader)->base.outline.n_points + (FT_UInt)(loader->gloader)->current.outline.n_points + (FT_UInt)(outline->n_points + 4) ) <= (loader->gloader)->max_points ) && ( (0) == 0 || ( (FT_UInt)(loader->gloader)->base.outline.n_contours + (FT_UInt)(loader->gloader)->current.outline.n_contours + (FT_UInt)(0) ) <= (loader->gloader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (loader->gloader), (FT_UInt)(outline->n_points + 4), (FT_UInt)(0) ) )

                                            ;
    if ( error )
      return error;

    outline->points[outline->n_points ] = loader->pp1;
    outline->points[outline->n_points + 1] = loader->pp2;
    outline->points[outline->n_points + 2] = loader->pp3;
    outline->points[outline->n_points + 3] = loader->pp4;

    outline->tags[outline->n_points ] = 0;
    outline->tags[outline->n_points + 1] = 0;
    outline->tags[outline->n_points + 2] = 0;
    outline->tags[outline->n_points + 3] = 0;



    {
      FT_Stream stream = loader->stream;
      FT_UShort n_ins, max_ins;
      FT_ULong tmp;




      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(loader->ins_pos) )) ) != 0 ) ||
           ( n_ins = (FT_UShort)FT_Stream_ReadUShort( stream, &error ), error != FT_Err_Ok ) )
        return error;

      do { } while ( 0 );


      max_ins = loader->face->max_profile.maxSizeOfInstructions;
      if ( n_ins > max_ins )
      {


        if ( (FT_Int)n_ins > loader->byte_len )
        {
          do { } while ( 0 )

                                                ;
          return TT_Err_Too_Many_Hints;
        }

        tmp = loader->exec->glyphSize;
        error = Update_Max( loader->exec->memory,
                            &tmp,
                            sizeof ( FT_Byte ),
                            (void*)&loader->exec->glyphIns,
                            n_ins );

        loader->exec->glyphSize = (FT_UShort)tmp;
        if ( error )
          return error;
      }
      else if ( n_ins == 0 )
        return FT_Err_Ok;

      if ( ( ( error = (FT_Stream_Read( stream, (FT_Byte*)(loader->exec->glyphIns), (FT_ULong)(n_ins) )) ) != 0 ) )
        return error;

      loader->glyph->control_data = loader->exec->glyphIns;
      loader->glyph->control_len = n_ins;
    }



    tt_prepare_zone( &loader->zone, &loader->gloader->base,
                     start_point, start_contour );



    for ( i = 0; i < loader->zone.n_points; i++ )
      loader->zone.tags[i] &= ~( 8 | 16 );

    loader->zone.n_points += 4;

    return TT_Hint_Glyph( loader, 1 );
  }
# 1380 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  load_truetype_glyph( TT_Loader loader,
                       FT_UInt glyph_index,
                       FT_UInt recurse_count,
                       FT_Bool header_only )
  {
    FT_Error error = FT_Err_Ok;
    FT_Fixed x_scale, y_scale;
    FT_ULong offset;
    TT_Face face = loader->face;
    FT_GlyphLoader gloader = loader->gloader;
    FT_Bool opened_frame = 0;


    FT_StreamRec inc_stream;
    FT_Data glyph_data;
    FT_Bool glyph_data_loaded = 0;
# 1407 "../../../libs/freetype/src/truetype/ttgload.c"
    if ( recurse_count > 1 &&
         recurse_count > face->max_profile.maxComponentDepth )
    {
      error = TT_Err_Invalid_Composite;
      goto Exit;
    }
# 1423 "../../../libs/freetype/src/truetype/ttgload.c"
    loader->glyph_index = glyph_index;

    if ( ( loader->load_flags & ( 1L << 0 ) ) == 0 )
    {
      x_scale = loader->size->metrics.x_scale;
      y_scale = loader->size->metrics.y_scale;
    }
    else
    {
      x_scale = 0x10000L;
      y_scale = 0x10000L;
    }
# 1445 "../../../libs/freetype/src/truetype/ttgload.c"
    if ( face->root.internal->incremental_interface )
    {
      error = face->root.internal->incremental_interface->funcs->get_glyph_data(
                face->root.internal->incremental_interface->object,
                glyph_index, &glyph_data );
      if ( error )
        goto Exit;

      glyph_data_loaded = 1;
      offset = 0;
      loader->byte_len = glyph_data.length;

      memset( &inc_stream, 0, (FT_Offset)(sizeof ( inc_stream )) );
      FT_Stream_OpenMemory( &inc_stream,
                            glyph_data.pointer,
                            (FT_ULong)glyph_data.length );

      loader->stream = &inc_stream;
    }
    else



      offset = tt_face_get_location( face, glyph_index,
                                     (FT_UInt*)&loader->byte_len );

    if ( loader->byte_len > 0 )
    {


      if ( !loader->glyf_offset &&
           !face->root.internal->incremental_interface )



      {
        do { } while ( 0 );
        error = TT_Err_Invalid_Table;
        goto Exit;
      }

      error = face->access_glyph_frame( loader, glyph_index,
                                        loader->glyf_offset + offset,
                                        (FT_UInt)loader->byte_len );
      if ( error )
        goto Exit;

      opened_frame = 1;


      error = face->read_glyph_header( loader );
      if ( error )
        goto Exit;




      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
        goto Exit;
    }

    if ( loader->byte_len == 0 || loader->n_contours == 0 )
    {
      loader->bbox.xMin = 0;
      loader->bbox.xMax = 0;
      loader->bbox.yMin = 0;
      loader->bbox.yMax = 0;

      error = tt_get_metrics( loader, glyph_index );
      if ( error )
        goto Exit;

      if ( header_only )
        goto Exit;



      do { FT_Bool subpixel_hinting_ = loader->exec ? loader->exec->subpixel_hinting : 0; FT_Bool grayscale_ = loader->exec ? loader->exec->grayscale : 0; FT_Bool use_aw_2_ = (FT_Bool)( subpixel_hinting_ && grayscale_ ); (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; (loader)->pp1.y = 0; (loader)->pp2.x = (loader)->pp1.x + (loader)->advance; (loader)->pp2.y = 0; (loader)->pp3.x = use_aw_2_ ? (loader)->advance / 2 : 0; (loader)->pp3.y = (loader)->bbox.yMax + (loader)->top_bearing; (loader)->pp4.x = use_aw_2_ ? (loader)->advance / 2 : 0; (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance; } while ( 0 );


      tt_get_metrics_incr_overrides( loader, glyph_index );




      if ( loader->face->doblend )
      {


        FT_Vector points[4];
        char tags[4] = { 1, 1, 1, 1 };
        short contours[4] = { 0, 1, 2, 3 };
        FT_Outline outline;


        points[0].x = loader->pp1.x;
        points[0].y = loader->pp1.y;
        points[1].x = loader->pp2.x;
        points[1].y = loader->pp2.y;

        points[2].x = loader->pp3.x;
        points[2].y = loader->pp3.y;
        points[3].x = loader->pp4.x;
        points[3].y = loader->pp4.y;

        outline.n_points = 4;
        outline.n_contours = 4;
        outline.points = points;
        outline.tags = tags;
        outline.contours = contours;


        error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                            glyph_index,
                                            &outline,
                                            (FT_UInt)outline.n_points );
        if ( error )
          goto Exit;

        loader->pp1.x = points[0].x;
        loader->pp1.y = points[0].y;
        loader->pp2.x = points[1].x;
        loader->pp2.y = points[1].y;

        loader->pp3.x = points[2].x;
        loader->pp3.y = points[2].y;
        loader->pp4.x = points[3].x;
        loader->pp4.y = points[3].y;
      }





      if ( ( loader->load_flags & ( 1L << 0 ) ) == 0 )
      {
        loader->pp1.x = FT_MulFix_arm( (FT_Int32)(loader->pp1.x), (FT_Int32)(x_scale) );
        loader->pp2.x = FT_MulFix_arm( (FT_Int32)(loader->pp2.x), (FT_Int32)(x_scale) );


        loader->pp3.x = FT_MulFix_arm( (FT_Int32)(loader->pp3.x), (FT_Int32)(x_scale) );
        loader->pp3.y = FT_MulFix_arm( (FT_Int32)(loader->pp3.y), (FT_Int32)(y_scale) );
        loader->pp4.x = FT_MulFix_arm( (FT_Int32)(loader->pp4.x), (FT_Int32)(x_scale) );
        loader->pp4.y = FT_MulFix_arm( (FT_Int32)(loader->pp4.y), (FT_Int32)(y_scale) );
      }

      error = FT_Err_Ok;
      goto Exit;
    }



    do { FT_Bool subpixel_hinting_ = loader->exec ? loader->exec->subpixel_hinting : 0; FT_Bool grayscale_ = loader->exec ? loader->exec->grayscale : 0; FT_Bool use_aw_2_ = (FT_Bool)( subpixel_hinting_ && grayscale_ ); (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; (loader)->pp1.y = 0; (loader)->pp2.x = (loader)->pp1.x + (loader)->advance; (loader)->pp2.y = 0; (loader)->pp3.x = use_aw_2_ ? (loader)->advance / 2 : 0; (loader)->pp3.y = (loader)->bbox.yMax + (loader)->top_bearing; (loader)->pp4.x = use_aw_2_ ? (loader)->advance / 2 : 0; (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance; } while ( 0 );


    tt_get_metrics_incr_overrides( loader, glyph_index );
# 1613 "../../../libs/freetype/src/truetype/ttgload.c"
    if ( loader->n_contours > 0 )
    {
      error = face->read_simple_glyph( loader );
      if ( error )
        goto Exit;


      face->forget_glyph_frame( loader );
      opened_frame = 0;

      error = TT_Process_Simple_Glyph( loader );
      if ( error )
        goto Exit;

      FT_GlyphLoader_Add( gloader );
    }






    else if ( loader->n_contours == -1 )
    {
      FT_Memory memory = face->root.memory;

      FT_UInt start_point;
      FT_UInt start_contour;
      FT_ULong ins_pos;
# 1652 "../../../libs/freetype/src/truetype/ttgload.c"
      if ( FT_List_Find( &loader->composites,
                         (void*)(unsigned long)glyph_index ) )
      {
        do { } while ( 0 )
                                                       ;
        error = TT_Err_Invalid_Composite;
        goto Exit;
      }
      else
      {
        FT_ListNode node = ((void *)0);


        if ( ( ((node) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *(node) )), &error ))), error != 0 ) )
          goto Exit;
        node->data = (void*)(unsigned long)glyph_index;
        FT_List_Add( &loader->composites, node );
      }

      start_point = (FT_UInt)gloader->base.outline.n_points;
      start_contour = (FT_UInt)gloader->base.outline.n_contours;


      error = face->read_composite_glyph( loader );
      if ( error )
        goto Exit;


      ins_pos = loader->ins_pos;


      face->forget_glyph_frame( loader );
      opened_frame = 0;



      if ( face->doblend )
      {
        short i, limit;
        FT_SubGlyph subglyph;

        FT_Outline outline;
        FT_Vector* points = ((void *)0);
        char* tags = ((void *)0);
        short* contours = ((void *)0);


        limit = (short)gloader->current.num_subglyphs;



        outline.n_points = (short)( gloader->current.num_subglyphs + 4 );
        outline.n_contours = outline.n_points;

        if ( ( ((points) = (ft_mem_realloc( memory, sizeof ( *(points) ), 0, (FT_Long)(outline.n_points), ((void *)0), &error ))), error != 0 ) ||
             ( ((tags) = (ft_mem_realloc( memory, sizeof ( *(tags) ), 0, (FT_Long)(outline.n_points), ((void *)0), &error ))), error != 0 ) ||
             ( ((contours) = (ft_mem_realloc( memory, sizeof ( *(contours) ), 0, (FT_Long)(outline.n_points), ((void *)0), &error ))), error != 0 ) )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {



          points[i].x = subglyph->arg1;
          points[i].y = subglyph->arg2;
          tags[i] = 1;
          contours[i] = i;
        }

        points[i].x = loader->pp1.x;
        points[i].y = loader->pp1.y;
        tags[i] = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp2.x;
        points[i].y = loader->pp2.y;
        tags[i] = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp3.x;
        points[i].y = loader->pp3.y;
        tags[i] = 1;
        contours[i] = i;

        i++;
        points[i].x = loader->pp4.x;
        points[i].y = loader->pp4.y;
        tags[i] = 1;
        contours[i] = i;

        outline.points = points;
        outline.tags = tags;
        outline.contours = contours;



        if ( ( error = TT_Vary_Apply_Glyph_Deltas(
                         face,
                         glyph_index,
                         &outline,
                         (FT_UInt)outline.n_points ) ) != 0 )
          goto Exit1;

        subglyph = gloader->current.subglyphs;

        for ( i = 0; i < limit; i++, subglyph++ )
        {



          subglyph->arg1 = (FT_Int16)points[i].x;
          subglyph->arg2 = (FT_Int16)points[i].y;
        }

        loader->pp1.x = points[i + 0].x;
        loader->pp1.y = points[i + 0].y;
        loader->pp2.x = points[i + 1].x;
        loader->pp2.y = points[i + 1].y;

        loader->pp3.x = points[i + 2].x;
        loader->pp3.y = points[i + 2].y;
        loader->pp4.x = points[i + 3].x;
        loader->pp4.y = points[i + 3].y;

      Exit1:
        do { ft_mem_free( memory, (outline.points) ); (outline.points) = ((void *)0); } while ( 0 );
        do { ft_mem_free( memory, (outline.tags) ); (outline.tags) = ((void *)0); } while ( 0 );
        do { ft_mem_free( memory, (outline.contours) ); (outline.contours) = ((void *)0); } while ( 0 );

        if ( error )
          goto Exit;
      }





      if ( ( loader->load_flags & ( 1L << 0 ) ) == 0 )
      {
        loader->pp1.x = FT_MulFix_arm( (FT_Int32)(loader->pp1.x), (FT_Int32)(x_scale) );
        loader->pp2.x = FT_MulFix_arm( (FT_Int32)(loader->pp2.x), (FT_Int32)(x_scale) );


        loader->pp3.x = FT_MulFix_arm( (FT_Int32)(loader->pp3.x), (FT_Int32)(x_scale) );
        loader->pp3.y = FT_MulFix_arm( (FT_Int32)(loader->pp3.y), (FT_Int32)(y_scale) );
        loader->pp4.x = FT_MulFix_arm( (FT_Int32)(loader->pp4.x), (FT_Int32)(x_scale) );
        loader->pp4.y = FT_MulFix_arm( (FT_Int32)(loader->pp4.y), (FT_Int32)(y_scale) );
      }




      if ( loader->load_flags & ( 1L << 10 ) )
      {
        FT_GlyphLoader_Add( gloader );
        loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;

        goto Exit;
      }





      {
        FT_UInt n, num_base_points;
        FT_SubGlyph subglyph = ((void *)0);

        FT_UInt num_points = start_point;
        FT_UInt num_subglyphs = gloader->current.num_subglyphs;
        FT_UInt num_base_subgs = gloader->base.num_subglyphs;

        FT_Stream old_stream = loader->stream;
        FT_Int old_byte_len = loader->byte_len;


        FT_GlyphLoader_Add( gloader );


        for ( n = 0; n < num_subglyphs; n++ )
        {
          FT_Vector pp[4];






          subglyph = gloader->base.subglyphs + num_base_subgs + n;

          pp[0] = loader->pp1;
          pp[1] = loader->pp2;
          pp[2] = loader->pp3;
          pp[3] = loader->pp4;

          num_base_points = (FT_UInt)gloader->base.outline.n_points;

          error = load_truetype_glyph( loader,
                                       (FT_UInt)subglyph->index,
                                       recurse_count + 1,
                                       0 );
          if ( error )
            goto Exit;


          subglyph = gloader->base.subglyphs + num_base_subgs + n;


          if ( !( subglyph->flags & 0x0200 ) )
          {
            loader->pp1 = pp[0];
            loader->pp2 = pp[1];
            loader->pp3 = pp[2];
            loader->pp4 = pp[3];
          }

          num_points = (FT_UInt)gloader->base.outline.n_points;

          if ( num_points == num_base_points )
            continue;







          error = TT_Process_Composite_Component( loader,
                                                  subglyph,
                                                  start_point,
                                                  num_base_points );
          if ( error )
            goto Exit;
        }

        loader->stream = old_stream;
        loader->byte_len = old_byte_len;


        loader->ins_pos = ins_pos;
        if ( ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) &&

             subglyph->flags & 0x0100 &&

             num_points > start_point )
        {
          error = TT_Process_Composite_Glyph( loader,
                                              start_point,
                                              start_contour );
          if ( error )
            goto Exit;
        }
      }
    }
    else
    {

      error = TT_Err_Invalid_Outline;
      goto Exit;
    }





  Exit:

    if ( opened_frame )
      face->forget_glyph_frame( loader );



    if ( glyph_data_loaded )
      face->root.internal->incremental_interface->funcs->free_glyph_data(
        face->root.internal->incremental_interface->object,
        &glyph_data );



    return error;
  }


  static FT_Error
  compute_glyph_metrics( TT_Loader loader,
                         FT_UInt glyph_index )
  {
    TT_Face face = loader->face;

    TT_Driver driver = (TT_Driver)((FT_Face)(face))->driver;


    FT_BBox bbox;
    FT_Fixed y_scale;
    TT_GlyphSlot glyph = loader->glyph;
    TT_Size size = loader->size;


    y_scale = 0x10000L;
    if ( ( loader->load_flags & ( 1L << 0 ) ) == 0 )
      y_scale = size->root.metrics.y_scale;

    if ( glyph->format != FT_GLYPH_FORMAT_COMPOSITE )
      FT_Outline_Get_CBox( &glyph->outline, &bbox );
    else
      bbox = loader->bbox;



    glyph->linearHoriAdvance = loader->linear;

    glyph->metrics.horiBearingX = bbox.xMin;
    glyph->metrics.horiBearingY = bbox.yMax;
    glyph->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;



    if ( !face->postscript.isFixedPitch &&
         ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) &&
         !( loader->load_flags & ( 1L << 21 ) ) )
    {
      FT_Byte* widthp;


      widthp = tt_face_get_device_metrics( face,
                                           size->root.metrics.x_ppem,
                                           glyph_index );



      if ( driver->interpreter_version == 38 )
      {
        FT_Bool ignore_x_mode;


        ignore_x_mode = ( (FT_Bool)( ( (FT_Render_Mode)( ( (loader->load_flags) >> 16 ) & 15 ) ) != FT_RENDER_MODE_MONO ) )
                                                      ;

        if ( widthp &&
             ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
                !ignore_x_mode ||
                0 ) )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
      else



      {
        if ( widthp )
          glyph->metrics.horiAdvance = *widthp * 64;
      }
    }


    glyph->metrics.width = bbox.xMax - bbox.xMin;
    glyph->metrics.height = bbox.yMax - bbox.yMin;




    {
      FT_Pos top;
      FT_Pos advance;



      if ( face->vertical_info &&
           face->vertical.number_Of_VMetrics > 0 )
      {
        top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                   y_scale );

        if ( loader->pp3.y <= loader->pp4.y )
          advance = 0;
        else
          advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                          y_scale );
      }
      else
      {
        FT_Pos height;
# 2049 "../../../libs/freetype/src/truetype/ttgload.c"
        height = (FT_Short)FT_DivFix( bbox.yMax - bbox.yMin,
                                      y_scale );
        if ( face->os2.version != 0xFFFFU )
          advance = (FT_Pos)( face->os2.sTypoAscender -
                              face->os2.sTypoDescender );
        else
          advance = (FT_Pos)( face->horizontal.Ascender -
                              face->horizontal.Descender );

        top = ( advance - height ) / 2;
      }


      {
        FT_Incremental_InterfaceRec* incr;
        FT_Incremental_MetricsRec metrics;
        FT_Error error;


        incr = face->root.internal->incremental_interface;



        if ( incr && incr->funcs->get_glyph_metrics )
        {
          metrics.bearing_x = 0;
          metrics.bearing_y = top;
          metrics.advance = advance;

          error = incr->funcs->get_glyph_metrics( incr->object,
                                                  glyph_index,
                                                  1,
                                                  &metrics );
          if ( error )
            return error;

          top = metrics.bearing_y;
          advance = metrics.advance;
        }
      }





      glyph->linearVertAdvance = advance;


      if ( !( loader->load_flags & ( 1L << 0 ) ) )
      {
        top = FT_MulFix_arm( (FT_Int32)(top), (FT_Int32)(y_scale) );
        advance = FT_MulFix_arm( (FT_Int32)(advance), (FT_Int32)(y_scale) );
      }




      glyph->metrics.vertBearingX = glyph->metrics.horiBearingX -
                                      glyph->metrics.horiAdvance / 2;
      glyph->metrics.vertBearingY = top;
      glyph->metrics.vertAdvance = advance;
    }

    return 0;
  }




  static FT_Error
  load_sbit_image( TT_Size size,
                   TT_GlyphSlot glyph,
                   FT_UInt glyph_index,
                   FT_Int32 load_flags )
  {
    TT_Face face;
    SFNT_Service sfnt;
    FT_Stream stream;
    FT_Error error;
    TT_SBit_MetricsRec metrics;


    face = (TT_Face)glyph->face;
    sfnt = (SFNT_Service)face->sfnt;
    stream = face->root.stream;

    error = sfnt->load_sbit_image( face,
                                   size->strike_index,
                                   glyph_index,
                                   (FT_UInt)load_flags,
                                   stream,
                                   &glyph->bitmap,
                                   &metrics );
    if ( !error )
    {
      glyph->outline.n_points = 0;
      glyph->outline.n_contours = 0;

      glyph->metrics.width = (FT_Pos)metrics.width * 64;
      glyph->metrics.height = (FT_Pos)metrics.height * 64;

      glyph->metrics.horiBearingX = (FT_Pos)metrics.horiBearingX * 64;
      glyph->metrics.horiBearingY = (FT_Pos)metrics.horiBearingY * 64;
      glyph->metrics.horiAdvance = (FT_Pos)metrics.horiAdvance * 64;

      glyph->metrics.vertBearingX = (FT_Pos)metrics.vertBearingX * 64;
      glyph->metrics.vertBearingY = (FT_Pos)metrics.vertBearingY * 64;
      glyph->metrics.vertAdvance = (FT_Pos)metrics.vertAdvance * 64;

      glyph->format = FT_GLYPH_FORMAT_BITMAP;

      if ( load_flags & ( 1L << 4 ) )
      {
        glyph->bitmap_left = metrics.vertBearingX;
        glyph->bitmap_top = metrics.vertBearingY;
      }
      else
      {
        glyph->bitmap_left = metrics.horiBearingX;
        glyph->bitmap_top = metrics.horiBearingY;
      }
    }

    return error;
  }




  static FT_Error
  tt_loader_init( TT_Loader loader,
                  TT_Size size,
                  TT_GlyphSlot glyph,
                  FT_Int32 load_flags,
                  FT_Bool glyf_table_only )
  {
    FT_Error error;

    TT_Face face;
    FT_Stream stream;

    FT_Bool pedantic = ( (FT_Bool)( load_flags & ( 1L << 7 ) ) );



    face = (TT_Face)glyph->face;
    stream = face->root.stream;

    memset( loader, 0, (FT_Offset)(sizeof ( TT_LoaderRec )) );




    if ( ( ( load_flags & ( 1L << 1 ) ) == 0 ) && !glyf_table_only )
    {
      TT_ExecContext exec;
      FT_Bool grayscale;


      TT_Driver driver = (TT_Driver)((FT_Face)(face))->driver;

      FT_Bool subpixel_hinting = 0;
# 2223 "../../../libs/freetype/src/truetype/ttgload.c"
      FT_Bool reexecute = 0;


      if ( size->bytecode_ready < 0 || size->cvt_ready < 0 )
      {
        error = tt_size_ready_bytecode( size, pedantic );
        if ( error )
          return error;
      }
      else if ( size->bytecode_ready )
        return size->bytecode_ready;
      else if ( size->cvt_ready )
        return size->cvt_ready;


      exec = size->context;
      if ( !exec )
        return TT_Err_Could_Not_Find_Context;



      if ( driver->interpreter_version == 38 )
      {
        subpixel_hinting = ( (FT_Bool)( ( ( (FT_Render_Mode)( ( (load_flags) >> 16 ) & 15 ) ) != FT_RENDER_MODE_MONO ) && 1 ) )

                                                                            ;

        if ( subpixel_hinting )
          grayscale = 0;
        else if ( 0 )
        {
          grayscale = 1;
          subpixel_hinting = 0;
        }
        else
          grayscale = 0;

        if ( ( glyph->face->face_flags & ( 1L << 13 ) ) )
          subpixel_hinting = 0;

        exec->ignore_x_mode = subpixel_hinting || grayscale;
        exec->rasterizer_version = 38;
        if ( exec->sph_tweak_flags & 0x0002000UL )
          exec->rasterizer_version = 35;


        exec->compatible_widths = 0;
        exec->symmetrical_smoothing = 1;
        exec->bgr = 0;
        exec->vertical_lcd = 0;
        exec->subpixel_positioned = 1;
        exec->gray_cleartype = 0;
# 2296 "../../../libs/freetype/src/truetype/ttgload.c"
      }
      else



      {
        grayscale = ( (FT_Bool)( ( (FT_Render_Mode)( ( (load_flags) >> 16 ) & 15 ) ) != FT_RENDER_MODE_MONO ) )
                                                  ;
      }

      error = TT_Load_Context( exec, face, size );
      if ( error )
        return error;



      if ( driver->interpreter_version == 38 )
      {


        if ( subpixel_hinting != exec->subpixel_hinting )
        {
          do { } while ( 0 )
                                                       ;

          exec->subpixel_hinting = subpixel_hinting;
          reexecute = 1;
        }



        if ( grayscale != exec->grayscale )
        {
          do { } while ( 0 )
                                                       ;

          exec->grayscale = grayscale;
          reexecute = 1;
        }
      }
      else



      {


        if ( grayscale != exec->grayscale )
        {
          do { } while ( 0 )
                                                       ;

          exec->grayscale = grayscale;
          reexecute = 1;
        }
      }

      if ( reexecute )
      {
        FT_UInt i;


        for ( i = 0; i < size->cvt_size; i++ )
          size->cvt[i] = FT_MulFix_arm( (FT_Int32)(face->cvt[i]), (FT_Int32)(size->ttmetrics.scale) );
        error = tt_size_run_prep( size, pedantic );
        if ( error )
          return error;
      }


      if ( exec->GS.instruct_control & 1 )
        load_flags |= ( 1L << 1 );


      if ( exec->GS.instruct_control & 2 )
        exec->GS = tt_default_graphics_state;




      if ( exec->GS.instruct_control & 4 )
        exec->ignore_x_mode = 0;


      exec->pedantic_hinting = ( (FT_Bool)( load_flags & ( 1L << 7 ) ) );
      loader->exec = exec;
      loader->instructions = exec->glyphIns;
    }
# 2393 "../../../libs/freetype/src/truetype/ttgload.c"
    if ( face->root.internal->incremental_interface )
      loader->glyf_offset = 0;
    else



    {
      error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'l' << 16 ) | ( (FT_ULong)'y' << 8 ) | (FT_ULong)'f' ), stream, 0 );

      if ( ( ( (error) & 0xFF ) == ( (TT_Err_Table_Missing) & 0xFF ) ) )
        loader->glyf_offset = 0;
      else if ( error )
      {
        do { } while ( 0 );
        return error;
      }
      else
        loader->glyf_offset = FT_Stream_Pos( stream );
    }


    if ( !glyf_table_only )
    {
      FT_GlyphLoader gloader = glyph->internal->loader;


      FT_GlyphLoader_Rewind( gloader );
      loader->gloader = gloader;
    }

    loader->load_flags = (FT_ULong)load_flags;

    loader->face = face;
    loader->size = size;
    loader->glyph = (FT_GlyphSlot)glyph;
    loader->stream = stream;

    loader->composites.head = ((void *)0);
    loader->composites.tail = ((void *)0);

    return FT_Err_Ok;
  }


  static void
  tt_loader_done( TT_Loader loader )
  {
    FT_List_Finalize( &loader->composites,
                      ((void *)0),
                      loader->face->root.memory,
                      ((void *)0) );
  }
# 2474 "../../../libs/freetype/src/truetype/ttgload.c"
  static FT_Error
  TT_Load_Glyph( TT_Size size,
                 TT_GlyphSlot glyph,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags )
  {
    FT_Error error;
    TT_LoaderRec loader;


    do { } while ( 0 );







    if ( size->strike_index != 0xFFFFFFFFUL &&
         ( load_flags & ( 1L << 3 ) ) == 0 )
    {
      error = load_sbit_image( size, glyph, glyph_index, load_flags );
      if ( !error )
      {
        if ( ( glyph->face->face_flags & ( 1L << 0 ) ) )
        {

          (void)tt_loader_init( &loader, size, glyph, load_flags, 1 );
          (void)load_truetype_glyph( &loader, glyph_index, 0, 1 );
          tt_loader_done( &loader );
          glyph->linearHoriAdvance = loader.linear;
          glyph->linearVertAdvance = loader.vadvance;



          if ( !glyph->metrics.horiAdvance && glyph->linearHoriAdvance )
            glyph->metrics.horiAdvance =
              FT_MulFix_arm( (FT_Int32)(glyph->linearHoriAdvance), (FT_Int32)(size->root.metrics.x_scale) )
                                                     ;
          if ( !glyph->metrics.vertAdvance && glyph->linearVertAdvance )
            glyph->metrics.vertAdvance =
              FT_MulFix_arm( (FT_Int32)(glyph->linearVertAdvance), (FT_Int32)(size->root.metrics.y_scale) )
                                                     ;
        }

        return FT_Err_Ok;
      }
    }




    if ( !( load_flags & ( 1L << 0 ) ) && !size->ttmetrics.valid )
      return TT_Err_Invalid_Size_Handle;

    if ( load_flags & ( 1L << 14 ) )
      return TT_Err_Invalid_Argument;

    error = tt_loader_init( &loader, size, glyph, load_flags, 0 );
    if ( error )
      return error;

    glyph->format = FT_GLYPH_FORMAT_OUTLINE;
    glyph->num_subglyphs = 0;
    glyph->outline.flags = 0;


    error = load_truetype_glyph( &loader, glyph_index, 0, 0 );
    if ( !error )
    {
      if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
      {
        glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
        glyph->subglyphs = loader.gloader->base.subglyphs;
      }
      else
      {
        glyph->outline = loader.gloader->base.outline;
        glyph->outline.flags &= ~0x200;





        if ( loader.pp1.x )
          FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
      }



      if ( ( ( load_flags & ( 1L << 1 ) ) == 0 ) )
      {
        if ( loader.exec->GS.scan_control )
        {

          switch ( loader.exec->GS.scan_type )
          {
          case 0:
            glyph->outline.flags |= 0x20;
            break;
          case 1:

            break;
          case 4:
            glyph->outline.flags |= 0x10 |
                                    0x20;
            break;
          case 5:
            glyph->outline.flags |= 0x10;
            break;

          default:
            glyph->outline.flags |= 0x8;
            break;
          }
        }
        else
          glyph->outline.flags |= 0x8;
      }



      error = compute_glyph_metrics( &loader, glyph_index );
    }

    tt_loader_done( &loader );





    if ( !( load_flags & ( 1L << 0 ) ) &&
         size->root.metrics.y_ppem < 24 )
      glyph->outline.flags |= 0x100;

    return error;
  }
# 26 "../../../libs/freetype/src/truetype/truetype.c" 2
# 1 "../../../libs/freetype/src/truetype/ttobjs.c" 1
# 73 "../../../libs/freetype/src/truetype/ttobjs.c"
  static void
  tt_glyphzone_done( TT_GlyphZone zone )
  {
    FT_Memory memory = zone->memory;


    if ( memory )
    {
      do { ft_mem_free( memory, (zone->contours) ); (zone->contours) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->tags) ); (zone->tags) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->cur) ); (zone->cur) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->org) ); (zone->org) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (zone->orus) ); (zone->orus) = ((void *)0); } while ( 0 );

      zone->max_points = zone->n_points = 0;
      zone->max_contours = zone->n_contours = 0;
      zone->memory = ((void *)0);
    }
  }
# 115 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_glyphzone_new( FT_Memory memory,
                    FT_UShort maxPoints,
                    FT_Short maxContours,
                    TT_GlyphZone zone )
  {
    FT_Error error;


    memset( zone, 0, (FT_Offset)(sizeof ( *zone )) );
    zone->memory = memory;

    if ( ( ((zone->org) = (ft_mem_realloc( memory, sizeof ( *(zone->org) ), 0, (FT_Long)(maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->cur) = (ft_mem_realloc( memory, sizeof ( *(zone->cur) ), 0, (FT_Long)(maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->orus) = (ft_mem_realloc( memory, sizeof ( *(zone->orus) ), 0, (FT_Long)(maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->tags) = (ft_mem_realloc( memory, sizeof ( *(zone->tags) ), 0, (FT_Long)(maxPoints), ((void *)0), &error ))), error != 0 ) ||
         ( ((zone->contours) = (ft_mem_realloc( memory, sizeof ( *(zone->contours) ), 0, (FT_Long)(maxContours), ((void *)0), &error ))), error != 0 ) )
    {
      tt_glyphzone_done( zone );
    }
    else
    {
      zone->max_points = maxPoints;
      zone->max_contours = maxContours;
    }

    return error;
  }






  static FT_Bool
  tt_check_trickyness_family( FT_String* name )
  {




    static const char trick_names[9]
                                 [19 + 1] =
    {
      "DFKaiSho-SB",
      "DFKaiShu",
      "DFKai-SB",
      "HuaTianKaiTi?",
      "HuaTianSongTi?",
      "Ming(for ISO10646)",
      "MingLiU",
      "PMingLiU",
      "MingLi43",
    };

    int nn;


    for ( nn = 0; nn < 9; nn++ )
      if ( strstr( name, trick_names[nn] ) )
        return 1;

    return 0;
  }
# 188 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_UInt32
  tt_synth_sfnt_checksum( FT_Stream stream,
                          FT_ULong length )
  {
    FT_Error error;
    FT_UInt32 checksum = 0;
    FT_UInt i;


    if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(length) ))) ) != 0 ) )
      return 0;

    for ( ; length > 3; length -= 4 )
      checksum += (FT_UInt32)( (FT_ULong)FT_Stream_GetULong( stream ) );

    for ( i = 3; length > 0; length--, i-- )
      checksum += (FT_UInt32)( (FT_Byte)FT_Stream_GetChar( stream ) ) << ( i * 8 );

    (FT_Stream_ExitFrame( stream ));

    return checksum;
  }




  static FT_ULong
  tt_get_sfnt_checksum( TT_Face face,
                        FT_UShort i )
  {





    if ( !face->goto_table )
      return 0;

    if ( face->goto_table( face,
                           face->dir_tables[i].Tag,
                           face->root.stream,
                           ((void *)0) ) )
      return 0;

    return (FT_ULong)tt_synth_sfnt_checksum( face->root.stream,
                                             face->dir_tables[i].Length );
  }


  typedef struct tt_sfnt_id_rec_
  {
    FT_ULong CheckSum;
    FT_ULong Length;

  } tt_sfnt_id_rec;


  static FT_Bool
  tt_check_trickyness_sfnt_ids( TT_Face face )
  {



    static const tt_sfnt_id_rec sfnt_id[17]
                                       [3] = {





      {
        { 0x05BCF058UL, 0x000002E4UL },
        { 0x28233BF1UL, 0x000087C4UL },
        { 0xA344A1EAUL, 0x000001E1UL }
      },
      {
        { 0x05BCF058UL, 0x000002E4UL },
        { 0x28233BF1UL, 0x000087C4UL },
        { 0xA344A1EBUL, 0x000001E1UL }
      },
      {
        { 0x11E5EAD4UL, 0x00000350UL },
        { 0x5A30CA3BUL, 0x00009063UL },
        { 0x13A42602UL, 0x0000007EUL }
      },
      {
        { 0xFFFBFFFCUL, 0x00000008UL },
        { 0x9C9E48B8UL, 0x0000BEA2UL },
        { 0x70020112UL, 0x00000008UL }
      },
      {
        { 0xFFFBFFFCUL, 0x00000008UL },
        { 0x0A5A0483UL, 0x00017C39UL },
        { 0x70020112UL, 0x00000008UL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x40C92555UL, 0x000000E5UL },
        { 0xA39B58E3UL, 0x0000117CUL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x33C41652UL, 0x000000E5UL },
        { 0x26D6C52AUL, 0x00000F6AUL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x6DB1651DUL, 0x0000019DUL },
        { 0x6C6E4B03UL, 0x00002492UL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x40C92555UL, 0x000000E5UL },
        { 0xDE51FAD0UL, 0x0000117CUL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x85E47664UL, 0x000000E5UL },
        { 0xA6C62831UL, 0x00001CAAUL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x2D891CFDUL, 0x0000019DUL },
        { 0xA0604633UL, 0x00001DE8UL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x40AA774CUL, 0x000001CBUL },
        { 0x9B5CAA96UL, 0x00001F9AUL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x0D3DE9CBUL, 0x00000141UL },
        { 0xD4127766UL, 0x00002280UL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x4A692698UL, 0x000001F0UL },
        { 0x340D4346UL, 0x00001FCAUL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0xCD34C604UL, 0x00000166UL },
        { 0x6CF31046UL, 0x000022B0UL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0x5DA75315UL, 0x0000019DUL },
        { 0x40745A5FUL, 0x000022E0UL }
      },
      {
        { 0x00000000UL, 0x00000000UL },
        { 0xF055FC48UL, 0x000001C2UL },
        { 0x3900DED3UL, 0x00001E18UL }
      }
    };

    FT_ULong checksum;
    int num_matched_ids[17];
    FT_Bool has_cvt, has_fpgm, has_prep;
    FT_UShort i;
    int j, k;


    memset( num_matched_ids, 0, (FT_Offset)(sizeof ( int ) * 17) )
                                                           ;
    has_cvt = 0;
    has_fpgm = 0;
    has_prep = 0;

    for ( i = 0; i < face->num_tables; i++ )
    {
      checksum = 0;

      switch( face->dir_tables[i].Tag )
      {
      case (FT_Tag) ( ( (FT_ULong)'c' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'t' << 8 ) | (FT_ULong)' ' ):
        k = 0;
        has_cvt = 1;
        break;

      case (FT_Tag) ( ( (FT_ULong)'f' << 24 ) | ( (FT_ULong)'p' << 16 ) | ( (FT_ULong)'g' << 8 ) | (FT_ULong)'m' ):
        k = 1;
        has_fpgm = 1;
        break;

      case (FT_Tag) ( ( (FT_ULong)'p' << 24 ) | ( (FT_ULong)'r' << 16 ) | ( (FT_ULong)'e' << 8 ) | (FT_ULong)'p' ):
        k = 2;
        has_prep = 1;
        break;

      default:
        continue;
      }

      for ( j = 0; j < 17; j++ )
        if ( face->dir_tables[i].Length == sfnt_id[j][k].Length )
        {
          if ( !checksum )
            checksum = tt_get_sfnt_checksum( face, i );

          if ( sfnt_id[j][k].CheckSum == checksum )
            num_matched_ids[j]++;

          if ( num_matched_ids[j] == 3 )
            return 1;
        }
    }

    for ( j = 0; j < 17; j++ )
    {
      if ( !has_cvt && !sfnt_id[j][0].Length )
        num_matched_ids[j] ++;
      if ( !has_fpgm && !sfnt_id[j][1].Length )
        num_matched_ids[j] ++;
      if ( !has_prep && !sfnt_id[j][2].Length )
        num_matched_ids[j] ++;
      if ( num_matched_ids[j] == 3 )
        return 1;
    }

    return 0;
  }


  static FT_Bool
  tt_check_trickyness( FT_Face face )
  {
    if ( !face )
      return 0;


    if ( face->family_name &&
         tt_check_trickyness_family( face->family_name ) )
      return 1;




    if ( tt_check_trickyness_sfnt_ids( (TT_Face)face ) )
      return 1;

    return 0;
  }



  static FT_Bool
  tt_check_single_notdef( FT_Face ttface )
  {
    FT_Bool result = 0;

    TT_Face face = (TT_Face)ttface;
    FT_UInt asize;
    FT_ULong i;
    FT_ULong glyph_index = 0;
    FT_UInt count = 0;


    for( i = 0; i < face->num_locations; i++ )
    {
      tt_face_get_location( face, i, &asize );
      if ( asize > 0 )
      {
        count += 1;
        if ( count > 1 )
          break;
        glyph_index = i;
      }
    }


    if ( count == 1 )
    {
      if ( glyph_index == 0 )
        result = 1;
      else
      {

        FT_Error error;
        char buf[8];


        error = FT_Get_Glyph_Name( ttface, glyph_index, buf, 8 );
        if ( !error &&
             buf[0] == '.' && !strncmp( buf, ".notdef", 8 ) )
          result = 1;
      }
    }

    return result;
  }
# 508 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_face_init( FT_Stream stream,
                FT_Face ttface,
                FT_Int face_index,
                FT_Int num_params,
                FT_Parameter* params )
  {
    FT_Error error;
    FT_Library library;
    SFNT_Service sfnt;
    TT_Face face = (TT_Face)ttface;


    do { } while ( 0 );

    library = ttface->driver->root.library;

    sfnt = (SFNT_Service)FT_Get_Module_Interface( library, "sfnt" );
    if ( !sfnt )
    {
      do { } while ( 0 );
      error = TT_Err_Missing_Module;
      goto Exit;
    }


    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(0) )) ) != 0 ) )
      goto Exit;


    error = sfnt->init_face( stream, face, face_index, num_params, params );


    stream = face->root.stream;

    if ( error )
      goto Exit;




    if ( face->format_tag != 0x00010000L &&
         face->format_tag != 0x00020000L &&
         face->format_tag != (FT_Tag) ( ( (FT_ULong)'t' << 24 ) | ( (FT_ULong)'r' << 16 ) | ( (FT_ULong)'u' << 8 ) | (FT_ULong)'e' ) )
    {
      do { } while ( 0 );
      goto Bad_Format;
    }


    ttface->face_flags |= ( 1L << 11 );



    if ( face_index < 0 )
      return FT_Err_Ok;


    error = sfnt->load_face( stream, face, face_index, num_params, params );
    if ( error )
      goto Exit;

    if ( tt_check_trickyness( ttface ) )
      ttface->face_flags |= ( 1L << 13 );

    error = tt_face_load_hdmx( face, stream );
    if ( error )
      goto Exit;

    if ( ( ttface->face_flags & ( 1L << 0 ) ) )
    {



      if ( !ttface->internal->incremental_interface )
        error = tt_face_load_loca( face, stream );
      if ( !error )
        error = tt_face_load_cvt( face, stream );
      if ( !error )
        error = tt_face_load_fpgm( face, stream );
      if ( !error )
        error = tt_face_load_prep( face, stream );


      if ( !ttface->internal->incremental_interface &&
           ttface->num_fixed_sizes &&
           face->glyph_locations &&
           tt_check_single_notdef( ttface ) )
      {
        do { } while ( 0 )


                                                             ;

        ttface->face_flags &= ~( 1L << 0 );
      }
# 631 "../../../libs/freetype/src/truetype/ttobjs.c"
    }



    {
      FT_Int instance_index = face_index >> 16;


      if ( ( ttface->face_flags & ( 1L << 8 ) ) &&
           instance_index > 0 )
      {
        error = TT_Get_MM_Var( face, ((void *)0) );
        if ( error )
          goto Exit;

        if ( face->blend->mmvar->namedstyle )
        {
          FT_Memory memory = ttface->memory;

          FT_Var_Named_Style* named_style;
          FT_String* style_name;



          named_style = face->blend->mmvar->namedstyle + instance_index - 1;
          error = sfnt->get_name( face,
                                  (FT_UShort)named_style->strid,
                                  &style_name );
          if ( error )
            goto Exit;


          if ( face->root.style_name )
            do { ft_mem_free( memory, (face->root.style_name) ); (face->root.style_name) = ((void *)0); } while ( 0 );
          face->root.style_name = style_name;


          error = TT_Set_Var_Design( face,
                                     face->blend->mmvar->num_axis,
                                     named_style->coords );
          if ( error )
            goto Exit;
        }
      }
    }
# 703 "../../../libs/freetype/src/truetype/ttobjs.c"
    TT_Init_Glyph_Loading( face );

  Exit:
    return error;

  Bad_Format:
    error = TT_Err_Unknown_File_Format;
    goto Exit;
  }
# 725 "../../../libs/freetype/src/truetype/ttobjs.c"
  static void
  tt_face_done( FT_Face ttface )
  {
    TT_Face face = (TT_Face)ttface;
    FT_Memory memory;
    FT_Stream stream;
    SFNT_Service sfnt;


    if ( !face )
      return;

    memory = ttface->memory;
    stream = ttface->stream;
    sfnt = (SFNT_Service)face->sfnt;


    if ( face->extra.finalizer )
      face->extra.finalizer( face->extra.data );

    if ( sfnt )
      sfnt->done_face( face );


    tt_face_done_loca( face );

    tt_face_free_hdmx( face );


    do { ft_mem_free( memory, (face->cvt) ); (face->cvt) = ((void *)0); } while ( 0 );
    face->cvt_size = 0;


    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->font_program) ));
    (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(face->cvt_program) ));
    face->font_program_size = 0;
    face->cvt_program_size = 0;


    tt_done_blend( memory, face->blend );
    face->blend = ((void *)0);

  }
# 794 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_run_fpgm( TT_Size size,
                    FT_Bool pedantic )
  {
    TT_Face face = (TT_Face)size->root.face;
    TT_ExecContext exec;
    FT_Error error;


    exec = size->context;

    error = TT_Load_Context( exec, face, size );
    if ( error )
      return error;

    exec->callTop = 0;
    exec->top = 0;

    exec->period = 64;
    exec->phase = 0;
    exec->threshold = 0;

    exec->instruction_trap = 0;
    exec->F_dot_P = 0x4000L;

    exec->pedantic_hinting = pedantic;

    {
      FT_Size_Metrics* metrics = &exec->metrics;
      TT_Size_Metrics* tt_metrics = &exec->tt_metrics;


      metrics->x_ppem = 0;
      metrics->y_ppem = 0;
      metrics->x_scale = 0;
      metrics->y_scale = 0;

      tt_metrics->ppem = 0;
      tt_metrics->scale = 0;
      tt_metrics->ratio = 0x10000L;
    }


    TT_Set_CodeRange( exec,
                      tt_coderange_font,
                      face->font_program,
                      (FT_Long)face->font_program_size );


    TT_Clear_CodeRange( exec, tt_coderange_cvt );
    TT_Clear_CodeRange( exec, tt_coderange_glyph );

    if ( face->font_program_size > 0 )
    {
      TT_Goto_CodeRange( exec, tt_coderange_font, 0 );

      do { } while ( 0 );
      error = face->interpreter( exec );
    }
    else
      error = FT_Err_Ok;

    size->bytecode_ready = error;

    if ( !error )
      TT_Save_Context( exec, size );

    return error;
  }
# 881 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_run_prep( TT_Size size,
                    FT_Bool pedantic )
  {
    TT_Face face = (TT_Face)size->root.face;
    TT_ExecContext exec;
    FT_Error error;


    exec = size->context;

    error = TT_Load_Context( exec, face, size );
    if ( error )
      return error;

    exec->callTop = 0;
    exec->top = 0;

    exec->instruction_trap = 0;

    exec->pedantic_hinting = pedantic;

    TT_Set_CodeRange( exec,
                      tt_coderange_cvt,
                      face->cvt_program,
                      (FT_Long)face->cvt_program_size );

    TT_Clear_CodeRange( exec, tt_coderange_glyph );

    if ( face->cvt_program_size > 0 )
    {
      TT_Goto_CodeRange( exec, tt_coderange_cvt, 0 );

      do { } while ( 0 );

      error = face->interpreter( exec );
    }
    else
      error = FT_Err_Ok;

    size->cvt_ready = error;




    exec->GS.dualVector.x = 0x4000;
    exec->GS.dualVector.y = 0;
    exec->GS.projVector.x = 0x4000;
    exec->GS.projVector.y = 0x0;
    exec->GS.freeVector.x = 0x4000;
    exec->GS.freeVector.y = 0x0;

    exec->GS.rp0 = 0;
    exec->GS.rp1 = 0;
    exec->GS.rp2 = 0;

    exec->GS.gep0 = 1;
    exec->GS.gep1 = 1;
    exec->GS.gep2 = 1;

    exec->GS.loop = 1;


    size->GS = exec->GS;

    TT_Save_Context( exec, size );

    return error;
  }


  static void
  tt_size_done_bytecode( FT_Size ftsize )
  {
    TT_Size size = (TT_Size)ftsize;
    TT_Face face = (TT_Face)ftsize->face;
    FT_Memory memory = face->root.memory;

    if ( size->context )
    {
      TT_Done_Context( size->context );
      size->context = ((void *)0);
    }

    do { ft_mem_free( memory, (size->cvt) ); (size->cvt) = ((void *)0); } while ( 0 );
    size->cvt_size = 0;


    do { ft_mem_free( memory, (size->storage) ); (size->storage) = ((void *)0); } while ( 0 );
    size->storage_size = 0;


    tt_glyphzone_done( &size->twilight );

    do { ft_mem_free( memory, (size->function_defs) ); (size->function_defs) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (size->instruction_defs) ); (size->instruction_defs) = ((void *)0); } while ( 0 );

    size->num_function_defs = 0;
    size->max_function_defs = 0;
    size->num_instruction_defs = 0;
    size->max_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins = 0;

    size->bytecode_ready = -1;
    size->cvt_ready = -1;
  }




  static FT_Error
  tt_size_init_bytecode( FT_Size ftsize,
                         FT_Bool pedantic )
  {
    FT_Error error;
    TT_Size size = (TT_Size)ftsize;
    TT_Face face = (TT_Face)ftsize->face;
    FT_Memory memory = face->root.memory;

    FT_UShort n_twilight;
    TT_MaxProfile* maxp = &face->max_profile;



    do { ft_mem_free( memory, (size->function_defs) ); (size->function_defs) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (size->instruction_defs) ); (size->instruction_defs) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (size->cvt) ); (size->cvt) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (size->storage) ); (size->storage) = ((void *)0); } while ( 0 );

    if ( size->context )
      TT_Done_Context( size->context );
    tt_glyphzone_done( &size->twilight );

    size->bytecode_ready = -1;
    size->cvt_ready = -1;

    size->context = TT_New_Context( (TT_Driver)face->root.driver );

    size->max_function_defs = maxp->maxFunctionDefs;
    size->max_instruction_defs = maxp->maxInstructionDefs;

    size->num_function_defs = 0;
    size->num_instruction_defs = 0;

    size->max_func = 0;
    size->max_ins = 0;

    size->cvt_size = face->cvt_size;
    size->storage_size = maxp->maxStorage;


    {
      TT_Size_Metrics* metrics = &size->ttmetrics;


      metrics->rotated = 0;
      metrics->stretched = 0;


      metrics->compensations[0] = 0;
      metrics->compensations[1] = 0;
      metrics->compensations[2] = 0;
      metrics->compensations[3] = 0;
    }


    if ( ( ((size->function_defs) = (ft_mem_realloc( memory, sizeof ( *(size->function_defs) ), 0, (FT_Long)(size->max_function_defs), ((void *)0), &error ))), error != 0 ) ||
         ( ((size->instruction_defs) = (ft_mem_realloc( memory, sizeof ( *(size->instruction_defs) ), 0, (FT_Long)(size->max_instruction_defs), ((void *)0), &error ))), error != 0 ) ||
         ( ((size->cvt) = (ft_mem_realloc( memory, sizeof ( *(size->cvt) ), 0, (FT_Long)(size->cvt_size), ((void *)0), &error ))), error != 0 ) ||
         ( ((size->storage) = (ft_mem_realloc( memory, sizeof ( *(size->storage) ), 0, (FT_Long)(size->storage_size), ((void *)0), &error ))), error != 0 ) )
      goto Exit;


    n_twilight = maxp->maxTwilightPoints;


    n_twilight += 4;

    error = tt_glyphzone_new( memory, n_twilight, 0, &size->twilight );
    if ( error )
      goto Exit;

    size->twilight.n_points = n_twilight;

    size->GS = tt_default_graphics_state;


    {
      FT_Library library = face->root.driver->root.library;


      face->interpreter = (TT_Interpreter)
                            library->debug_hooks[0];
      if ( !face->interpreter )
        face->interpreter = (TT_Interpreter)TT_RunIns;
    }
# 1088 "../../../libs/freetype/src/truetype/ttobjs.c"
    error = tt_size_run_fpgm( size, pedantic );
    return error;

  Exit:
    if ( error )
      tt_size_done_bytecode( ftsize );

    return error;
  }


  static FT_Error
  tt_size_ready_bytecode( TT_Size size,
                          FT_Bool pedantic )
  {
    FT_Error error = FT_Err_Ok;


    if ( size->bytecode_ready < 0 )
      error = tt_size_init_bytecode( (FT_Size)size, pedantic );

    if ( error || size->bytecode_ready )
      goto Exit;


    if ( size->cvt_ready < 0 )
    {
      FT_UInt i;
      TT_Face face = (TT_Face)size->root.face;




      for ( i = 0; i < size->cvt_size; i++ )
        size->cvt[i] = FT_MulFix_arm( (FT_Int32)(face->cvt[i]), (FT_Int32)(size->ttmetrics.scale) );


      for ( i = 0; i < (FT_UInt)size->twilight.n_points; i++ )
      {
        size->twilight.org[i].x = 0;
        size->twilight.org[i].y = 0;
        size->twilight.cur[i].x = 0;
        size->twilight.cur[i].y = 0;
      }


      for ( i = 0; i < (FT_UInt)size->storage_size; i++ )
        size->storage[i] = 0;

      size->GS = tt_default_graphics_state;

      error = tt_size_run_prep( size, pedantic );
    }

  Exit:
    return error;
  }
# 1163 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_init( FT_Size ttsize )
  {
    TT_Size size = (TT_Size)ttsize;
    FT_Error error = FT_Err_Ok;



    size->bytecode_ready = -1;
    size->cvt_ready = -1;


    size->ttmetrics.valid = 0;
    size->strike_index = 0xFFFFFFFFUL;

    return error;
  }
# 1193 "../../../libs/freetype/src/truetype/ttobjs.c"
  static void
  tt_size_done( FT_Size ttsize )
  {
    TT_Size size = (TT_Size)ttsize;



    tt_size_done_bytecode( ttsize );


    size->ttmetrics.valid = 0;
  }
# 1219 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_size_reset( TT_Size size )
  {
    TT_Face face;
    FT_Error error = FT_Err_Ok;
    FT_Size_Metrics* metrics;


    size->ttmetrics.valid = 0;

    face = (TT_Face)size->root.face;

    metrics = &size->metrics;


    *metrics = size->root.metrics;

    if ( metrics->x_ppem < 1 || metrics->y_ppem < 1 )
      return TT_Err_Invalid_PPem;





    if ( face->header.Flags & 8 )
    {
      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,
                                    face->root.units_per_EM );
      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,
                                    face->root.units_per_EM );

      metrics->ascender =
        ( ((FT_MulFix_arm( (FT_Int32)(face->root.ascender), (FT_Int32)(metrics->y_scale) )) + 32) & ~(__typeof__ ((FT_MulFix_arm( (FT_Int32)(face->root.ascender), (FT_Int32)(metrics->y_scale) )) + 32))63 );
      metrics->descender =
        ( ((FT_MulFix_arm( (FT_Int32)(face->root.descender), (FT_Int32)(metrics->y_scale) )) + 32) & ~(__typeof__ ((FT_MulFix_arm( (FT_Int32)(face->root.descender), (FT_Int32)(metrics->y_scale) )) + 32))63 );
      metrics->height =
        ( ((FT_MulFix_arm( (FT_Int32)(face->root.height), (FT_Int32)(metrics->y_scale) )) + 32) & ~(__typeof__ ((FT_MulFix_arm( (FT_Int32)(face->root.height), (FT_Int32)(metrics->y_scale) )) + 32))63 );
      metrics->max_advance =
        ( ((FT_MulFix_arm( (FT_Int32)(face->root.max_advance_width), (FT_Int32)(metrics->x_scale) )) + 32) & ~(__typeof__ ((FT_MulFix_arm( (FT_Int32)(face->root.max_advance_width), (FT_Int32)(metrics->x_scale) )) + 32))63 )
                                                     ;
    }


    if ( metrics->x_ppem >= metrics->y_ppem )
    {
      size->ttmetrics.scale = metrics->x_scale;
      size->ttmetrics.ppem = metrics->x_ppem;
      size->ttmetrics.x_ratio = 0x10000L;
      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,
                                           metrics->x_ppem );
    }
    else
    {
      size->ttmetrics.scale = metrics->y_scale;
      size->ttmetrics.ppem = metrics->y_ppem;
      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,
                                           metrics->y_ppem );
      size->ttmetrics.y_ratio = 0x10000L;
    }


    size->cvt_ready = -1;


    if ( !error )
      size->ttmetrics.valid = 1;

    return error;
  }
# 1304 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_driver_init( FT_Module ttdriver )
  {



    TT_Driver driver = (TT_Driver)ttdriver;


    driver->interpreter_version = 38;
# 1324 "../../../libs/freetype/src/truetype/ttobjs.c"
    return FT_Err_Ok;
  }
# 1339 "../../../libs/freetype/src/truetype/ttobjs.c"
  static void
  tt_driver_done( FT_Module ttdriver )
  {
    ( (ttdriver) = (ttdriver) );
  }
# 1360 "../../../libs/freetype/src/truetype/ttobjs.c"
  static FT_Error
  tt_slot_init( FT_GlyphSlot slot )
  {
    return FT_GlyphLoader_CreateExtra( slot->internal->loader );
  }
# 27 "../../../libs/freetype/src/truetype/truetype.c" 2


# 1 "../../../libs/freetype/src/truetype/ttinterp.c" 1
# 26 "../../../libs/freetype/src/truetype/ttinterp.c"
# 1 "../../../libs/freetype/include/freetype/fttrigon.h" 1
# 31 "../../../libs/freetype/include/freetype/fttrigon.h"

# 52 "../../../libs/freetype/include/freetype/fttrigon.h"
  typedef FT_Fixed FT_Angle;
# 123 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern FT_Fixed
  FT_Sin( FT_Angle angle );
# 147 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern FT_Fixed
  FT_Cos( FT_Angle angle );
# 167 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern FT_Fixed
  FT_Tan( FT_Angle angle );
# 191 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern FT_Angle
  FT_Atan2( FT_Fixed x,
            FT_Fixed y );
# 216 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern FT_Angle
  FT_Angle_Diff( FT_Angle angle1,
                 FT_Angle angle2 );
# 243 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern void
  FT_Vector_Unit( FT_Vector* vec,
                  FT_Angle angle );
# 265 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern void
  FT_Vector_Rotate( FT_Vector* vec,
                    FT_Angle angle );
# 287 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern FT_Fixed
  FT_Vector_Length( FT_Vector* vec );
# 311 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern void
  FT_Vector_Polarize( FT_Vector* vec,
                      FT_Fixed *length,
                      FT_Angle *angle );
# 337 "../../../libs/freetype/include/freetype/fttrigon.h"
  extern void
  FT_Vector_From_Polar( FT_Vector* vec,
                        FT_Fixed length,
                        FT_Angle angle );





# 27 "../../../libs/freetype/src/truetype/ttinterp.c" 2
# 70 "../../../libs/freetype/src/truetype/ttinterp.c"
  typedef void (*TInstruction_Function)( TT_ExecContext exc,
                                          FT_Long* args );
# 127 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  TT_Goto_CodeRange( TT_ExecContext exec,
                     FT_Int range,
                     FT_Long IP )
  {
    TT_CodeRange* coderange;


    do { } while ( 0 );

    coderange = &exec->codeRangeTable[range - 1];

    do { } while ( 0 );





    do { } while ( 0 );

    exec->code = coderange->base;
    exec->codeSize = coderange->size;
    exec->IP = IP;
    exec->curRange = range;
  }
# 172 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  TT_Set_CodeRange( TT_ExecContext exec,
                    FT_Int range,
                    void* base,
                    FT_Long length )
  {
    do { } while ( 0 );

    exec->codeRangeTable[range - 1].base = (FT_Byte*)base;
    exec->codeRangeTable[range - 1].size = length;
  }
# 199 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  TT_Clear_CodeRange( TT_ExecContext exec,
                      FT_Int range )
  {
    do { } while ( 0 );

    exec->codeRangeTable[range - 1].base = ((void *)0);
    exec->codeRangeTable[range - 1].size = 0;
  }
# 233 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  TT_Done_Context( TT_ExecContext exec )
  {
    FT_Memory memory = exec->memory;



    exec->maxPoints = 0;
    exec->maxContours = 0;


    do { ft_mem_free( memory, (exec->stack) ); (exec->stack) = ((void *)0); } while ( 0 );
    exec->stackSize = 0;


    do { ft_mem_free( memory, (exec->callStack) ); (exec->callStack) = ((void *)0); } while ( 0 );
    exec->callSize = 0;
    exec->callTop = 0;


    do { ft_mem_free( memory, (exec->glyphIns) ); (exec->glyphIns) = ((void *)0); } while ( 0 );
    exec->glyphSize = 0;

    exec->size = ((void *)0);
    exec->face = ((void *)0);

    do { ft_mem_free( memory, (exec) ); (exec) = ((void *)0); } while ( 0 );
  }
# 280 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Error
  Init_Context( TT_ExecContext exec,
                FT_Memory memory )
  {
    FT_Error error;


    do { } while ( 0 );

    exec->memory = memory;
    exec->callSize = 32;

    if ( ( ((exec->callStack) = (ft_mem_realloc( memory, sizeof ( *(exec->callStack) ), 0, (FT_Long)(exec->callSize), ((void *)0), &error ))), error != 0 ) )
      goto Fail_Memory;



    exec->maxPoints = 0;
    exec->maxContours = 0;

    exec->stackSize = 0;
    exec->glyphSize = 0;

    exec->stack = ((void *)0);
    exec->glyphIns = ((void *)0);

    exec->face = ((void *)0);
    exec->size = ((void *)0);

    return FT_Err_Ok;

  Fail_Memory:
    do { } while ( 0 );
    TT_Done_Context( exec );

    return error;
 }
# 343 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Error
  Update_Max( FT_Memory memory,
              FT_ULong* size,
              FT_ULong multiplier,
              void* _pbuff,
              FT_ULong new_max )
  {
    FT_Error error;
    void** pbuff = (void**)_pbuff;


    if ( *size < new_max )
    {
      if ( ( ((*pbuff) = (ft_mem_realloc( memory, 1, (FT_Long)(*size * multiplier), (FT_Long)(new_max * multiplier), (*pbuff), &error ))), error != 0 ) )
        return error;
      *size = new_max;
    }

    return FT_Err_Ok;
  }
# 387 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Load_Context( TT_ExecContext exec,
                   TT_Face face,
                   TT_Size size )
  {
    FT_Int i;
    FT_ULong tmp;
    TT_MaxProfile* maxp;
    FT_Error error;


    exec->face = face;
    maxp = &face->max_profile;
    exec->size = size;

    if ( size )
    {
      exec->numFDefs = size->num_function_defs;
      exec->maxFDefs = size->max_function_defs;
      exec->numIDefs = size->num_instruction_defs;
      exec->maxIDefs = size->max_instruction_defs;
      exec->FDefs = size->function_defs;
      exec->IDefs = size->instruction_defs;
      exec->tt_metrics = size->ttmetrics;
      exec->metrics = size->metrics;

      exec->maxFunc = size->max_func;
      exec->maxIns = size->max_ins;

      for ( i = 0; i < 3; i++ )
        exec->codeRangeTable[i] = size->codeRangeTable[i];


      exec->GS = size->GS;

      exec->cvtSize = size->cvt_size;
      exec->cvt = size->cvt;

      exec->storeSize = size->storage_size;
      exec->storage = size->storage;

      exec->twilight = size->twilight;



      memset( &exec->zp0, 0, sizeof ( exec->zp0 ) );
      exec->zp1 = exec->zp0;
      exec->zp2 = exec->zp0;
    }



    tmp = (FT_ULong)exec->stackSize;
    error = Update_Max( exec->memory,
                        &tmp,
                        sizeof ( FT_F26Dot6 ),
                        (void*)&exec->stack,
                        maxp->maxStackElements + 32 );
    exec->stackSize = (FT_Long)tmp;
    if ( error )
      return error;

    tmp = exec->glyphSize;
    error = Update_Max( exec->memory,
                        &tmp,
                        sizeof ( FT_Byte ),
                        (void*)&exec->glyphIns,
                        maxp->maxSizeOfInstructions );
    exec->glyphSize = (FT_UShort)tmp;
    if ( error )
      return error;

    exec->pts.n_points = 0;
    exec->pts.n_contours = 0;

    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;
    exec->zp0 = exec->pts;

    exec->instruction_trap = 0;

    return FT_Err_Ok;
  }
# 489 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  TT_Save_Context( TT_ExecContext exec,
                   TT_Size size )
  {
    FT_Int i;





    size->num_function_defs = exec->numFDefs;
    size->num_instruction_defs = exec->numIDefs;

    size->max_func = exec->maxFunc;
    size->max_ins = exec->maxIns;

    for ( i = 0; i < 3; i++ )
      size->codeRangeTable[i] = exec->codeRangeTable[i];
  }
# 531 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Error
  TT_Run_Context( TT_ExecContext exec )
  {
    TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );

    exec->zp0 = exec->pts;
    exec->zp1 = exec->pts;
    exec->zp2 = exec->pts;

    exec->GS.gep0 = 1;
    exec->GS.gep1 = 1;
    exec->GS.gep2 = 1;

    exec->GS.projVector.x = 0x4000;
    exec->GS.projVector.y = 0x0000;

    exec->GS.freeVector = exec->GS.projVector;
    exec->GS.dualVector = exec->GS.projVector;





    exec->GS.round_state = 1;
    exec->GS.loop = 1;



    exec->top = 0;
    exec->callTop = 0;

    return exec->face->interpreter( exec );
  }
# 573 "../../../libs/freetype/src/truetype/ttinterp.c"
  const TT_GraphicsState tt_default_graphics_state =
  {
    0, 0, 0,
    { 0x4000, 0 },
    { 0x4000, 0 },
    { 0x4000, 0 },





    1, 64, 1,
    1, 68, 0, 0, 9, 3,
    0, 0, 0, 1, 1, 1
  };




  extern TT_ExecContext
  TT_New_Context( TT_Driver driver )
  {
    FT_Memory memory;
    FT_Error error;

    TT_ExecContext exec = ((void *)0);


    if ( !driver )
      goto Fail;

    memory = driver->root.root.memory;


    if ( ( ((exec) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *(exec) )), &error ))), error != 0 ) )
      goto Fail;


    error = Init_Context( exec, memory );
    if ( error )
      goto Fail;

    return exec;

  Fail:
    return ((void *)0);
  }
# 644 "../../../libs/freetype/src/truetype/ttinterp.c"
  static
  const FT_Byte Pop_Push_Count[256] =
  {



                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 5 << 4 ) | 0 ),

                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 1 << 4 ) | 2 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 1 ),

                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 3 << 4 ) | 3 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 2 << 4 ) | 1 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),
                      ( ( 0 << 4 ) | 0 ),

                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 3 ),
                      ( ( 0 << 4 ) | 4 ),
                      ( ( 0 << 4 ) | 5 ),
                      ( ( 0 << 4 ) | 6 ),
                      ( ( 0 << 4 ) | 7 ),
                      ( ( 0 << 4 ) | 8 ),
                      ( ( 0 << 4 ) | 1 ),
                      ( ( 0 << 4 ) | 2 ),
                      ( ( 0 << 4 ) | 3 ),
                      ( ( 0 << 4 ) | 4 ),
                      ( ( 0 << 4 ) | 5 ),
                      ( ( 0 << 4 ) | 6 ),
                      ( ( 0 << 4 ) | 7 ),
                      ( ( 0 << 4 ) | 8 ),

                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),
                      ( ( 1 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),

                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 ),
                      ( ( 2 << 4 ) | 0 )
  };
# 1209 "../../../libs/freetype/src/truetype/ttinterp.c"
  static
  const FT_Char opcode_length[256] =
  {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

   -1,-2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 3, 4, 5, 6, 7, 8, 9, 3, 5, 7, 9, 11,13,15,17,

    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
  };
# 1243 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Int32
  TT_MulFix14_arm( FT_Int32 a,
                   FT_Int b )
  {
    FT_Int32 t, t2;
# 1265 "../../../libs/freetype/src/truetype/ttinterp.c"
    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"
      "mov    %0, %2, asr #31\n\t"



      "add    %0, %0, #0x2000\n\t"

      "adds   %1, %1, %0\n\t"
      "adc    %2, %2, #0\n\t"
      "mov    %0, %1, lsr #14\n\t"
      "orr    %0, %0, %2, lsl #18\n\t"
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );



    return a;
  }
# 1378 "../../../libs/freetype/src/truetype/ttinterp.c"
#pragma GCC diagnostic push

#pragma GCC diagnostic ignored "-Wlong-long"

  static __attribute__(( pure )) FT_Int32
  TT_DotFix14_long_long( FT_Int32 ax,
                         FT_Int32 ay,
                         FT_Int bx,
                         FT_Int by )
  {



    long long temp1 = (long long)ax * bx;
    long long temp2 = (long long)ay * by;


    temp1 += temp2;
    temp2 = temp1 >> 63;
    temp1 += 0x2000 + temp2;

    return (FT_Int32)( temp1 >> 14 );

  }


#pragma GCC diagnostic pop
# 1468 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Long
  Current_Ratio( TT_ExecContext exc )
  {
    if ( !exc->tt_metrics.ratio )
    {
# 1483 "../../../libs/freetype/src/truetype/ttinterp.c"
      {
        if ( exc->GS.projVector.y == 0 )
          exc->tt_metrics.ratio = exc->tt_metrics.x_ratio;

        else if ( exc->GS.projVector.x == 0 )
          exc->tt_metrics.ratio = exc->tt_metrics.y_ratio;

        else
        {
          FT_F26Dot6 x, y;


          x = TT_MulFix14_arm( exc->tt_metrics.x_ratio,
                           exc->GS.projVector.x );
          y = TT_MulFix14_arm( exc->tt_metrics.y_ratio,
                           exc->GS.projVector.y );
          exc->tt_metrics.ratio = FT_Hypot( x, y );
        }
      }
    }
    return exc->tt_metrics.ratio;
  }


  static FT_Long
  Current_Ppem( TT_ExecContext exc )
  {
    return exc->tt_metrics.ppem;
  }


  static FT_Long
  Current_Ppem_Stretched( TT_ExecContext exc )
  {
    return FT_MulFix_arm( (FT_Int32)(exc->tt_metrics.ppem), (FT_Int32)(Current_Ratio( exc )) );
  }
# 1528 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Read_CVT( TT_ExecContext exc,
            FT_ULong idx )
  {
    return exc->cvt[idx];
  }


  static FT_F26Dot6
  Read_CVT_Stretched( TT_ExecContext exc,
                      FT_ULong idx )
  {
    return FT_MulFix_arm( (FT_Int32)(exc->cvt[idx]), (FT_Int32)(Current_Ratio( exc )) );
  }


  static void
  Write_CVT( TT_ExecContext exc,
             FT_ULong idx,
             FT_F26Dot6 value )
  {
    exc->cvt[idx] = value;
  }


  static void
  Write_CVT_Stretched( TT_ExecContext exc,
                       FT_ULong idx,
                       FT_F26Dot6 value )
  {
    exc->cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );
  }


  static void
  Move_CVT( TT_ExecContext exc,
            FT_ULong idx,
            FT_F26Dot6 value )
  {
    exc->cvt[idx] += value;
  }


  static void
  Move_CVT_Stretched( TT_ExecContext exc,
                      FT_ULong idx,
                      FT_F26Dot6 value )
  {
    exc->cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );
  }
# 1595 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Short
  GetShortIns( TT_ExecContext exc )
  {

    exc->IP += 2;
    return (FT_Short)( ( exc->code[exc->IP - 2] << 8 ) +
                         exc->code[exc->IP - 1] );
  }
# 1621 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  Ins_Goto_CodeRange( TT_ExecContext exc,
                      FT_Int aRange,
                      FT_Long aIP )
  {
    TT_CodeRange* range;


    if ( aRange < 1 || aRange > 3 )
    {
      exc->error = TT_Err_Bad_Argument;
      return 1;
    }

    range = &exc->codeRangeTable[aRange - 1];

    if ( range->base == ((void *)0) )
    {
      exc->error = TT_Err_Invalid_CodeRange;
      return 1;
    }





    if ( aIP > range->size )
    {
      exc->error = TT_Err_Code_Overflow;
      return 1;
    }

    exc->code = range->base;
    exc->codeSize = range->size;
    exc->IP = aIP;
    exc->curRange = aRange;

    return 0;
  }
# 1679 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move( TT_ExecContext exc,
               TT_GlyphZone zone,
               FT_UShort point,
               FT_F26Dot6 distance )
  {
    FT_F26Dot6 v;






    v = exc->GS.freeVector.x;

    if ( v != 0 )
    {

      if ( !( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) ||
           ( !exc->ignore_x_mode ||
             ( exc->sph_tweak_flags & 0x0000001UL ) ) )

        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );

      zone->tags[point] |= 8;
    }

    v = exc->GS.freeVector.y;

    if ( v != 0 )
    {
      zone->cur[point].y += FT_MulDiv( distance, v, exc->F_dot_P );

      zone->tags[point] |= 16;
    }
  }
# 1734 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move_Orig( TT_ExecContext exc,
                    TT_GlyphZone zone,
                    FT_UShort point,
                    FT_F26Dot6 distance )
  {
    FT_F26Dot6 v;






    v = exc->GS.freeVector.x;

    if ( v != 0 )
      zone->org[point].x += FT_MulDiv( distance, v, exc->F_dot_P );

    v = exc->GS.freeVector.y;

    if ( v != 0 )
      zone->org[point].y += FT_MulDiv( distance, v, exc->F_dot_P );
  }
# 1769 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move_X( TT_ExecContext exc,
                 TT_GlyphZone zone,
                 FT_UShort point,
                 FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );


    if ( !( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) ||
         !exc->ignore_x_mode )

      zone->cur[point].x += distance;

    zone->tags[point] |= 8;
  }


  static void
  Direct_Move_Y( TT_ExecContext exc,
                 TT_GlyphZone zone,
                 FT_UShort point,
                 FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->cur[point].y += distance;
    zone->tags[point] |= 16;
  }
# 1810 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Direct_Move_Orig_X( TT_ExecContext exc,
                      TT_GlyphZone zone,
                      FT_UShort point,
                      FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->org[point].x += distance;
  }


  static void
  Direct_Move_Orig_Y( TT_ExecContext exc,
                      TT_GlyphZone zone,
                      FT_UShort point,
                      FT_F26Dot6 distance )
  {
    ( (exc) = (exc) );

    zone->org[point].y += distance;
  }
# 1856 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_None( TT_ExecContext exc,
              FT_F26Dot6 distance,
              FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = distance + compensation;
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = distance - compensation;
      if ( val > 0 )
        val = 0;
    }
    return val;
  }
# 1898 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_To_Grid( TT_ExecContext exc,
                 FT_F26Dot6 distance,
                 FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = ( ((distance + compensation) + 32) & ~(__typeof__ ((distance + compensation) + 32))63 );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -( ((compensation - distance) + 32) & ~(__typeof__ ((compensation - distance) + 32))63 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 1941 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_To_Half_Grid( TT_ExecContext exc,
                      FT_F26Dot6 distance,
                      FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = ( (distance + compensation) & ~(__typeof__ (distance + compensation))63 ) + 32;
      if ( val < 0 )
        val = 32;
    }
    else
    {
      val = -( ( (compensation - distance) & ~(__typeof__ (compensation - distance))63 ) + 32 );
      if ( val > 0 )
        val = -32;
    }

    return val;
  }
# 1984 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Down_To_Grid( TT_ExecContext exc,
                      FT_F26Dot6 distance,
                      FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = ( (distance + compensation) & ~(__typeof__ (distance + compensation))63 );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -( (compensation - distance) & ~(__typeof__ (compensation - distance))63 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 2027 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Up_To_Grid( TT_ExecContext exc,
                    FT_F26Dot6 distance,
                    FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = ( ((distance + compensation) + 63) & ~(__typeof__ ((distance + compensation) + 63))63 );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -( ((compensation - distance) + 63) & ~(__typeof__ ((compensation - distance) + 63))63 );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 2070 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_To_Double_Grid( TT_ExecContext exc,
                        FT_F26Dot6 distance,
                        FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;

    ( (exc) = (exc) );


    if ( distance >= 0 )
    {
      val = ( ((distance + compensation) + ((32)/2)) & ~(__typeof__ ((distance + compensation) + ((32)/2)))( (32)-1 ) );
      if ( val < 0 )
        val = 0;
    }
    else
    {
      val = -( ((compensation - distance) + ((32)/2)) & ~(__typeof__ ((compensation - distance) + ((32)/2)))( (32)-1 ) );
      if ( val > 0 )
        val = 0;
    }

    return val;
  }
# 2119 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Super( TT_ExecContext exc,
               FT_F26Dot6 distance,
               FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;


    if ( distance >= 0 )
    {
      val = ( distance - exc->phase + exc->threshold + compensation ) &
              -exc->period;
      val += exc->phase;
      if ( val < 0 )
        val = exc->phase;
    }
    else
    {
      val = -( ( exc->threshold - exc->phase - distance + compensation ) &
               -exc->period );
      val -= exc->phase;
      if ( val > 0 )
        val = -exc->phase;
    }

    return val;
  }
# 2168 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Round_Super_45( TT_ExecContext exc,
                  FT_F26Dot6 distance,
                  FT_F26Dot6 compensation )
  {
    FT_F26Dot6 val;


    if ( distance >= 0 )
    {
      val = ( ( distance - exc->phase + exc->threshold + compensation ) /
                exc->period ) * exc->period;
      val += exc->phase;
      if ( val < 0 )
        val = exc->phase;
    }
    else
    {
      val = -( ( ( exc->threshold - exc->phase - distance + compensation ) /
                   exc->period ) * exc->period );
      val -= exc->phase;
      if ( val > 0 )
        val = -exc->phase;
    }

    return val;
  }
# 2208 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Compute_Round( TT_ExecContext exc,
                 FT_Byte round_mode )
  {
    switch ( round_mode )
    {
    case 5:
      exc->func_round = (TT_Round_Func)Round_None;
      break;

    case 1:
      exc->func_round = (TT_Round_Func)Round_To_Grid;
      break;

    case 4:
      exc->func_round = (TT_Round_Func)Round_Up_To_Grid;
      break;

    case 3:
      exc->func_round = (TT_Round_Func)Round_Down_To_Grid;
      break;

    case 0:
      exc->func_round = (TT_Round_Func)Round_To_Half_Grid;
      break;

    case 2:
      exc->func_round = (TT_Round_Func)Round_To_Double_Grid;
      break;

    case 6:
      exc->func_round = (TT_Round_Func)Round_Super;
      break;

    case 7:
      exc->func_round = (TT_Round_Func)Round_Super_45;
      break;
    }
  }
# 2262 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  SetSuperRound( TT_ExecContext exc,
                 FT_F2Dot14 GridPeriod,
                 FT_Long selector )
  {
    switch ( (FT_Int)( selector & 0xC0 ) )
    {
      case 0:
        exc->period = GridPeriod / 2;
        break;

      case 0x40:
        exc->period = GridPeriod;
        break;

      case 0x80:
        exc->period = GridPeriod * 2;
        break;


      case 0xC0:
        exc->period = GridPeriod;
        break;
    }

    switch ( (FT_Int)( selector & 0x30 ) )
    {
    case 0:
      exc->phase = 0;
      break;

    case 0x10:
      exc->phase = exc->period / 4;
      break;

    case 0x20:
      exc->phase = exc->period / 2;
      break;

    case 0x30:
      exc->phase = exc->period * 3 / 4;
      break;
    }

    if ( ( selector & 0x0F ) == 0 )
      exc->threshold = exc->period - 1;
    else
      exc->threshold = ( (FT_Int)( selector & 0x0F ) - 4 ) * exc->period / 8;


    exc->period >>= 8;
    exc->phase >>= 8;
    exc->threshold >>= 8;
  }
# 2334 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Project( TT_ExecContext exc,
           FT_Pos dx,
           FT_Pos dy )
  {




    return TT_DotFix14_long_long( dx, dy,
                        exc->GS.projVector.x,
                        exc->GS.projVector.y );
  }
# 2365 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Dual_Project( TT_ExecContext exc,
                FT_Pos dx,
                FT_Pos dy )
  {
    return TT_DotFix14_long_long( dx, dy,
                        exc->GS.dualVector.x,
                        exc->GS.dualVector.y );
  }
# 2392 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Project_x( TT_ExecContext exc,
             FT_Pos dx,
             FT_Pos dy )
  {
    ( (exc) = (exc) );
    ( (dy) = (dy) );

    return dx;
  }
# 2420 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_F26Dot6
  Project_y( TT_ExecContext exc,
             FT_Pos dx,
             FT_Pos dy )
  {
    ( (exc) = (exc) );
    ( (dx) = (dx) );

    return dy;
  }
# 2441 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Compute_Funcs( TT_ExecContext exc )
  {
# 2489 "../../../libs/freetype/src/truetype/ttinterp.c"
    if ( exc->GS.freeVector.x == 0x4000 )
      exc->F_dot_P = exc->GS.projVector.x;
    else if ( exc->GS.freeVector.y == 0x4000 )
      exc->F_dot_P = exc->GS.projVector.y;
    else
      exc->F_dot_P =
        ( (FT_Long)exc->GS.projVector.x * exc->GS.freeVector.x +
          (FT_Long)exc->GS.projVector.y * exc->GS.freeVector.y ) >> 14;

    if ( exc->GS.projVector.x == 0x4000 )
      exc->func_project = (TT_Project_Func)Project_x;
    else if ( exc->GS.projVector.y == 0x4000 )
      exc->func_project = (TT_Project_Func)Project_y;
    else
      exc->func_project = (TT_Project_Func)Project;

    if ( exc->GS.dualVector.x == 0x4000 )
      exc->func_dualproj = (TT_Project_Func)Project_x;
    else if ( exc->GS.dualVector.y == 0x4000 )
      exc->func_dualproj = (TT_Project_Func)Project_y;
    else
      exc->func_dualproj = (TT_Project_Func)Dual_Project;

    exc->func_move = (TT_Move_Func)Direct_Move;
    exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig;

    if ( exc->F_dot_P == 0x4000L )
    {
      if ( exc->GS.freeVector.x == 0x4000 )
      {
        exc->func_move = (TT_Move_Func)Direct_Move_X;
        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
      }
      else if ( exc->GS.freeVector.y == 0x4000 )
      {
        exc->func_move = (TT_Move_Func)Direct_Move_Y;
        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
      }
    }




    if ( ( (exc->F_dot_P) < 0 ? -(exc->F_dot_P) : (exc->F_dot_P) ) < 0x400L )
      exc->F_dot_P = 0x4000L;


    exc->tt_metrics.ratio = 0;
  }
# 2562 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  Normalize( FT_F26Dot6 Vx,
             FT_F26Dot6 Vy,
             FT_UnitVector* R )
  {
    FT_Vector V;


    if ( Vx == 0 && Vy == 0 )
    {


      return 0;
    }

    V.x = Vx;
    V.y = Vy;

    FT_Vector_NormLen( &V );

    R->x = (FT_F2Dot14)( V.x / 4 );
    R->y = (FT_F2Dot14)( V.y / 4 );

    return 0;
  }
# 2610 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MPPEM( TT_ExecContext exc,
             FT_Long* args )
  {
    args[0] = exc->func_cur_ppem( exc );
  }
# 2624 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MPS( TT_ExecContext exc,
           FT_Long* args )
  {





    args[0] = exc->func_cur_ppem( exc );

  }
# 2644 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DUP( FT_Long* args )
  {
    args[1] = args[0];
  }
# 2657 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_POP( void )
  {

  }
# 2670 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_CLEAR( TT_ExecContext exc )
  {
    exc->new_top = 0;
  }
# 2683 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SWAP( FT_Long* args )
  {
    FT_Long L;


    L = args[0];
    args[0] = args[1];
    args[1] = L;
  }
# 2701 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DEPTH( TT_ExecContext exc,
             FT_Long* args )
  {
    args[0] = exc->top;
  }
# 2715 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_LT( FT_Long* args )
  {
    args[0] = ( args[0] < args[1] );
  }
# 2728 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_LTEQ( FT_Long* args )
  {
    args[0] = ( args[0] <= args[1] );
  }
# 2741 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GT( FT_Long* args )
  {
    args[0] = ( args[0] > args[1] );
  }
# 2754 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GTEQ( FT_Long* args )
  {
    args[0] = ( args[0] >= args[1] );
  }
# 2767 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_EQ( FT_Long* args )
  {
    args[0] = ( args[0] == args[1] );
  }
# 2780 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NEQ( FT_Long* args )
  {
    args[0] = ( args[0] != args[1] );
  }
# 2793 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ODD( TT_ExecContext exc,
           FT_Long* args )
  {
    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 64 );
  }
# 2807 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_EVEN( TT_ExecContext exc,
            FT_Long* args )
  {
    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 0 );
  }
# 2821 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_AND( FT_Long* args )
  {
    args[0] = ( args[0] && args[1] );
  }
# 2834 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_OR( FT_Long* args )
  {
    args[0] = ( args[0] || args[1] );
  }
# 2847 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NOT( FT_Long* args )
  {
    args[0] = !args[0];
  }
# 2860 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ADD( FT_Long* args )
  {
    args[0] += args[1];
  }
# 2873 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SUB( FT_Long* args )
  {
    args[0] -= args[1];
  }
# 2886 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DIV( TT_ExecContext exc,
           FT_Long* args )
  {
    if ( args[1] == 0 )
      exc->error = TT_Err_Divide_By_Zero;
    else
      args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
  }
# 2903 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MUL( FT_Long* args )
  {
    args[0] = FT_MulDiv( args[0], args[1], 64L );
  }
# 2916 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ABS( FT_Long* args )
  {
    args[0] = ( (args[0]) < 0 ? -(args[0]) : (args[0]) );
  }
# 2929 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NEG( FT_Long* args )
  {
    args[0] = -args[0];
  }
# 2942 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLOOR( FT_Long* args )
  {
    args[0] = ( (args[0]) & ~(__typeof__ (args[0]))63 );
  }
# 2955 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_CEILING( FT_Long* args )
  {
    args[0] = ( ((args[0]) + 63) & ~(__typeof__ ((args[0]) + 63))63 );
  }
# 2968 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_RS( TT_ExecContext exc,
          FT_Long* args )
  {


    FT_ULong I = (FT_ULong)args[0];


    if ( ( (FT_ULong)(I) >= (FT_ULong)(exc->storeSize) ) )
    {
      if ( exc->pedantic_hinting )
        do { exc->error = TT_Err_Invalid_Reference; return; } while (0);
      else
        args[0] = 0;
    }
    else
    {


      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
           exc->ignore_x_mode &&
           ( ( I == 24 &&
               ( exc->face->sph_found_func_flags &
                 ( 0x0000020 |
                   0x0000040 ) ) ) ||
             ( I == 22 &&
               ( exc->sph_in_func_flags &
                 0x0000080 ) ) ||
             ( I == 8 &&
               ( exc->face->sph_found_func_flags &
                 0x0000008 ) &&
               exc->iup_called ) ) )
        args[0] = 0;
      else
        args[0] = exc->storage[I];
    }
# 3022 "../../../libs/freetype/src/truetype/ttinterp.c"
  }
# 3031 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_WS( TT_ExecContext exc,
          FT_Long* args )
  {
    FT_ULong I = (FT_ULong)args[0];


    if ( ( (FT_ULong)(I) >= (FT_ULong)(exc->storeSize) ) )
    {
      if ( exc->pedantic_hinting )
        do { exc->error = TT_Err_Invalid_Reference; return; } while (0);
    }
    else
      exc->storage[I] = args[1];
  }
# 3054 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_WCVTP( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_ULong I = (FT_ULong)args[0];


    if ( ( (FT_ULong)(I) >= (FT_ULong)(exc->cvtSize) ) )
    {
      if ( exc->pedantic_hinting )
        do { exc->error = TT_Err_Invalid_Reference; return; } while (0);
    }
    else
      exc->func_write_cvt( exc, I, args[1] );
  }
# 3077 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_WCVTF( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_ULong I = (FT_ULong)args[0];


    if ( ( (FT_ULong)(I) >= (FT_ULong)(exc->cvtSize) ) )
    {
      if ( exc->pedantic_hinting )
        do { exc->error = TT_Err_Invalid_Reference; return; } while (0);
    }
    else
      exc->cvt[I] = FT_MulFix_arm( (FT_Int32)(args[1]), (FT_Int32)(exc->tt_metrics.scale) );
  }
# 3100 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_RCVT( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_ULong I = (FT_ULong)args[0];


    if ( ( (FT_ULong)(I) >= (FT_ULong)(exc->cvtSize) ) )
    {
      if ( exc->pedantic_hinting )
        do { exc->error = TT_Err_Invalid_Reference; return; } while (0);
      else
        args[0] = 0;
    }
    else
      args[0] = exc->func_read_cvt( exc, I );
  }
# 3125 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_AA( void )
  {

  }
# 3140 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DEBUG( TT_ExecContext exc )
  {
    exc->error = TT_Err_Debug_OpCode;
  }
# 3153 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ROUND( TT_ExecContext exc,
             FT_Long* args )
  {
    args[0] = exc->func_round(
                exc,
                args[0],
                exc->tt_metrics.compensations[exc->opcode - 0x68] );
  }
# 3170 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NROUND( TT_ExecContext exc,
              FT_Long* args )
  {
    args[0] = Round_None(
                exc,
                args[0],
                exc->tt_metrics.compensations[exc->opcode - 0x6C] );
  }
# 3187 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MAX( FT_Long* args )
  {
    if ( args[1] > args[0] )
      args[0] = args[1];
  }
# 3201 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MIN( FT_Long* args )
  {
    if ( args[1] < args[0] )
      args[0] = args[1];
  }
# 3215 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MINDEX( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_Long L, K;


    L = args[0];

    if ( L <= 0 || L > exc->args )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
    }
    else
    {
      K = exc->stack[exc->args - L];

      memmove( &exc->stack[exc->args - L ], &exc->stack[exc->args - L + 1], (FT_Offset)((FT_Offset)(( L - 1 )) * sizeof ( *(&exc->stack[exc->args - L ]) )) )

                                ;

      exc->stack[exc->args - 1] = K;
    }
  }
# 3248 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_CINDEX( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_Long L;


    L = args[0];

    if ( L <= 0 || L > exc->args )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      args[0] = 0;
    }
    else
      args[0] = exc->stack[exc->args - L];
  }
# 3274 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ROLL( FT_Long* args )
  {
    FT_Long A, B, C;


    A = args[2];
    B = args[1];
    C = args[0];

    args[2] = C;
    args[1] = A;
    args[0] = B;
  }
# 3303 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SLOOP( TT_ExecContext exc,
             FT_Long* args )
  {
    if ( args[0] < 0 )
      exc->error = TT_Err_Bad_Argument;
    else
      exc->GS.loop = args[0];
  }


  static FT_Bool
  SkipCode( TT_ExecContext exc )
  {
    exc->IP += exc->length;

    if ( exc->IP < exc->codeSize )
    {
      exc->opcode = exc->code[exc->IP];

      exc->length = opcode_length[exc->opcode];
      if ( exc->length < 0 )
      {
        if ( exc->IP + 1 >= exc->codeSize )
          goto Fail_Overflow;
        exc->length = 2 - exc->length * exc->code[exc->IP + 1];
      }

      if ( exc->IP + exc->length <= exc->codeSize )
        return 0;
    }

  Fail_Overflow:
    exc->error = TT_Err_Code_Overflow;
    return 1;
  }
# 3347 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IF( TT_ExecContext exc,
          FT_Long* args )
  {
    FT_Int nIfs;
    FT_Bool Out;


    if ( args[0] != 0 )
      return;

    nIfs = 1;
    Out = 0;

    do
    {
      if ( SkipCode( exc ) == 1 )
        return;

      switch ( exc->opcode )
      {
      case 0x58:
        nIfs++;
        break;

      case 0x1B:
        Out = ( (FT_Bool)( nIfs == 1 ) );
        break;

      case 0x59:
        nIfs--;
        Out = ( (FT_Bool)( nIfs == 0 ) );
        break;
      }
    } while ( Out == 0 );
  }
# 3391 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ELSE( TT_ExecContext exc )
  {
    FT_Int nIfs;


    nIfs = 1;

    do
    {
      if ( SkipCode( exc ) == 1 )
        return;

      switch ( exc->opcode )
      {
      case 0x58:
        nIfs++;
        break;

      case 0x59:
        nIfs--;
        break;
      }
    } while ( nIfs != 0 );
  }
# 3424 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_EIF( void )
  {

  }
# 3437 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_JMPR( TT_ExecContext exc,
            FT_Long* args )
  {
    if ( args[0] == 0 && exc->args == 0 )
      exc->error = TT_Err_Bad_Argument;
    exc->IP += args[0];
    if ( exc->IP < 0 ||
         ( exc->callTop > 0 &&
           exc->IP > exc->callStack[exc->callTop - 1].Def->end ) )
      exc->error = TT_Err_Bad_Argument;
    exc->step_ins = 0;
  }
# 3458 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_JROT( TT_ExecContext exc,
            FT_Long* args )
  {
    if ( args[1] != 0 )
      Ins_JMPR( exc, args );
  }
# 3473 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_JROF( TT_ExecContext exc,
            FT_Long* args )
  {
    if ( args[1] == 0 )
      Ins_JMPR( exc, args );
  }
# 3495 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FDEF( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_ULong n;
    TT_DefRecord* rec;
    TT_DefRecord* limit;



    FT_Byte opcode_pattern[9][12] = {

                 {
                   0x4B,
                   0x53,
                   0x23,
                   0x4B,
                   0x51,
                   0x5A,
                   0x58,
                   0x38,
                   0x1B,
                   0x21,
                   0x21,
                   0x59
                 },

                 {
                   0x4B,
                   0x54,
                   0x58,
                   0x38,
                   0x1B,
                   0x21,
                   0x21,
                   0x59
                 },

                 {
                   0x20,
                   0x20,
                   0xB0,

                   0x60,
                   0x46,
                   0xB0,

                   0x23,
                   0x42
                 },

                 {
                   0x45,
                   0x23,
                   0x46,
                   0x60,
                   0x20,
                   0xB0

                 },

                 {
                   0x20,
                   0x64,
                   0xB0,

                   0x60,
                   0x66,
                   0x23,
                   0xB0
                 },

                 {
                   0x01,
                   0xB0,

                   0x43,
                   0x58
                 },

                 {
                   0x01,
                   0x18,
                   0xB0,

                   0x43,
                   0x58
                 },

                 {
                   0x01,
                   0x20,
                   0xB0,

                   0x25,
                 },

                 {
                   0x06,
                   0x7D,
                 },
               };
    FT_UShort opcode_patterns = 9;
    FT_UShort opcode_pointer[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    FT_UShort opcode_size[9] = { 12, 8, 8, 6, 7, 4, 5, 4, 2 };
    FT_UShort i;






    rec = exc->FDefs;
    limit = rec + exc->numFDefs;
    n = (FT_ULong)args[0];

    for ( ; rec < limit; rec++ )
    {
      if ( rec->opc == n )
        break;
    }

    if ( rec == limit )
    {

      if ( exc->numFDefs >= exc->maxFDefs )
      {
        exc->error = TT_Err_Too_Many_Function_Defs;
        return;
      }
      exc->numFDefs++;
    }



    if ( n > 0xFFFFU )
    {
      exc->error = TT_Err_Too_Many_Function_Defs;
      return;
    }

    rec->range = exc->curRange;
    rec->opc = (FT_UInt16)n;
    rec->start = exc->IP + 1;
    rec->active = 1;
    rec->inline_delta = 0;
    rec->sph_fdef_flags = 0x0000;

    if ( n > exc->maxFunc )
      exc->maxFunc = (FT_UInt16)n;




    if ( n >= 64 && n <= 66 )
      rec->sph_fdef_flags |= 0x0000080;





    while ( SkipCode( exc ) == 0 )
    {



      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) )
      {
        for ( i = 0; i < opcode_patterns; i++ )
        {
          if ( opcode_pointer[i] < opcode_size[i] &&
               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )
          {
            opcode_pointer[i] += 1;

            if ( opcode_pointer[i] == opcode_size[i] )
            {
              do { } while ( 0 )


                                                       ;

              switch ( i )
              {
              case 0:
                rec->sph_fdef_flags |= 0x0000001;
                exc->face->sph_found_func_flags |= 0x0000001;
                break;

              case 1:
                rec->sph_fdef_flags |= 0x0000002;
                exc->face->sph_found_func_flags |= 0x0000002;
                break;

              case 2:
                switch ( n )
                {

                case 58:
                  rec->sph_fdef_flags |= 0x0000004;
                  exc->face->sph_found_func_flags |= 0x0000004;
                }
                break;

              case 3:
                switch ( n )
                {
                case 0:
                  rec->sph_fdef_flags |= 0x0000008;
                  exc->face->sph_found_func_flags |= 0x0000008;
                }
                break;

              case 4:

                rec->sph_fdef_flags |= 0x0000010;
                exc->face->sph_found_func_flags |= 0x0000010;
                break;

              case 5:
                switch ( n )
                {
                case 0:
                case 1:
                case 2:
                case 4:
                case 7:
                case 8:
                  rec->sph_fdef_flags |= 0x0000020;
                  exc->face->sph_found_func_flags |= 0x0000020;
                }
                break;

              case 6:
                switch ( n )
                {
                case 0:
                case 1:
                case 2:
                case 4:
                case 7:
                case 8:
                  rec->sph_fdef_flags |= 0x0000040;
                  exc->face->sph_found_func_flags |= 0x0000040;
                }
                break;

               case 7:
                 rec->sph_fdef_flags |= 0x0000100;
                 exc->face->sph_found_func_flags |= 0x0000100;
                 break;

               case 8:




                 break;
              }
              opcode_pointer[i] = 0;
            }
          }

          else
            opcode_pointer[i] = 0;
        }


        exc->face->sph_compatibility_mode =
          ( ( exc->face->sph_found_func_flags & 0x0000001 ) |
            ( exc->face->sph_found_func_flags & 0x0000002 ) );
      }



      switch ( exc->opcode )
      {
      case 0x89:
      case 0x2C:
        exc->error = TT_Err_Nested_DEFS;
        return;

      case 0x2D:
        rec->end = exc->IP;
        return;
      }
    }
  }
# 3791 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ENDF( TT_ExecContext exc )
  {
    TT_CallRec* pRec;



    exc->sph_in_func_flags = 0x0000;


    if ( exc->callTop <= 0 )
    {
      exc->error = TT_Err_ENDF_In_Exec_Stream;
      return;
    }

    exc->callTop--;

    pRec = &exc->callStack[exc->callTop];

    pRec->Cur_Count--;

    exc->step_ins = 0;

    if ( pRec->Cur_Count > 0 )
    {
      exc->callTop++;
      exc->IP = pRec->Def->start;
    }
    else

      Ins_Goto_CodeRange( exc, pRec->Caller_Range, pRec->Caller_IP );
# 3831 "../../../libs/freetype/src/truetype/ttinterp.c"
  }
# 3840 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_CALL( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_ULong F;
    TT_CallRec* pCrec;
    TT_DefRecord* def;




    F = (FT_ULong)args[0];
    if ( ( (FT_ULong)(F) >= (FT_ULong)(exc->maxFunc + 1) ) )
      goto Fail;
# 3864 "../../../libs/freetype/src/truetype/ttinterp.c"
    def = exc->FDefs + F;
    if ( exc->maxFunc + 1 != exc->numFDefs || def->opc != F )
    {

      TT_DefRecord* limit;


      def = exc->FDefs;
      limit = def + exc->numFDefs;

      while ( def < limit && def->opc != F )
        def++;

      if ( def == limit )
        goto Fail;
    }


    if ( !def->active )
      goto Fail;


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         ( ( exc->iup_called &&
             ( exc->sph_tweak_flags & 0x0000400UL ) ) ||
           ( def->sph_fdef_flags & 0x0000008 ) ) )
      goto Fail;
    else
      exc->sph_in_func_flags = def->sph_fdef_flags;



    if ( exc->callTop >= exc->callSize )
    {
      exc->error = TT_Err_Stack_Overflow;
      return;
    }

    pCrec = exc->callStack + exc->callTop;

    pCrec->Caller_Range = exc->curRange;
    pCrec->Caller_IP = exc->IP + 1;
    pCrec->Cur_Count = 1;
    pCrec->Def = def;

    exc->callTop++;

    Ins_Goto_CodeRange( exc, def->range, def->start );

    exc->step_ins = 0;

    return;

  Fail:
    exc->error = TT_Err_Invalid_Reference;
  }
# 3929 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_LOOPCALL( TT_ExecContext exc,
                FT_Long* args )
  {
    FT_ULong F;
    TT_CallRec* pCrec;
    TT_DefRecord* def;



    F = (FT_ULong)args[1];
    if ( ( (FT_ULong)(F) >= (FT_ULong)(exc->maxFunc + 1) ) )
      goto Fail;
# 3952 "../../../libs/freetype/src/truetype/ttinterp.c"
    def = exc->FDefs + F;
    if ( exc->maxFunc + 1 != exc->numFDefs || def->opc != F )
    {

      TT_DefRecord* limit;


      def = exc->FDefs;
      limit = def + exc->numFDefs;

      while ( def < limit && def->opc != F )
        def++;

      if ( def == limit )
        goto Fail;
    }


    if ( !def->active )
      goto Fail;


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         ( def->sph_fdef_flags & 0x0000008 ) )
      goto Fail;
    else
      exc->sph_in_func_flags = def->sph_fdef_flags;



    if ( exc->callTop >= exc->callSize )
    {
      exc->error = TT_Err_Stack_Overflow;
      return;
    }

    if ( args[0] > 0 )
    {
      pCrec = exc->callStack + exc->callTop;

      pCrec->Caller_Range = exc->curRange;
      pCrec->Caller_IP = exc->IP + 1;
      pCrec->Cur_Count = (FT_Int)args[0];
      pCrec->Def = def;

      exc->callTop++;

      Ins_Goto_CodeRange( exc, def->range, def->start );

      exc->step_ins = 0;
    }

    return;

  Fail:
    exc->error = TT_Err_Invalid_Reference;
  }
# 4018 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IDEF( TT_ExecContext exc,
            FT_Long* args )
  {
    TT_DefRecord* def;
    TT_DefRecord* limit;




    def = exc->IDefs;
    limit = def + exc->numIDefs;

    for ( ; def < limit; def++ )
      if ( def->opc == (FT_ULong)args[0] )
        break;

    if ( def == limit )
    {

      if ( exc->numIDefs >= exc->maxIDefs )
      {
        exc->error = TT_Err_Too_Many_Instruction_Defs;
        return;
      }
      exc->numIDefs++;
    }


    if ( 0 > args[0] || args[0] > 0x00FF )
    {
      exc->error = TT_Err_Too_Many_Instruction_Defs;
      return;
    }

    def->opc = (FT_Byte)args[0];
    def->start = exc->IP + 1;
    def->range = exc->curRange;
    def->active = 1;

    if ( (FT_ULong)args[0] > exc->maxIns )
      exc->maxIns = (FT_Byte)args[0];




    while ( SkipCode( exc ) == 0 )
    {
      switch ( exc->opcode )
      {
      case 0x89:
      case 0x2C:
        exc->error = TT_Err_Nested_DEFS;
        return;
      case 0x2D:
        return;
      }
    }
  }
# 4092 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NPUSHB( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)exc->code[exc->IP + 1];

    if ( ( (FT_UInt)(L) >= (FT_UInt)(exc->stackSize + 1 - exc->top) ) )
    {
      exc->error = TT_Err_Stack_Overflow;
      return;
    }

    for ( K = 1; K <= L; K++ )
      args[K - 1] = exc->code[exc->IP + K + 1];

    exc->new_top += L;
  }
# 4120 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_NPUSHW( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)exc->code[exc->IP + 1];

    if ( ( (FT_UInt)(L) >= (FT_UInt)(exc->stackSize + 1 - exc->top) ) )
    {
      exc->error = TT_Err_Stack_Overflow;
      return;
    }

    exc->IP += 2;

    for ( K = 0; K < L; K++ )
      args[K] = GetShortIns( exc );

    exc->step_ins = 0;
    exc->new_top += L;
  }
# 4151 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_PUSHB( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)( exc->opcode - 0xB0 + 1 );

    if ( ( (FT_UInt)(L) >= (FT_UInt)(exc->stackSize + 1 - exc->top) ) )
    {
      exc->error = TT_Err_Stack_Overflow;
      return;
    }

    for ( K = 1; K <= L; K++ )
      args[K - 1] = exc->code[exc->IP + K];
  }
# 4177 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_PUSHW( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_UShort L, K;


    L = (FT_UShort)( exc->opcode - 0xB8 + 1 );

    if ( ( (FT_UInt)(L) >= (FT_UInt)(exc->stackSize + 1 - exc->top) ) )
    {
      exc->error = TT_Err_Stack_Overflow;
      return;
    }

    exc->IP++;

    for ( K = 0; K < L; K++ )
      args[K] = GetShortIns( exc );

    exc->step_ins = 0;
  }
# 4208 "../../../libs/freetype/src/truetype/ttinterp.c"
  static FT_Bool
  Ins_SxVTL( TT_ExecContext exc,
             FT_UShort aIdx1,
             FT_UShort aIdx2,
             FT_UnitVector* Vec )
  {
    FT_Long A, B, C;
    FT_Vector* p1;
    FT_Vector* p2;

    FT_Byte opcode = exc->opcode;


    if ( ( (FT_UInt)(aIdx1) >= (FT_UInt)(exc->zp2.n_points) ) ||
         ( (FT_UInt)(aIdx2) >= (FT_UInt)(exc->zp1.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return 1;
    }

    p1 = exc->zp1.cur + aIdx2;
    p2 = exc->zp2.cur + aIdx1;

    A = p1->x - p2->x;
    B = p1->y - p2->y;






    if ( A == 0 && B == 0 )
    {
      A = 0x4000;
      opcode = 0;
    }

    if ( ( opcode & 1 ) != 0 )
    {
      C = B;
      B = A;
      A = -C;
    }

    Normalize( A, B, Vec );

    return 0;
  }
# 4273 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SxyTCA( TT_ExecContext exc )
  {
    FT_Short AA, BB;

    FT_Byte opcode = exc->opcode;


    AA = (FT_Short)( ( opcode & 1 ) << 14 );
    BB = (FT_Short)( AA ^ 0x4000 );

    if ( opcode < 4 )
    {
      exc->GS.projVector.x = AA;
      exc->GS.projVector.y = BB;

      exc->GS.dualVector.x = AA;
      exc->GS.dualVector.y = BB;
    }
    else
      do { } while (0);

    if ( ( opcode & 2 ) == 0 )
    {
      exc->GS.freeVector.x = AA;
      exc->GS.freeVector.y = BB;
    }
    else
      do { } while (0);

    Compute_Funcs( exc );
  }
# 4313 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SPVTL( TT_ExecContext exc,
             FT_Long* args )
  {
    if ( Ins_SxVTL( exc,
                    (FT_UShort)args[1],
                    (FT_UShort)args[0],
                    &exc->GS.projVector ) == 0 )
    {
      exc->GS.dualVector = exc->GS.projVector;
      do { } while (0);
      Compute_Funcs( exc );
    }
  }
# 4335 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SFVTL( TT_ExecContext exc,
             FT_Long* args )
  {
    if ( Ins_SxVTL( exc,
                    (FT_UShort)args[1],
                    (FT_UShort)args[0],
                    &exc->GS.freeVector ) == 0 )
    {
      do { } while (0);
      Compute_Funcs( exc );
    }
  }
# 4356 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SFVTPV( TT_ExecContext exc )
  {
    do { } while (0);
    exc->GS.freeVector = exc->GS.projVector;
    Compute_Funcs( exc );
  }
# 4371 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SPVFS( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_Short S;
    FT_Long X, Y;



    S = (FT_Short)args[1];
    Y = (FT_Long)S;
    S = (FT_Short)args[0];
    X = (FT_Long)S;

    Normalize( X, Y, &exc->GS.projVector );

    exc->GS.dualVector = exc->GS.projVector;
    do { } while (0);
    Compute_Funcs( exc );
  }
# 4399 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SFVFS( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_Short S;
    FT_Long X, Y;



    S = (FT_Short)args[1];
    Y = (FT_Long)S;
    S = (FT_Short)args[0];
    X = S;

    Normalize( X, Y, &exc->GS.freeVector );
    do { } while (0);
    Compute_Funcs( exc );
  }
# 4425 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GPV( TT_ExecContext exc,
           FT_Long* args )
  {
# 4441 "../../../libs/freetype/src/truetype/ttinterp.c"
    args[0] = exc->GS.projVector.x;
    args[1] = exc->GS.projVector.y;

  }
# 4453 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GFV( TT_ExecContext exc,
           FT_Long* args )
  {
# 4469 "../../../libs/freetype/src/truetype/ttinterp.c"
    args[0] = exc->GS.freeVector.x;
    args[1] = exc->GS.freeVector.y;

  }
# 4481 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SRP0( TT_ExecContext exc,
            FT_Long* args )
  {
    exc->GS.rp0 = (FT_UShort)args[0];
  }
# 4495 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SRP1( TT_ExecContext exc,
            FT_Long* args )
  {
    exc->GS.rp1 = (FT_UShort)args[0];
  }
# 4509 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SRP2( TT_ExecContext exc,
            FT_Long* args )
  {
    exc->GS.rp2 = (FT_UShort)args[0];
  }
# 4523 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SMD( TT_ExecContext exc,
           FT_Long* args )
  {
    exc->GS.minimum_distance = args[0];
  }
# 4537 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCVTCI( TT_ExecContext exc,
              FT_Long* args )
  {
    exc->GS.control_value_cutin = (FT_F26Dot6)args[0];
  }
# 4551 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SSWCI( TT_ExecContext exc,
             FT_Long* args )
  {
    exc->GS.single_width_cutin = (FT_F26Dot6)args[0];
  }
# 4565 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SSW( TT_ExecContext exc,
           FT_Long* args )
  {
    exc->GS.single_width_value = FT_MulFix_arm( (FT_Int32)(args[0]), (FT_Int32)(exc->tt_metrics.scale) )
                                                                   ;
  }
# 4580 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPON( TT_ExecContext exc )
  {
    exc->GS.auto_flip = 1;
  }
# 4593 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPOFF( TT_ExecContext exc )
  {
    exc->GS.auto_flip = 0;
  }
# 4606 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SANGW( void )
  {

  }
# 4619 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SDB( TT_ExecContext exc,
           FT_Long* args )
  {
    exc->GS.delta_base = (FT_UShort)args[0];
  }
# 4633 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SDS( TT_ExecContext exc,
           FT_Long* args )
  {
    if ( (FT_ULong)args[0] > 6UL )
      exc->error = TT_Err_Bad_Argument;
    else
      exc->GS.delta_shift = (FT_UShort)args[0];
  }
# 4650 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_RTHG( TT_ExecContext exc )
  {
    exc->GS.round_state = 0;
    exc->func_round = (TT_Round_Func)Round_To_Half_Grid;
  }
# 4664 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_RTG( TT_ExecContext exc )
  {
    exc->GS.round_state = 1;
    exc->func_round = (TT_Round_Func)Round_To_Grid;
  }







  static void
  Ins_RTDG( TT_ExecContext exc )
  {
    exc->GS.round_state = 2;
    exc->func_round = (TT_Round_Func)Round_To_Double_Grid;
  }







  static void
  Ins_RUTG( TT_ExecContext exc )
  {
    exc->GS.round_state = 4;
    exc->func_round = (TT_Round_Func)Round_Up_To_Grid;
  }
# 4704 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_RDTG( TT_ExecContext exc )
  {
    exc->GS.round_state = 3;
    exc->func_round = (TT_Round_Func)Round_Down_To_Grid;
  }
# 4718 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ROFF( TT_ExecContext exc )
  {
    exc->GS.round_state = 5;
    exc->func_round = (TT_Round_Func)Round_None;
  }
# 4732 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SROUND( TT_ExecContext exc,
              FT_Long* args )
  {
    SetSuperRound( exc, 0x4000, args[0] );

    exc->GS.round_state = 6;
    exc->func_round = (TT_Round_Func)Round_Super;
  }
# 4749 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_S45ROUND( TT_ExecContext exc,
                FT_Long* args )
  {
    SetSuperRound( exc, 0x2D41, args[0] );

    exc->GS.round_state = 7;
    exc->func_round = (TT_Round_Func)Round_Super_45;
  }
# 4769 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GC( TT_ExecContext exc,
          FT_Long* args )
  {
    FT_ULong L;
    FT_F26Dot6 R;


    L = (FT_ULong)args[0];

    if ( ( (FT_ULong)(L) >= (FT_ULong)(exc->zp2.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      R = 0;
    }
    else
    {
      if ( exc->opcode & 1 )
        R = exc->func_dualproj( exc, (&exc->zp2.org[L])->x, (&exc->zp2.org[L])->y );
      else
        R = exc->func_project( exc, (&exc->zp2.cur[L])->x, (&exc->zp2.cur[L])->y );
    }

    args[0] = R;
  }
# 4807 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCFS( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_Long K;
    FT_UShort L;


    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(L) >= (FT_UInt)(exc->zp2.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    K = exc->func_project( exc, (&exc->zp2.cur[L])->x, (&exc->zp2.cur[L])->y );

    exc->func_move( exc, &exc->zp2, L, args[1] - K );



    if ( exc->GS.gep2 == 0 )
      exc->zp2.org[L] = exc->zp2.cur[L];
  }
# 4850 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MD( TT_ExecContext exc,
          FT_Long* args )
  {
    FT_UShort K, L;
    FT_F26Dot6 D;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(L) >= (FT_UInt)(exc->zp0.n_points) ) ||
         ( (FT_UInt)(K) >= (FT_UInt)(exc->zp1.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      D = 0;
    }
    else
    {
      if ( exc->opcode & 1 )
        D = exc->func_project( exc, (exc->zp0.cur + L)->x - (exc->zp1.cur + K)->x, (exc->zp0.cur + L)->y - (exc->zp1.cur + K)->y );
      else
      {


        if ( exc->GS.gep0 == 0 || exc->GS.gep1 == 0 )
        {
          FT_Vector* vec1 = exc->zp0.org + L;
          FT_Vector* vec2 = exc->zp1.org + K;


          D = exc->func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
        }
        else
        {
          FT_Vector* vec1 = exc->zp0.orus + L;
          FT_Vector* vec2 = exc->zp1.orus + K;


          if ( exc->metrics.x_scale == exc->metrics.y_scale )
          {

            D = exc->func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
            D = FT_MulFix_arm( (FT_Int32)(D), (FT_Int32)(exc->metrics.x_scale) );
          }
          else
          {
            FT_Vector vec;


            vec.x = FT_MulFix_arm( (FT_Int32)(vec1->x - vec2->x), (FT_Int32)(exc->metrics.x_scale) );
            vec.y = FT_MulFix_arm( (FT_Int32)(vec1->y - vec2->y), (FT_Int32)(exc->metrics.y_scale) );

            D = exc->func_dualproj( exc, (&vec)->x, (&vec)->y );
          }
        }
      }
    }



    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         ( (D) < 0 ? -(D) : (D) ) == 64 )
      D += 1;


    args[0] = D;
  }
# 4928 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SDPVTL( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_Long A, B, C;
    FT_UShort p1, p2;

    FT_Byte opcode = exc->opcode;


    p1 = (FT_UShort)args[1];
    p2 = (FT_UShort)args[0];

    if ( ( (FT_UInt)(p2) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_UInt)(p1) >= (FT_UInt)(exc->zp2.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    {
      FT_Vector* v1 = exc->zp1.org + p2;
      FT_Vector* v2 = exc->zp2.org + p1;


      A = v1->x - v2->x;
      B = v1->y - v2->y;






      if ( A == 0 && B == 0 )
      {
        A = 0x4000;
        opcode = 0;
      }
    }

    if ( ( opcode & 1 ) != 0 )
    {
      C = B;
      B = A;
      A = -C;
    }

    Normalize( A, B, &exc->GS.dualVector );

    {
      FT_Vector* v1 = exc->zp1.cur + p2;
      FT_Vector* v2 = exc->zp2.cur + p1;


      A = v1->x - v2->x;
      B = v1->y - v2->y;

      if ( A == 0 && B == 0 )
      {
        A = 0x4000;
        opcode = 0;
      }
    }

    if ( ( opcode & 1 ) != 0 )
    {
      C = B;
      B = A;
      A = -C;
    }

    Normalize( A, B, &exc->GS.projVector );
    do { } while (0);
    Compute_Funcs( exc );
  }
# 5012 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZP0( TT_ExecContext exc,
            FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp0 = exc->twilight;
      break;

    case 1:
      exc->zp0 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    exc->GS.gep0 = (FT_UShort)args[0];
  }
# 5042 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZP1( TT_ExecContext exc,
            FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp1 = exc->twilight;
      break;

    case 1:
      exc->zp1 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    exc->GS.gep1 = (FT_UShort)args[0];
  }
# 5072 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZP2( TT_ExecContext exc,
            FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp2 = exc->twilight;
      break;

    case 1:
      exc->zp2 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    exc->GS.gep2 = (FT_UShort)args[0];
  }
# 5102 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SZPS( TT_ExecContext exc,
            FT_Long* args )
  {
    switch ( (FT_Int)args[0] )
    {
    case 0:
      exc->zp0 = exc->twilight;
      break;

    case 1:
      exc->zp0 = exc->pts;
      break;

    default:
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    exc->zp1 = exc->zp0;
    exc->zp2 = exc->zp0;

    exc->GS.gep0 = (FT_UShort)args[0];
    exc->GS.gep1 = (FT_UShort)args[0];
    exc->GS.gep2 = (FT_UShort)args[0];
  }
# 5137 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_INSTCTRL( TT_ExecContext exc,
                FT_Long* args )
  {
    FT_ULong K, L, Kf;


    K = (FT_ULong)args[1];
    L = (FT_ULong)args[0];



    if ( K < 1 || K > 3 )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }


    Kf = 1 << ( K - 1 );

    if ( L != 0 )
    {

      if ( L != Kf )
      {
        if ( exc->pedantic_hinting )
          exc->error = TT_Err_Invalid_Reference;
        return;
      }
    }

    exc->GS.instruct_control &= ~(FT_Byte)Kf;
    exc->GS.instruct_control |= (FT_Byte)L;




    if ( K == 3 )
      exc->ignore_x_mode = ( (FT_Bool)( L == 4 ) );

  }
# 5188 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCANCTRL( TT_ExecContext exc,
                FT_Long* args )
  {
    FT_Int A;



    A = (FT_Int)( args[0] & 0xFF );

    if ( A == 0xFF )
    {
      exc->GS.scan_control = 1;
      return;
    }
    else if ( A == 0 )
    {
      exc->GS.scan_control = 0;
      return;
    }

    if ( ( args[0] & 0x100 ) != 0 && exc->tt_metrics.ppem <= A )
      exc->GS.scan_control = 1;

    if ( ( args[0] & 0x200 ) != 0 && exc->tt_metrics.rotated )
      exc->GS.scan_control = 1;

    if ( ( args[0] & 0x400 ) != 0 && exc->tt_metrics.stretched )
      exc->GS.scan_control = 1;

    if ( ( args[0] & 0x800 ) != 0 && exc->tt_metrics.ppem > A )
      exc->GS.scan_control = 0;

    if ( ( args[0] & 0x1000 ) != 0 && exc->tt_metrics.rotated )
      exc->GS.scan_control = 0;

    if ( ( args[0] & 0x2000 ) != 0 && exc->tt_metrics.stretched )
      exc->GS.scan_control = 0;
  }
# 5235 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SCANTYPE( TT_ExecContext exc,
                FT_Long* args )
  {
    if ( args[0] >= 0 )
      exc->GS.scan_type = (FT_Int)args[0];
  }
# 5257 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPPT( TT_ExecContext exc )
  {
    FT_UShort point;


    if ( exc->top < exc->GS.loop )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Too_Few_Arguments;
      goto Fail;
    }

    while ( exc->GS.loop > 0 )
    {
      exc->args--;

      point = (FT_UShort)exc->stack[exc->args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->pts.n_points) ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
        exc->pts.tags[point] ^= 1;

      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }
# 5302 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPRGON( TT_ExecContext exc,
                FT_Long* args )
  {
    FT_UShort I, K, L;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(K) >= (FT_UInt)(exc->pts.n_points) ) ||
         ( (FT_UInt)(L) >= (FT_UInt)(exc->pts.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    for ( I = L; I <= K; I++ )
      exc->pts.tags[I] |= 1;
  }
# 5331 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_FLIPRGOFF( TT_ExecContext exc,
                 FT_Long* args )
  {
    FT_UShort I, K, L;


    K = (FT_UShort)args[1];
    L = (FT_UShort)args[0];

    if ( ( (FT_UInt)(K) >= (FT_UInt)(exc->pts.n_points) ) ||
         ( (FT_UInt)(L) >= (FT_UInt)(exc->pts.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    for ( I = L; I <= K; I++ )
      exc->pts.tags[I] &= ~1;
  }


  static FT_Bool
  Compute_Point_Displacement( TT_ExecContext exc,
                              FT_F26Dot6* x,
                              FT_F26Dot6* y,
                              TT_GlyphZone zone,
                              FT_UShort* refp )
  {
    TT_GlyphZoneRec zp;
    FT_UShort p;
    FT_F26Dot6 d;


    if ( exc->opcode & 1 )
    {
      zp = exc->zp0;
      p = exc->GS.rp1;
    }
    else
    {
      zp = exc->zp1;
      p = exc->GS.rp2;
    }

    if ( ( (FT_UInt)(p) >= (FT_UInt)(zp.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      *refp = 0;
      return 1;
    }

    *zone = zp;
    *refp = p;

    d = exc->func_project( exc, (zp.cur + p)->x - (zp.org + p)->x, (zp.cur + p)->y - (zp.org + p)->y );
# 5406 "../../../libs/freetype/src/truetype/ttinterp.c"
    {
      *x = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.x, exc->F_dot_P );
      *y = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.y, exc->F_dot_P );
    }

    return 0;
  }


  static void
  Move_Zp2_Point( TT_ExecContext exc,
                  FT_UShort point,
                  FT_F26Dot6 dx,
                  FT_F26Dot6 dy,
                  FT_Bool touch )
  {
# 5441 "../../../libs/freetype/src/truetype/ttinterp.c"
    if ( exc->GS.freeVector.x != 0 )
    {
      exc->zp2.cur[point].x += dx;
      if ( touch )
        exc->zp2.tags[point] |= 8;
    }

    if ( exc->GS.freeVector.y != 0 )
    {
      exc->zp2.cur[point].y += dy;
      if ( touch )
        exc->zp2.tags[point] |= 16;
    }
  }
# 5463 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHP( TT_ExecContext exc )
  {
    TT_GlyphZoneRec zp;
    FT_UShort refp;

    FT_F26Dot6 dx, dy;
    FT_UShort point;


    if ( exc->top < exc->GS.loop )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    while ( exc->GS.loop > 0 )
    {
      exc->args--;
      point = (FT_UShort)exc->stack[exc->args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp2.n_points) ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else


      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
           exc->ignore_x_mode )
        Move_Zp2_Point( exc, point, 0, dy, 1 );
      else

        Move_Zp2_Point( exc, point, dx, dy, 1 );

      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }
# 5525 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHC( TT_ExecContext exc,
           FT_Long* args )
  {
    TT_GlyphZoneRec zp;
    FT_UShort refp;
    FT_F26Dot6 dx, dy;

    FT_Short contour, bounds;
    FT_UShort start, limit, i;


    contour = (FT_Short)args[0];
    bounds = ( exc->GS.gep2 == 0 ) ? 1 : exc->zp2.n_contours;

    if ( ( (FT_UInt)(contour) >= (FT_UInt)(bounds) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;

    if ( contour == 0 )
      start = 0;
    else
      start = (FT_UShort)( exc->zp2.contours[contour - 1] + 1 -
                           exc->zp2.first_point );


    if ( exc->GS.gep2 == 0 )
      limit = exc->zp2.n_points;
    else
      limit = (FT_UShort)( exc->zp2.contours[contour] -
                           exc->zp2.first_point + 1 );

    for ( i = start; i < limit; i++ )
    {
      if ( zp.cur != exc->zp2.cur || refp != i )
        Move_Zp2_Point( exc, i, dx, dy, 1 );
    }
  }
# 5577 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHZ( TT_ExecContext exc,
           FT_Long* args )
  {
    TT_GlyphZoneRec zp;
    FT_UShort refp;
    FT_F26Dot6 dx,
                     dy;

    FT_UShort limit, i;


    if ( ( (FT_UInt)(args[0]) >= (FT_UInt)(2) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
      return;





    if ( exc->GS.gep2 == 0 )
      limit = (FT_UShort)exc->zp2.n_points;
    else if ( exc->GS.gep2 == 1 && exc->zp2.n_contours > 0 )
      limit = (FT_UShort)( exc->zp2.contours[exc->zp2.n_contours - 1] + 1 );
    else
      limit = 0;


    for ( i = 0; i < limit; i++ )
    {
      if ( zp.cur != exc->zp2.cur || refp != i )
        Move_Zp2_Point( exc, i, dx, dy, 0 );
    }
  }
# 5625 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_SHPIX( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_F26Dot6 dx, dy;
    FT_UShort point;

    FT_Int B1, B2;



    if ( exc->top < exc->GS.loop + 1 )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }
# 5659 "../../../libs/freetype/src/truetype/ttinterp.c"
    {
      dx = TT_MulFix14_arm( args[0], exc->GS.freeVector.x );
      dy = TT_MulFix14_arm( args[0], exc->GS.freeVector.y );
    }

    while ( exc->GS.loop > 0 )
    {
      exc->args--;

      point = (FT_UShort)exc->stack[exc->args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp2.n_points) ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else

      {
# 5689 "../../../libs/freetype/src/truetype/ttinterp.c"
        if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
             exc->ignore_x_mode )
        {

          if ( exc->GS.freeVector.y != 0 )
            B1 = exc->zp2.cur[point].y;
          else
            B1 = exc->zp2.cur[point].x;

          if ( !exc->face->sph_compatibility_mode &&
               exc->GS.freeVector.y != 0 )
          {
            Move_Zp2_Point( exc, point, dx, dy, 1 );


            if ( exc->GS.freeVector.y != 0 )
            {
              B2 = exc->zp2.cur[point].y;


              if ( ( exc->sph_tweak_flags & 0x0010000UL ) &&
                   ( B1 & 63 ) != 0 &&
                   ( B2 & 63 ) != 0 &&
                   B1 != B2 )
                Move_Zp2_Point( exc, point, -dx, -dy, 1 );
            }
          }
          else if ( exc->face->sph_compatibility_mode )
          {
            if ( exc->sph_tweak_flags & 0x0004000UL )
            {
              dx = ( ((B1 + dx) + 32) & ~(__typeof__ ((B1 + dx) + 32))63 ) - B1;
              dy = ( ((B1 + dy) + 32) & ~(__typeof__ ((B1 + dy) + 32))63 ) - B1;
            }


            if ( exc->iup_called &&
                 ( ( exc->sph_in_func_flags & 0x0000001 ) ||
                   ( exc->sph_in_func_flags & 0x0000002 ) ) )
              goto Skip;

            if ( !( exc->sph_tweak_flags & 0x0000004UL ) &&
                  ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
                    ( exc->zp2.tags[point] & 16 ) ||
                    ( exc->sph_tweak_flags & 0x0000020UL ) ) )
              Move_Zp2_Point( exc, point, 0, dy, 1 );


            if ( exc->GS.freeVector.y != 0 )
            {
              B2 = exc->zp2.cur[point].y;


              if ( ( B1 & 63 ) == 0 &&
                   ( B2 & 63 ) != 0 &&
                   B1 != B2 )
                Move_Zp2_Point( exc, point, 0, -dy, 1 );
            }
          }
          else if ( exc->sph_in_func_flags & 0x0000100 )
            Move_Zp2_Point( exc, point, dx, dy, 1 );
        }
        else
          Move_Zp2_Point( exc, point, dx, dy, 1 );
      }

    Skip:







      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }
# 5778 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MSIRP( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 distance;


    FT_F26Dot6 control_value_cutin = 0;


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) )
    {
      control_value_cutin = exc->GS.control_value_cutin;

      if ( exc->ignore_x_mode &&
           exc->GS.freeVector.x != 0 &&
           !( exc->sph_tweak_flags & 0x0000100UL ) )
        control_value_cutin = 0;
    }



    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_UInt)(exc->GS.rp0) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }



    if ( exc->GS.gep1 == 0 )
    {
      exc->zp1.org[point] = exc->zp0.org[exc->GS.rp0];
      exc->func_move_orig( exc, &exc->zp1, point, args[1] );
      exc->zp1.cur[point] = exc->zp1.org[point];
    }

    distance = exc->func_project( exc, (exc->zp1.cur + point)->x - (exc->zp0.cur + exc->GS.rp0)->x, (exc->zp1.cur + point)->y - (exc->zp0.cur + exc->GS.rp0)->y );



    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->GS.freeVector.x != 0 &&
         ( (distance - args[1]) < 0 ? -(distance - args[1]) : (distance - args[1]) ) >= control_value_cutin )
      distance = args[1];


    exc->func_move( exc, &exc->zp1, point, args[1] - distance );

    exc->GS.rp1 = exc->GS.rp0;
    exc->GS.rp2 = point;

    if ( ( exc->opcode & 1 ) != 0 )
      exc->GS.rp0 = point;
  }
# 5847 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MDAP( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 cur_dist;
    FT_F26Dot6 distance;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    if ( ( exc->opcode & 1 ) != 0 )
    {
      cur_dist = exc->func_project( exc, (&exc->zp0.cur[point])->x, (&exc->zp0.cur[point])->y );

      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
           exc->ignore_x_mode &&
           exc->GS.freeVector.x != 0 )
        distance = Round_None(
                     exc,
                     cur_dist,
                     exc->tt_metrics.compensations[0] ) - cur_dist;
      else

        distance = exc->func_round(
                     exc,
                     cur_dist,
                     exc->tt_metrics.compensations[0] ) - cur_dist;
    }
    else
      distance = 0;

    exc->func_move( exc, &exc->zp0, point, distance );

    exc->GS.rp0 = point;
    exc->GS.rp1 = point;
  }
# 5899 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MIAP( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_ULong cvtEntry;
    FT_UShort point;
    FT_F26Dot6 distance;
    FT_F26Dot6 org_dist;
    FT_F26Dot6 control_value_cutin;


    control_value_cutin = exc->GS.control_value_cutin;
    cvtEntry = (FT_ULong)args[1];
    point = (FT_UShort)args[0];


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->GS.freeVector.x != 0 &&
         exc->GS.freeVector.y == 0 &&
         !( exc->sph_tweak_flags & 0x0000100UL ) )
      control_value_cutin = 0;


    if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp0.n_points) ) ||
         ( (FT_ULong)(cvtEntry) >= (FT_ULong)(exc->cvtSize) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }
# 5951 "../../../libs/freetype/src/truetype/ttinterp.c"
    distance = exc->func_read_cvt( exc, cvtEntry );

    if ( exc->GS.gep0 == 0 )
    {



      if ( !( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) ||
           ( !exc->ignore_x_mode ||
             !exc->face->sph_compatibility_mode ) )

        exc->zp0.org[point].x = TT_MulFix14_arm( distance,
                                             exc->GS.freeVector.x );
      exc->zp0.org[point].y = TT_MulFix14_arm( distance,
                                           exc->GS.freeVector.y ),
      exc->zp0.cur[point] = exc->zp0.org[point];
    }

    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         ( exc->sph_tweak_flags & 0x0000080UL ) &&
         distance > 0 &&
         exc->GS.freeVector.y != 0 )
      distance = 0;


    org_dist = exc->func_project( exc, (&exc->zp0.cur[point])->x, (&exc->zp0.cur[point])->y );

    if ( ( exc->opcode & 1 ) != 0 )
    {
      if ( ( (distance - org_dist) < 0 ? -(distance - org_dist) : (distance - org_dist) ) > control_value_cutin )
        distance = org_dist;


      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
           exc->ignore_x_mode &&
           exc->GS.freeVector.x != 0 )
        distance = Round_None( exc,
                               distance,
                               exc->tt_metrics.compensations[0] );
      else

        distance = exc->func_round( exc,
                                    distance,
                                    exc->tt_metrics.compensations[0] );
    }

    exc->func_move( exc, &exc->zp0, point, distance - org_dist );

  Fail:
    exc->GS.rp0 = point;
    exc->GS.rp1 = point;
  }
# 6012 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MDRP( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_UShort point;
    FT_F26Dot6 org_dist, distance, minimum_distance;


    minimum_distance = exc->GS.minimum_distance;


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->GS.freeVector.x != 0 &&
         !( exc->sph_tweak_flags & 0x0000100UL ) )
      minimum_distance = 0;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_UInt)(exc->GS.rp0) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }






    if ( exc->GS.gep0 == 0 || exc->GS.gep1 == 0 )
    {
      FT_Vector* vec1 = &exc->zp1.org[point];
      FT_Vector* vec2 = &exc->zp0.org[exc->GS.rp0];


      org_dist = exc->func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
    }
    else
    {
      FT_Vector* vec1 = &exc->zp1.orus[point];
      FT_Vector* vec2 = &exc->zp0.orus[exc->GS.rp0];


      if ( exc->metrics.x_scale == exc->metrics.y_scale )
      {

        org_dist = exc->func_dualproj( exc, (vec1)->x - (vec2)->x, (vec1)->y - (vec2)->y );
        org_dist = FT_MulFix_arm( (FT_Int32)(org_dist), (FT_Int32)(exc->metrics.x_scale) );
      }
      else
      {
        FT_Vector vec;


        vec.x = FT_MulFix_arm( (FT_Int32)(vec1->x - vec2->x), (FT_Int32)(exc->metrics.x_scale) );
        vec.y = FT_MulFix_arm( (FT_Int32)(vec1->y - vec2->y), (FT_Int32)(exc->metrics.y_scale) );

        org_dist = exc->func_dualproj( exc, (&vec)->x, (&vec)->y );
      }
    }



    if ( ( (org_dist - exc->GS.single_width_value) < 0 ? -(org_dist - exc->GS.single_width_value) : (org_dist - exc->GS.single_width_value) ) <
         exc->GS.single_width_cutin )
    {
      if ( org_dist >= 0 )
        org_dist = exc->GS.single_width_value;
      else
        org_dist = -exc->GS.single_width_value;
    }



    if ( ( exc->opcode & 4 ) != 0 )
    {

      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
           exc->ignore_x_mode &&
           exc->GS.freeVector.x != 0 )
        distance = Round_None(
                     exc,
                     org_dist,
                     exc->tt_metrics.compensations[exc->opcode & 3] );
      else

        distance = exc->func_round(
                     exc,
                     org_dist,
                     exc->tt_metrics.compensations[exc->opcode & 3] );
    }
    else
      distance = Round_None(
                   exc,
                   org_dist,
                   exc->tt_metrics.compensations[exc->opcode & 3] );



    if ( ( exc->opcode & 8 ) != 0 )
    {
      if ( org_dist >= 0 )
      {
        if ( distance < minimum_distance )
          distance = minimum_distance;
      }
      else
      {
        if ( distance > -minimum_distance )
          distance = -minimum_distance;
      }
    }



    org_dist = exc->func_project( exc, (exc->zp1.cur + point)->x - (exc->zp0.cur + exc->GS.rp0)->x, (exc->zp1.cur + point)->y - (exc->zp0.cur + exc->GS.rp0)->y );

    exc->func_move( exc, &exc->zp1, point, distance - org_dist );

  Fail:
    exc->GS.rp1 = exc->GS.rp0;
    exc->GS.rp2 = point;

    if ( ( exc->opcode & 16 ) != 0 )
      exc->GS.rp0 = point;
  }
# 6150 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_MIRP( TT_ExecContext exc,
            FT_Long* args )
  {
    FT_UShort point;
    FT_ULong cvtEntry;

    FT_F26Dot6 cvt_dist,
                distance,
                cur_dist,
                org_dist,
                control_value_cutin,
                minimum_distance;

    FT_Int B1 = 0;
    FT_Int B2 = 0;
    FT_Bool reverse_move = 0;



    minimum_distance = exc->GS.minimum_distance;
    control_value_cutin = exc->GS.control_value_cutin;
    point = (FT_UShort)args[0];
    cvtEntry = (FT_ULong)( args[1] + 1 );


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->GS.freeVector.x != 0 &&
         !( exc->sph_tweak_flags & 0x0000100UL ) )
      control_value_cutin = minimum_distance = 0;




    if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_ULong)(cvtEntry) >= (FT_ULong)(exc->cvtSize + 1) ) ||
         ( (FT_UInt)(exc->GS.rp0) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }

    if ( !cvtEntry )
      cvt_dist = 0;
    else
      cvt_dist = exc->func_read_cvt( exc, cvtEntry - 1 );



    if ( ( (cvt_dist - exc->GS.single_width_value) < 0 ? -(cvt_dist - exc->GS.single_width_value) : (cvt_dist - exc->GS.single_width_value) ) <
         exc->GS.single_width_cutin )
    {
      if ( cvt_dist >= 0 )
        cvt_dist = exc->GS.single_width_value;
      else
        cvt_dist = -exc->GS.single_width_value;
    }



    if ( exc->GS.gep1 == 0 )
    {
      exc->zp1.org[point].x = exc->zp0.org[exc->GS.rp0].x +
                              TT_MulFix14_arm( cvt_dist,
                                           exc->GS.freeVector.x );
      exc->zp1.org[point].y = exc->zp0.org[exc->GS.rp0].y +
                              TT_MulFix14_arm( cvt_dist,
                                           exc->GS.freeVector.y );
      exc->zp1.cur[point] = exc->zp1.org[point];
    }

    org_dist = exc->func_dualproj( exc, (&exc->zp1.org[point])->x - (&exc->zp0.org[exc->GS.rp0])->x, (&exc->zp1.org[point])->y - (&exc->zp0.org[exc->GS.rp0])->y );
    cur_dist = exc->func_project( exc, (&exc->zp1.cur[point])->x - (&exc->zp0.cur[exc->GS.rp0])->x, (&exc->zp1.cur[point])->y - (&exc->zp0.cur[exc->GS.rp0])->y );



    if ( exc->GS.auto_flip )
    {
      if ( ( org_dist ^ cvt_dist ) < 0 )
        cvt_dist = -cvt_dist;
    }


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->GS.freeVector.y != 0 &&
         ( exc->sph_tweak_flags & 0x0040000UL ) )
    {
      if ( cur_dist < -64 )
        cvt_dist -= 16;
      else if ( cur_dist > 64 && cur_dist < 84 )
        cvt_dist += 32;
    }




    if ( ( exc->opcode & 4 ) != 0 )
    {



      if ( exc->GS.gep0 == exc->GS.gep1 )
      {
# 6268 "../../../libs/freetype/src/truetype/ttinterp.c"
        if ( ( (cvt_dist - org_dist) < 0 ? -(cvt_dist - org_dist) : (cvt_dist - org_dist) ) > control_value_cutin )
          cvt_dist = org_dist;
      }

      distance = exc->func_round(
                   exc,
                   cvt_dist,
                   exc->tt_metrics.compensations[exc->opcode & 3] );
    }
    else
    {



      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
           exc->ignore_x_mode &&
           exc->GS.gep0 == exc->GS.gep1 )
      {
        if ( ( (cvt_dist - org_dist) < 0 ? -(cvt_dist - org_dist) : (cvt_dist - org_dist) ) > control_value_cutin )
          cvt_dist = org_dist;
      }


      distance = Round_None(
                   exc,
                   cvt_dist,
                   exc->tt_metrics.compensations[exc->opcode & 3] );
    }



    if ( ( exc->opcode & 8 ) != 0 )
    {
      if ( org_dist >= 0 )
      {
        if ( distance < minimum_distance )
          distance = minimum_distance;
      }
      else
      {
        if ( distance > -minimum_distance )
          distance = -minimum_distance;
      }
    }


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) )
    {
      B1 = exc->zp1.cur[point].y;


      if ( exc->ignore_x_mode &&
           exc->GS.freeVector.y != 0 &&
           ( exc->sph_tweak_flags & 0x0004000UL ) )
        distance = ( ((B1 + distance - cur_dist) + 32) & ~(__typeof__ ((B1 + distance - cur_dist) + 32))63 ) - B1 + cur_dist;

      if ( exc->ignore_x_mode &&
           exc->GS.freeVector.y != 0 &&
           ( exc->opcode & 16 ) == 0 &&
           ( exc->opcode & 8 ) == 0 &&
           ( exc->sph_tweak_flags & 0x0000008UL ) )
        distance += 64;
    }


    exc->func_move( exc, &exc->zp1, point, distance - cur_dist );


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) )
    {
      B2 = exc->zp1.cur[point].y;


      if ( exc->ignore_x_mode )
      {
        if ( exc->face->sph_compatibility_mode &&
             exc->GS.freeVector.y != 0 &&
             ( B1 & 63 ) == 0 &&
             ( B2 & 63 ) != 0 )
          reverse_move = 1;

        if ( ( exc->sph_tweak_flags & 0x0010000UL ) &&
             exc->GS.freeVector.y != 0 &&
             ( B2 & 63 ) != 0 &&
             ( B1 & 63 ) != 0 )
          reverse_move = 1;
      }

      if ( reverse_move )
        exc->func_move( exc, &exc->zp1, point, -( distance - cur_dist ) );
    }



  Fail:
    exc->GS.rp1 = exc->GS.rp0;

    if ( ( exc->opcode & 16 ) != 0 )
      exc->GS.rp0 = point;

    exc->GS.rp2 = point;
  }
# 6378 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ALIGNRP( TT_ExecContext exc )
  {
    FT_UShort point;
    FT_F26Dot6 distance;



    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->iup_called &&
         ( exc->sph_tweak_flags & 0x0000200UL ) )
    {
      exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }


    if ( exc->top < exc->GS.loop ||
         ( (FT_UInt)(exc->GS.rp0) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }

    while ( exc->GS.loop > 0 )
    {
      exc->args--;

      point = (FT_UShort)exc->stack[exc->args];

      if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp1.n_points) ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
      {
        distance = exc->func_project( exc, (exc->zp1.cur + point)->x - (exc->zp0.cur + exc->GS.rp0)->x, (exc->zp1.cur + point)->y - (exc->zp0.cur + exc->GS.rp0)->y )
                                                        ;

        exc->func_move( exc, &exc->zp1, point, -distance );
      }

      exc->GS.loop--;
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }
# 6441 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ISECT( TT_ExecContext exc,
             FT_Long* args )
  {
    FT_UShort point,
                a0, a1,
                b0, b1;

    FT_F26Dot6 discriminant, dotproduct;

    FT_F26Dot6 dx, dy,
                dax, day,
                dbx, dby;

    FT_F26Dot6 val;

    FT_Vector R;


    point = (FT_UShort)args[0];

    a0 = (FT_UShort)args[1];
    a1 = (FT_UShort)args[2];
    b0 = (FT_UShort)args[3];
    b1 = (FT_UShort)args[4];

    if ( ( (FT_UInt)(b0) >= (FT_UInt)(exc->zp0.n_points) ) ||
         ( (FT_UInt)(b1) >= (FT_UInt)(exc->zp0.n_points) ) ||
         ( (FT_UInt)(a0) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_UInt)(a1) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_UInt)(point) >= (FT_UInt)(exc->zp2.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }



    dbx = exc->zp0.cur[b1].x - exc->zp0.cur[b0].x;
    dby = exc->zp0.cur[b1].y - exc->zp0.cur[b0].y;

    dax = exc->zp1.cur[a1].x - exc->zp1.cur[a0].x;
    day = exc->zp1.cur[a1].y - exc->zp1.cur[a0].y;

    dx = exc->zp0.cur[b0].x - exc->zp1.cur[a0].x;
    dy = exc->zp0.cur[b0].y - exc->zp1.cur[a0].y;

    discriminant = FT_MulDiv( dax, -dby, 0x40 ) +
                   FT_MulDiv( day, dbx, 0x40 );
    dotproduct = FT_MulDiv( dax, dbx, 0x40 ) +
                   FT_MulDiv( day, dby, 0x40 );
# 6502 "../../../libs/freetype/src/truetype/ttinterp.c"
    if ( 19 * ( (discriminant) < 0 ? -(discriminant) : (discriminant) ) > ( (dotproduct) < 0 ? -(dotproduct) : (dotproduct) ) )
    {
      val = FT_MulDiv( dx, -dby, 0x40 ) + FT_MulDiv( dy, dbx, 0x40 );

      R.x = FT_MulDiv( val, dax, discriminant );
      R.y = FT_MulDiv( val, day, discriminant );

      exc->zp2.cur[point].x = exc->zp1.cur[a0].x + R.x;
      exc->zp2.cur[point].y = exc->zp1.cur[a0].y + R.y;
    }
    else
    {


      exc->zp2.cur[point].x = ( exc->zp1.cur[a0].x +
                                exc->zp1.cur[a1].x +
                                exc->zp0.cur[b0].x +
                                exc->zp0.cur[b1].x ) / 4;
      exc->zp2.cur[point].y = ( exc->zp1.cur[a0].y +
                                exc->zp1.cur[a1].y +
                                exc->zp0.cur[b0].y +
                                exc->zp0.cur[b1].y ) / 4;
    }

    exc->zp2.tags[point] |= ( 8 | 16 );
  }
# 6536 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_ALIGNPTS( TT_ExecContext exc,
                FT_Long* args )
  {
    FT_UShort p1, p2;
    FT_F26Dot6 distance;


    p1 = (FT_UShort)args[0];
    p2 = (FT_UShort)args[1];

    if ( ( (FT_UInt)(p1) >= (FT_UInt)(exc->zp1.n_points) ) ||
         ( (FT_UInt)(p2) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    distance = exc->func_project( exc, (exc->zp0.cur + p2)->x - (exc->zp1.cur + p1)->x, (exc->zp0.cur + p2)->y - (exc->zp1.cur + p1)->y ) / 2;

    exc->func_move( exc, &exc->zp1, p1, distance );
    exc->func_move( exc, &exc->zp0, p2, -distance );
  }
# 6571 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IP( TT_ExecContext exc )
  {
    FT_F26Dot6 old_range, cur_range;
    FT_Vector* orus_base;
    FT_Vector* cur_base;
    FT_Int twilight;


    if ( exc->top < exc->GS.loop )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }






    twilight = exc->GS.gep0 == 0 || exc->GS.gep1 == 0 || exc->GS.gep2 == 0;

    if ( ( (FT_UInt)(exc->GS.rp1) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      goto Fail;
    }

    if ( twilight )
      orus_base = &exc->zp0.org[exc->GS.rp1];
    else
      orus_base = &exc->zp0.orus[exc->GS.rp1];

    cur_base = &exc->zp0.cur[exc->GS.rp1];





    if ( ( (FT_UInt)(exc->GS.rp1) >= (FT_UInt)(exc->zp0.n_points) ) ||
         ( (FT_UInt)(exc->GS.rp2) >= (FT_UInt)(exc->zp1.n_points) ) )
    {
      old_range = 0;
      cur_range = 0;
    }
    else
    {
      if ( twilight )
        old_range = exc->func_dualproj( exc, (&exc->zp1.org[exc->GS.rp2])->x - (orus_base)->x, (&exc->zp1.org[exc->GS.rp2])->y - (orus_base)->y );
      else if ( exc->metrics.x_scale == exc->metrics.y_scale )
        old_range = exc->func_dualproj( exc, (&exc->zp1.orus[exc->GS.rp2])->x - (orus_base)->x, (&exc->zp1.orus[exc->GS.rp2])->y - (orus_base)->y );
      else
      {
        FT_Vector vec;


        vec.x = FT_MulFix_arm( (FT_Int32)(exc->zp1.orus[exc->GS.rp2].x - orus_base->x), (FT_Int32)(exc->metrics.x_scale) )
                                                 ;
        vec.y = FT_MulFix_arm( (FT_Int32)(exc->zp1.orus[exc->GS.rp2].y - orus_base->y), (FT_Int32)(exc->metrics.y_scale) )
                                                 ;

        old_range = exc->func_dualproj( exc, (&vec)->x, (&vec)->y );
      }

      cur_range = exc->func_project( exc, (&exc->zp1.cur[exc->GS.rp2])->x - (cur_base)->x, (&exc->zp1.cur[exc->GS.rp2])->y - (cur_base)->y );
    }

    for ( ; exc->GS.loop > 0; --exc->GS.loop )
    {
      FT_UInt point = (FT_UInt)exc->stack[--exc->args];
      FT_F26Dot6 org_dist, cur_dist, new_dist;



      if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp2.n_points) ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Invalid_Reference;
          return;
        }
        continue;
      }

      if ( twilight )
        org_dist = exc->func_dualproj( exc, (&exc->zp2.org[point])->x - (orus_base)->x, (&exc->zp2.org[point])->y - (orus_base)->y );
      else if ( exc->metrics.x_scale == exc->metrics.y_scale )
        org_dist = exc->func_dualproj( exc, (&exc->zp2.orus[point])->x - (orus_base)->x, (&exc->zp2.orus[point])->y - (orus_base)->y );
      else
      {
        FT_Vector vec;


        vec.x = FT_MulFix_arm( (FT_Int32)(exc->zp2.orus[point].x - orus_base->x), (FT_Int32)(exc->metrics.x_scale) )
                                                 ;
        vec.y = FT_MulFix_arm( (FT_Int32)(exc->zp2.orus[point].y - orus_base->y), (FT_Int32)(exc->metrics.y_scale) )
                                                 ;

        org_dist = exc->func_dualproj( exc, (&vec)->x, (&vec)->y );
      }

      cur_dist = exc->func_project( exc, (&exc->zp2.cur[point])->x - (cur_base)->x, (&exc->zp2.cur[point])->y - (cur_base)->y );

      if ( org_dist )
      {
        if ( old_range )
          new_dist = FT_MulDiv( org_dist, cur_range, old_range );
        else
        {
# 6698 "../../../libs/freetype/src/truetype/ttinterp.c"
          new_dist = org_dist;
        }
      }
      else
        new_dist = 0;

      exc->func_move( exc,
                      &exc->zp2,
                      (FT_UShort)point,
                      new_dist - cur_dist );
    }

  Fail:
    exc->GS.loop = 1;
    exc->new_top = exc->args;
  }
# 6722 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_UTP( TT_ExecContext exc,
           FT_Long* args )
  {
    FT_UShort point;
    FT_Byte mask;


    point = (FT_UShort)args[0];

    if ( ( (FT_UInt)(point) >= (FT_UInt)(exc->zp0.n_points) ) )
    {
      if ( exc->pedantic_hinting )
        exc->error = TT_Err_Invalid_Reference;
      return;
    }

    mask = 0xFF;

    if ( exc->GS.freeVector.x != 0 )
      mask &= ~8;

    if ( exc->GS.freeVector.y != 0 )
      mask &= ~16;

    exc->zp0.tags[point] &= mask;
  }



  typedef struct IUP_WorkerRec_
  {
    FT_Vector* orgs;
    FT_Vector* curs;
    FT_Vector* orus;
    FT_UInt max_points;

  } IUP_WorkerRec, *IUP_Worker;


  static void
  _iup_worker_shift( IUP_Worker worker,
                     FT_UInt p1,
                     FT_UInt p2,
                     FT_UInt p )
  {
    FT_UInt i;
    FT_F26Dot6 dx;


    dx = worker->curs[p].x - worker->orgs[p].x;
    if ( dx != 0 )
    {
      for ( i = p1; i < p; i++ )
        worker->curs[i].x += dx;

      for ( i = p + 1; i <= p2; i++ )
        worker->curs[i].x += dx;
    }
  }


  static void
  _iup_worker_interpolate( IUP_Worker worker,
                           FT_UInt p1,
                           FT_UInt p2,
                           FT_UInt ref1,
                           FT_UInt ref2 )
  {
    FT_UInt i;
    FT_F26Dot6 orus1, orus2, org1, org2, cur1, cur2, delta1, delta2;


    if ( p1 > p2 )
      return;

    if ( ( (FT_UInt)(ref1) >= (FT_UInt)(worker->max_points) ) ||
         ( (FT_UInt)(ref2) >= (FT_UInt)(worker->max_points) ) )
      return;

    orus1 = worker->orus[ref1].x;
    orus2 = worker->orus[ref2].x;

    if ( orus1 > orus2 )
    {
      FT_F26Dot6 tmp_o;
      FT_UInt tmp_r;


      tmp_o = orus1;
      orus1 = orus2;
      orus2 = tmp_o;

      tmp_r = ref1;
      ref1 = ref2;
      ref2 = tmp_r;
    }

    org1 = worker->orgs[ref1].x;
    org2 = worker->orgs[ref2].x;
    cur1 = worker->curs[ref1].x;
    cur2 = worker->curs[ref2].x;
    delta1 = cur1 - org1;
    delta2 = cur2 - org2;

    if ( cur1 == cur2 || orus1 == orus2 )
    {


      for ( i = p1; i <= p2; i++ )
      {
        FT_F26Dot6 x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;

        else if ( x >= org2 )
          x += delta2;

        else
          x = cur1;

        worker->curs[i].x = x;
      }
    }
    else
    {
      FT_Fixed scale = 0;
      FT_Bool scale_valid = 0;



      for ( i = p1; i <= p2; i++ )
      {
        FT_F26Dot6 x = worker->orgs[i].x;


        if ( x <= org1 )
          x += delta1;

        else if ( x >= org2 )
          x += delta2;

        else
        {
          if ( !scale_valid )
          {
            scale_valid = 1;
            scale = FT_DivFix( cur2 - cur1, orus2 - orus1 );
          }

          x = cur1 + FT_MulFix_arm( (FT_Int32)(worker->orus[i].x - orus1), (FT_Int32)(scale) );
        }
        worker->curs[i].x = x;
      }
    }
  }
# 6888 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_IUP( TT_ExecContext exc )
  {
    IUP_WorkerRec V;
    FT_Byte mask;

    FT_UInt first_point;
    FT_UInt end_point;

    FT_UInt first_touched;
    FT_UInt cur_touched;

    FT_UInt point;
    FT_Short contour;



    if ( exc->pts.n_contours == 0 )
      return;

    if ( exc->opcode & 1 )
    {
      mask = 8;
      V.orgs = exc->pts.org;
      V.curs = exc->pts.cur;
      V.orus = exc->pts.orus;
    }
    else
    {
      mask = 16;
      V.orgs = (FT_Vector*)( (FT_Pos*)exc->pts.org + 1 );
      V.curs = (FT_Vector*)( (FT_Pos*)exc->pts.cur + 1 );
      V.orus = (FT_Vector*)( (FT_Pos*)exc->pts.orus + 1 );
    }
    V.max_points = exc->pts.n_points;

    contour = 0;
    point = 0;


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode )
    {
      exc->iup_called = 1;
      if ( exc->sph_tweak_flags & 0x0008000UL )
        return;
    }


    do
    {
      end_point = exc->pts.contours[contour] - exc->pts.first_point;
      first_point = point;

      if ( ( (FT_UInt)(end_point) >= (FT_UInt)(exc->pts.n_points) ) )
        end_point = exc->pts.n_points - 1;

      while ( point <= end_point && ( exc->pts.tags[point] & mask ) == 0 )
        point++;

      if ( point <= end_point )
      {
        first_touched = point;
        cur_touched = point;

        point++;

        while ( point <= end_point )
        {
          if ( ( exc->pts.tags[point] & mask ) != 0 )
          {
            _iup_worker_interpolate( &V,
                                     cur_touched + 1,
                                     point - 1,
                                     cur_touched,
                                     point );
            cur_touched = point;
          }

          point++;
        }

        if ( cur_touched == first_touched )
          _iup_worker_shift( &V, first_point, end_point, cur_touched );
        else
        {
          _iup_worker_interpolate( &V,
                                   (FT_UShort)( cur_touched + 1 ),
                                   end_point,
                                   cur_touched,
                                   first_touched );

          if ( first_touched > 0 )
            _iup_worker_interpolate( &V,
                                     first_point,
                                     first_touched - 1,
                                     cur_touched,
                                     first_touched );
        }
      }
      contour++;
    } while ( contour < exc->pts.n_contours );
  }
# 6999 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DELTAP( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_ULong nump, k;
    FT_UShort A;
    FT_ULong C, P;
    FT_Long B;

    FT_UShort B1, B2;


    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->ignore_x_mode &&
         exc->iup_called &&
         ( exc->sph_tweak_flags & 0x0000800UL ) )
      goto Fail;
# 7039 "../../../libs/freetype/src/truetype/ttinterp.c"
    P = (FT_ULong)exc->func_cur_ppem( exc );
    nump = (FT_ULong)args[0];


    for ( k = 1; k <= nump; k++ )
    {
      if ( exc->args < 2 )
      {
        if ( exc->pedantic_hinting )
          exc->error = TT_Err_Too_Few_Arguments;
        exc->args = 0;
        goto Fail;
      }

      exc->args -= 2;

      A = (FT_UShort)exc->stack[exc->args + 1];
      B = exc->stack[exc->args];







      if ( !( (FT_UInt)(A) >= (FT_UInt)(exc->zp0.n_points) ) )
      {
        C = ( (FT_ULong)B & 0xF0 ) >> 4;

        switch ( exc->opcode )
        {
        case 0x5D:
          break;

        case 0x71:
          C += 16;
          break;

        case 0x72:
          C += 32;
          break;
        }

        C += exc->GS.delta_base;

        if ( P == C )
        {
          B = ( (FT_ULong)B & 0xF ) - 8;
          if ( B >= 0 )
            B++;
          B *= 1L << ( 6 - exc->GS.delta_shift );



          if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) )
          {
# 7103 "../../../libs/freetype/src/truetype/ttinterp.c"
            if ( !exc->ignore_x_mode ||
                 ( exc->sph_tweak_flags & 0x0000002UL ) ||
                 ( exc->is_composite && exc->GS.freeVector.y != 0 ) )
              exc->func_move( exc, &exc->zp0, A, B );



            else if ( exc->ignore_x_mode && exc->GS.freeVector.y != 0 )
            {

              B1 = (FT_UShort)exc->zp0.cur[A].y;



              if ( !exc->face->sph_compatibility_mode &&
                   ( exc->zp0.tags[A] & 16 ) )
                exc->func_move( exc, &exc->zp0, A, B );


              else if ( exc->face->sph_compatibility_mode &&
                        !( exc->sph_tweak_flags & 0x0000004UL ) )
              {
                if ( exc->sph_tweak_flags & 0x0004000UL )
                  B = ( ((B1 + B) + 32) & ~(__typeof__ ((B1 + B) + 32))63 ) - B1;



                if ( !exc->iup_called &&
                     ( exc->zp0.tags[A] & 16 ) )
                  exc->func_move( exc, &exc->zp0, A, B );
              }

              B2 = (FT_UShort)exc->zp0.cur[A].y;


              if ( exc->GS.freeVector.y != 0 &&
                   ( ( exc->face->sph_compatibility_mode &&
                       ( B1 & 63 ) == 0 &&
                       ( B2 & 63 ) != 0 ) ||
                     ( ( exc->sph_tweak_flags &
                         0x0080000UL ) &&
                       ( B1 & 63 ) != 0 &&
                       ( B2 & 63 ) != 0 ) ) )
                exc->func_move( exc, &exc->zp0, A, -B );
            }
          }
          else


            exc->func_move( exc, &exc->zp0, A, B );
        }
      }
      else
        if ( exc->pedantic_hinting )
          exc->error = TT_Err_Invalid_Reference;
    }

  Fail:
    exc->new_top = exc->args;
  }
# 7171 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_DELTAC( TT_ExecContext exc,
              FT_Long* args )
  {
    FT_ULong nump, k;
    FT_ULong A, C, P;
    FT_Long B;
# 7200 "../../../libs/freetype/src/truetype/ttinterp.c"
    P = (FT_ULong)exc->func_cur_ppem( exc );
    nump = (FT_ULong)args[0];

    for ( k = 1; k <= nump; k++ )
    {
      if ( exc->args < 2 )
      {
        if ( exc->pedantic_hinting )
          exc->error = TT_Err_Too_Few_Arguments;
        exc->args = 0;
        goto Fail;
      }

      exc->args -= 2;

      A = (FT_ULong)exc->stack[exc->args + 1];
      B = exc->stack[exc->args];

      if ( ( (FT_ULong)(A) >= (FT_ULong)(exc->cvtSize) ) )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Invalid_Reference;
          return;
        }
      }
      else
      {
        C = ( (FT_ULong)B & 0xF0 ) >> 4;

        switch ( exc->opcode )
        {
        case 0x73:
          break;

        case 0x74:
          C += 16;
          break;

        case 0x75:
          C += 32;
          break;
        }

        C += exc->GS.delta_base;

        if ( P == C )
        {
          B = ( (FT_ULong)B & 0xF ) - 8;
          if ( B >= 0 )
            B++;
          B *= 1L << ( 6 - exc->GS.delta_shift );

          exc->func_move_cvt( exc, A, B );
        }
      }
    }

  Fail:
    exc->new_top = exc->args;
  }
# 7284 "../../../libs/freetype/src/truetype/ttinterp.c"
  static void
  Ins_GETINFO( TT_ExecContext exc,
               FT_Long* args )
  {
    FT_Long K;


    K = 0;







    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         ( args[0] & 1 ) != 0 &&
         exc->subpixel_hinting )
    {
      if ( exc->ignore_x_mode )
      {


        K = exc->rasterizer_version;
        do { } while ( 0 )
                                              ;
      }
      else
        K = 38;
    }
    else

      if ( ( args[0] & 1 ) != 0 )
        K = 35;






    if ( ( args[0] & 2 ) != 0 && exc->tt_metrics.rotated )
      K |= 0x80;






    if ( ( args[0] & 4 ) != 0 && exc->tt_metrics.stretched )
      K |= 1 << 8;






    if ( ( args[0] & 32 ) != 0 && exc->grayscale )
      K |= 1 << 12;



    if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) &&
         exc->rasterizer_version >= 35 )
    {

      if ( exc->rasterizer_version >= 37 )
      {





        if ( ( args[0] & 64 ) != 0 && exc->subpixel_hinting )
          K |= 1 << 13;







        if ( ( args[0] & 128 ) != 0 && exc->compatible_widths )
          K |= 1 << 14;







        if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd )
          K |= 1 << 15;







        if ( ( args[0] & 512 ) != 0 && exc->bgr )
          K |= 1 << 16;

        if ( exc->rasterizer_version >= 38 )
        {






          if ( ( args[0] & 1024 ) != 0 && exc->subpixel_positioned )
            K |= 1 << 17;







          if ( ( args[0] & 2048 ) != 0 && exc->symmetrical_smoothing )
            K |= 1 << 18;







          if ( ( args[0] & 4096 ) != 0 && exc->gray_cleartype )
            K |= 1 << 19;
        }
      }
    }



    args[0] = K;
  }


  static void
  Ins_UNKNOWN( TT_ExecContext exc )
  {
    TT_DefRecord* def = exc->IDefs;
    TT_DefRecord* limit = def + exc->numIDefs;


    for ( ; def < limit; def++ )
    {
      if ( (FT_Byte)def->opc == exc->opcode && def->active )
      {
        TT_CallRec* call;


        if ( exc->callTop >= exc->callSize )
        {
          exc->error = TT_Err_Stack_Overflow;
          return;
        }

        call = exc->callStack + exc->callTop++;

        call->Caller_Range = exc->curRange;
        call->Caller_IP = exc->IP + 1;
        call->Cur_Count = 1;
        call->Def = def;

        Ins_Goto_CodeRange( exc, def->range, def->start );

        exc->step_ins = 0;
        return;
      }
    }

    exc->error = TT_Err_Invalid_Opcode;
  }
# 7494 "../../../libs/freetype/src/truetype/ttinterp.c"
  extern FT_Error
  TT_RunIns( TT_ExecContext exc )
  {
    FT_Long ins_counter = 0;
    FT_UShort i;


    FT_Byte opcode_pattern[1][2] = {

                  {
                    0x06,
                    0x7D,
                  },
                };
    FT_UShort opcode_patterns = 1;
    FT_UShort opcode_pointer[1] = { 0 };
    FT_UShort opcode_size[1] = { 1 };




    exc->iup_called = 0;



    exc->tt_metrics.ratio = 0;
    if ( exc->metrics.x_ppem != exc->metrics.y_ppem )
    {

      exc->func_cur_ppem = Current_Ppem_Stretched;
      exc->func_read_cvt = Read_CVT_Stretched;
      exc->func_write_cvt = Write_CVT_Stretched;
      exc->func_move_cvt = Move_CVT_Stretched;
    }
    else
    {

      exc->func_cur_ppem = Current_Ppem;
      exc->func_read_cvt = Read_CVT;
      exc->func_write_cvt = Write_CVT;
      exc->func_move_cvt = Move_CVT;
    }

    Compute_Funcs( exc );
    Compute_Round( exc, (FT_Byte)exc->GS.round_state );

    do
    {
      exc->opcode = exc->code[exc->IP];
# 7565 "../../../libs/freetype/src/truetype/ttinterp.c"
      if ( ( exc->length = opcode_length[exc->opcode] ) < 0 )
      {
        if ( exc->IP + 1 >= exc->codeSize )
          goto LErrorCodeOverflow_;

        exc->length = 2 - exc->length * exc->code[exc->IP + 1];
      }

      if ( exc->IP + exc->length > exc->codeSize )
        goto LErrorCodeOverflow_;


      exc->args = exc->top - ( Pop_Push_Count[exc->opcode] >> 4 );



      if ( exc->args < 0 )
      {
        if ( exc->pedantic_hinting )
        {
          exc->error = TT_Err_Too_Few_Arguments;
          goto LErrorLabel_;
        }


        for ( i = 0; i < Pop_Push_Count[exc->opcode] >> 4; i++ )
          exc->stack[i] = 0;
        exc->args = 0;
      }

      exc->new_top = exc->args + ( Pop_Push_Count[exc->opcode] & 15 );




      if ( exc->new_top > exc->stackSize )
      {
        exc->error = TT_Err_Stack_Overflow;
        goto LErrorLabel_;
      }

      exc->step_ins = 1;
      exc->error = FT_Err_Ok;



      if ( ( ((TT_Driver)((FT_Face)(exc->face))->driver)->interpreter_version == 38 ) )
      {
        for ( i = 0; i < opcode_patterns; i++ )
        {
          if ( opcode_pointer[i] < opcode_size[i] &&
               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )
          {
            opcode_pointer[i] += 1;

            if ( opcode_pointer[i] == opcode_size[i] )
            {
              do { } while ( 0 )


                                                       ;

              switch ( i )
              {
              case 0:
                break;
              }
              opcode_pointer[i] = 0;
            }
          }
          else
            opcode_pointer[i] = 0;
        }
      }



      {
        FT_Long* args = exc->stack + exc->args;
        FT_Byte opcode = exc->opcode;


        switch ( opcode )
        {
        case 0x00:
        case 0x01:
        case 0x02:
        case 0x03:
        case 0x04:
        case 0x05:
          Ins_SxyTCA( exc );
          break;

        case 0x06:
        case 0x07:
          Ins_SPVTL( exc, args );
          break;

        case 0x08:
        case 0x09:
          Ins_SFVTL( exc, args );
          break;

        case 0x0A:
          Ins_SPVFS( exc, args );
          break;

        case 0x0B:
          Ins_SFVFS( exc, args );
          break;

        case 0x0C:
          Ins_GPV( exc, args );
          break;

        case 0x0D:
          Ins_GFV( exc, args );
          break;

        case 0x0E:
          Ins_SFVTPV( exc );
          break;

        case 0x0F:
          Ins_ISECT( exc, args );
          break;

        case 0x10:
          Ins_SRP0( exc, args );
          break;

        case 0x11:
          Ins_SRP1( exc, args );
          break;

        case 0x12:
          Ins_SRP2( exc, args );
          break;

        case 0x13:
          Ins_SZP0( exc, args );
          break;

        case 0x14:
          Ins_SZP1( exc, args );
          break;

        case 0x15:
          Ins_SZP2( exc, args );
          break;

        case 0x16:
          Ins_SZPS( exc, args );
          break;

        case 0x17:
          Ins_SLOOP( exc, args );
          break;

        case 0x18:
          Ins_RTG( exc );
          break;

        case 0x19:
          Ins_RTHG( exc );
          break;

        case 0x1A:
          Ins_SMD( exc, args );
          break;

        case 0x1B:
          Ins_ELSE( exc );
          break;

        case 0x1C:
          Ins_JMPR( exc, args );
          break;

        case 0x1D:
          Ins_SCVTCI( exc, args );
          break;

        case 0x1E:
          Ins_SSWCI( exc, args );
          break;

        case 0x1F:
          Ins_SSW( exc, args );
          break;

        case 0x20:
          Ins_DUP( args );
          break;

        case 0x21:
          Ins_POP();
          break;

        case 0x22:
          Ins_CLEAR( exc );
          break;

        case 0x23:
          Ins_SWAP( args );
          break;

        case 0x24:
          Ins_DEPTH( exc, args );
          break;

        case 0x25:
          Ins_CINDEX( exc, args );
          break;

        case 0x26:
          Ins_MINDEX( exc, args );
          break;

        case 0x27:
          Ins_ALIGNPTS( exc, args );
          break;

        case 0x28:
          Ins_UNKNOWN( exc );
          break;

        case 0x29:
          Ins_UTP( exc, args );
          break;

        case 0x2A:
          Ins_LOOPCALL( exc, args );
          break;

        case 0x2B:
          Ins_CALL( exc, args );
          break;

        case 0x2C:
          Ins_FDEF( exc, args );
          break;

        case 0x2D:
          Ins_ENDF( exc );
          break;

        case 0x2E:
        case 0x2F:
          Ins_MDAP( exc, args );
          break;

        case 0x30:
        case 0x31:
          Ins_IUP( exc );
          break;

        case 0x32:
        case 0x33:
          Ins_SHP( exc );
          break;

        case 0x34:
        case 0x35:
          Ins_SHC( exc, args );
          break;

        case 0x36:
        case 0x37:
          Ins_SHZ( exc, args );
          break;

        case 0x38:
          Ins_SHPIX( exc, args );
          break;

        case 0x39:
          Ins_IP( exc );
          break;

        case 0x3A:
        case 0x3B:
          Ins_MSIRP( exc, args );
          break;

        case 0x3C:
          Ins_ALIGNRP( exc );
          break;

        case 0x3D:
          Ins_RTDG( exc );
          break;

        case 0x3E:
        case 0x3F:
          Ins_MIAP( exc, args );
          break;

        case 0x40:
          Ins_NPUSHB( exc, args );
          break;

        case 0x41:
          Ins_NPUSHW( exc, args );
          break;

        case 0x42:
          Ins_WS( exc, args );
          break;

        case 0x43:
          Ins_RS( exc, args );
          break;

        case 0x44:
          Ins_WCVTP( exc, args );
          break;

        case 0x45:
          Ins_RCVT( exc, args );
          break;

        case 0x46:
        case 0x47:
          Ins_GC( exc, args );
          break;

        case 0x48:
          Ins_SCFS( exc, args );
          break;

        case 0x49:
        case 0x4A:
          Ins_MD( exc, args );
          break;

        case 0x4B:
          Ins_MPPEM( exc, args );
          break;

        case 0x4C:
          Ins_MPS( exc, args );
          break;

        case 0x4D:
          Ins_FLIPON( exc );
          break;

        case 0x4E:
          Ins_FLIPOFF( exc );
          break;

        case 0x4F:
          Ins_DEBUG( exc );
          break;

        case 0x50:
          Ins_LT( args );
          break;

        case 0x51:
          Ins_LTEQ( args );
          break;

        case 0x52:
          Ins_GT( args );
          break;

        case 0x53:
          Ins_GTEQ( args );
          break;

        case 0x54:
          Ins_EQ( args );
          break;

        case 0x55:
          Ins_NEQ( args );
          break;

        case 0x56:
          Ins_ODD( exc, args );
          break;

        case 0x57:
          Ins_EVEN( exc, args );
          break;

        case 0x58:
          Ins_IF( exc, args );
          break;

        case 0x59:
          Ins_EIF();
          break;

        case 0x5A:
          Ins_AND( args );
          break;

        case 0x5B:
          Ins_OR( args );
          break;

        case 0x5C:
          Ins_NOT( args );
          break;

        case 0x5D:
          Ins_DELTAP( exc, args );
          break;

        case 0x5E:
          Ins_SDB( exc, args );
          break;

        case 0x5F:
          Ins_SDS( exc, args );
          break;

        case 0x60:
          Ins_ADD( args );
          break;

        case 0x61:
          Ins_SUB( args );
          break;

        case 0x62:
          Ins_DIV( exc, args );
          break;

        case 0x63:
          Ins_MUL( args );
          break;

        case 0x64:
          Ins_ABS( args );
          break;

        case 0x65:
          Ins_NEG( args );
          break;

        case 0x66:
          Ins_FLOOR( args );
          break;

        case 0x67:
          Ins_CEILING( args );
          break;

        case 0x68:
        case 0x69:
        case 0x6A:
        case 0x6B:
          Ins_ROUND( exc, args );
          break;

        case 0x6C:
        case 0x6D:
        case 0x6E:
        case 0x6F:
          Ins_NROUND( exc, args );
          break;

        case 0x70:
          Ins_WCVTF( exc, args );
          break;

        case 0x71:
        case 0x72:
          Ins_DELTAP( exc, args );
          break;

        case 0x73:
        case 0x74:
        case 0x75:
          Ins_DELTAC( exc, args );
          break;

        case 0x76:
          Ins_SROUND( exc, args );
          break;

        case 0x77:
          Ins_S45ROUND( exc, args );
          break;

        case 0x78:
          Ins_JROT( exc, args );
          break;

        case 0x79:
          Ins_JROF( exc, args );
          break;

        case 0x7A:
          Ins_ROFF( exc );
          break;

        case 0x7B:
          Ins_UNKNOWN( exc );
          break;

        case 0x7C:
          Ins_RUTG( exc );
          break;

        case 0x7D:
          Ins_RDTG( exc );
          break;

        case 0x7E:
          Ins_SANGW();
          break;

        case 0x7F:
          Ins_AA();
          break;

        case 0x80:
          Ins_FLIPPT( exc );
          break;

        case 0x81:
          Ins_FLIPRGON( exc, args );
          break;

        case 0x82:
          Ins_FLIPRGOFF( exc, args );
          break;

        case 0x83:
        case 0x84:
          Ins_UNKNOWN( exc );
          break;

        case 0x85:
          Ins_SCANCTRL( exc, args );
          break;

        case 0x86:
        case 0x87:
          Ins_SDPVTL( exc, args );
          break;

        case 0x88:
          Ins_GETINFO( exc, args );
          break;

        case 0x89:
          Ins_IDEF( exc, args );
          break;

        case 0x8A:
          Ins_ROLL( args );
          break;

        case 0x8B:
          Ins_MAX( args );
          break;

        case 0x8C:
          Ins_MIN( args );
          break;

        case 0x8D:
          Ins_SCANTYPE( exc, args );
          break;

        case 0x8E:
          Ins_INSTCTRL( exc, args );
          break;

        case 0x8F:
          Ins_UNKNOWN( exc );
          break;

        default:
          if ( opcode >= 0xE0 )
            Ins_MIRP( exc, args );
          else if ( opcode >= 0xC0 )
            Ins_MDRP( exc, args );
          else if ( opcode >= 0xB8 )
            Ins_PUSHW( exc, args );
          else if ( opcode >= 0xB0 )
            Ins_PUSHB( exc, args );
          else
            Ins_UNKNOWN( exc );
        }
      }

      if ( exc->error )
      {
        switch ( exc->error )
        {

        case TT_Err_Invalid_Opcode:
          {
            TT_DefRecord* def = exc->IDefs;
            TT_DefRecord* limit = def + exc->numIDefs;


            for ( ; def < limit; def++ )
            {
              if ( def->active && exc->opcode == (FT_Byte)def->opc )
              {
                TT_CallRec* callrec;


                if ( exc->callTop >= exc->callSize )
                {
                  exc->error = TT_Err_Invalid_Reference;
                  goto LErrorLabel_;
                }

                callrec = &exc->callStack[exc->callTop];

                callrec->Caller_Range = exc->curRange;
                callrec->Caller_IP = exc->IP + 1;
                callrec->Cur_Count = 1;
                callrec->Def = def;

                if ( Ins_Goto_CodeRange( exc,
                                         def->range,
                                         def->start ) == 1 )
                  goto LErrorLabel_;

                goto LSuiteLabel_;
              }
            }
          }

          exc->error = TT_Err_Invalid_Opcode;
          goto LErrorLabel_;







        default:
          goto LErrorLabel_;




        }
      }

      exc->top = exc->new_top;

      if ( exc->step_ins )
        exc->IP += exc->length;



      if ( ++ins_counter > 10000 )
        return TT_Err_Execution_Too_Long;

    LSuiteLabel_:
      if ( exc->IP >= exc->codeSize )
      {
        if ( exc->callTop > 0 )
        {
          exc->error = TT_Err_Code_Overflow;
          goto LErrorLabel_;
        }
        else
          goto LNo_Error_;
      }
    } while ( !exc->instruction_trap );

  LNo_Error_:
    return FT_Err_Ok;

  LErrorCodeOverflow_:
    exc->error = TT_Err_Code_Overflow;

  LErrorLabel_:



    if ( exc->error &&
         !exc->instruction_trap &&
         exc->curRange == tt_coderange_glyph )
    {
      do { } while ( 0 );
      exc->size->bytecode_ready = -1;
      exc->size->cvt_ready = -1;
    }

    return exc->error;
  }
# 30 "../../../libs/freetype/src/truetype/truetype.c" 2
# 1 "../../../libs/freetype/src/truetype/ttsubpix.c" 1
# 66 "../../../libs/freetype/src/truetype/ttsubpix.c"
  static const SPH_Font_Class FAMILY_CLASS_Rules
                               [7] =
  {
    { "MS Legacy Fonts",
      { "Aharoni",
        "Andale Mono",
        "Andalus",
        "Angsana New",
        "AngsanaUPC",
        "Arabic Transparent",
        "Arial Black",
        "Arial Narrow",
        "Arial Unicode MS",
        "Arial",
        "Batang",
        "Browallia New",
        "BrowalliaUPC",
        "Comic Sans MS",
        "Cordia New",
        "CordiaUPC",
        "Courier New",
        "DFKai-SB",
        "David Transparent",
        "David",
        "DilleniaUPC",
        "Estrangelo Edessa",
        "EucrosiaUPC",
        "FangSong_GB2312",
        "Fixed Miriam Transparent",
        "FrankRuehl",
        "Franklin Gothic Medium",
        "FreesiaUPC",
        "Garamond",
        "Gautami",
        "Georgia",
        "Gulim",
        "Impact",
        "IrisUPC",
        "JasmineUPC",
        "KaiTi_GB2312",
        "KodchiangUPC",
        "Latha",
        "Levenim MT",
        "LilyUPC",
        "Lucida Console",
        "Lucida Sans Unicode",
        "MS Gothic",
        "MS Mincho",
        "MV Boli",
        "Mangal",
        "Marlett",
        "Microsoft Sans Serif",
        "Mingliu",
        "Miriam Fixed",
        "Miriam Transparent",
        "Miriam",
        "Narkisim",
        "Palatino Linotype",
        "Raavi",
        "Rod Transparent",
        "Rod",
        "Shruti",
        "SimHei",
        "Simplified Arabic Fixed",
        "Simplified Arabic",
        "Simsun",
        "Sylfaen",
        "Symbol",
        "Tahoma",
        "Times New Roman",
        "Traditional Arabic",
        "Trebuchet MS",
        "Tunga",
        "Verdana",
        "Webdings",
        "Wingdings",
        "",
      },
    },
    { "Core MS Legacy Fonts",
      { "Arial Black",
        "Arial Narrow",
        "Arial Unicode MS",
        "Arial",
        "Comic Sans MS",
        "Courier New",
        "Garamond",
        "Georgia",
        "Impact",
        "Lucida Console",
        "Lucida Sans Unicode",
        "Microsoft Sans Serif",
        "Palatino Linotype",
        "Tahoma",
        "Times New Roman",
        "Trebuchet MS",
        "Verdana",
        "",
      },
    },
    { "Apple Legacy Fonts",
      { "Geneva",
        "Times",
        "Monaco",
        "Century",
        "Chalkboard",
        "Lobster",
        "Century Gothic",
        "Optima",
        "Lucida Grande",
        "Gill Sans",
        "Baskerville",
        "Helvetica",
        "Helvetica Neue",
        "",
      },
    },
    { "Legacy Sans Fonts",
      { "Andale Mono",
        "Arial Unicode MS",
        "Arial",
        "Century Gothic",
        "Comic Sans MS",
        "Franklin Gothic Medium",
        "Geneva",
        "Lucida Console",
        "Lucida Grande",
        "Lucida Sans Unicode",
        "Lucida Sans Typewriter",
        "Microsoft Sans Serif",
        "Monaco",
        "Tahoma",
        "Trebuchet MS",
        "Verdana",
        "",
      },
    },

    { "Misc Legacy Fonts",
      { "Dark Courier", "", }, },
    { "Verdana Clones",
      { "DejaVu Sans",
        "Bitstream Vera Sans", "", }, },
    { "Verdana and Clones",
      { "DejaVu Sans",
        "Bitstream Vera Sans",
        "Verdana", "", }, },
  };
# 226 "../../../libs/freetype/src/truetype/ttsubpix.c"
  static const SPH_Font_Class STYLE_CLASS_Rules
                               [5] =
  {
    { "Regular Class",
      { "Regular",
        "Book",
        "Medium",
        "Roman",
        "Normal",
        "",
      },
    },
    { "Regular/Italic Class",
      { "Regular",
        "Book",
        "Medium",
        "Italic",
        "Oblique",
        "Roman",
        "Normal",
        "",
      },
    },
    { "Bold/BoldItalic Class",
      { "Bold",
        "Bold Italic",
        "Black",
        "",
      },
    },
    { "Bold/Italic/BoldItalic Class",
      { "Bold",
        "Bold Italic",
        "Black",
        "Italic",
        "Oblique",
        "",
      },
    },
    { "Regular/Bold Class",
      { "Regular",
        "Book",
        "Medium",
        "Normal",
        "Roman",
        "Bold",
        "Black",
        "",
      },
    },
  };





  static const SPH_TweakRule COMPATIBILITY_MODE_Rules
                              [1] =
  {
    { "Verdana Clones", 0, "", 0 },
  };





  static const SPH_TweakRule PIXEL_HINTING_Rules
                              [2] =
  {

    { "Courier New", 12, "Italic", 'z' },
    { "Courier New", 11, "Italic", 'z' },
  };





  static const SPH_TweakRule DO_SHPIX_Rules
                              [1] =
  {
    { "-", 0, "", 0 },
  };






  static const SPH_TweakRule SKIP_NONPIXEL_Y_MOVES_Rules
                              [4] =
  {

    { "Consolas", 0, "", 0 },

    { "Core MS Legacy Fonts", 0, "Regular", 0 },

    { "Legacy Sans Fonts", 0, "", 0 },

    { "Verdana Clones", 0, "", 0 },
  };




  static const SPH_TweakRule SKIP_NONPIXEL_Y_MOVES_Rules_Exceptions
                              [1] =
  {

    { "Courier New", 0, "Regular", 0 },
  };






  static const SPH_TweakRule SKIP_NONPIXEL_Y_MOVES_DELTAP_Rules
                              [2] =
  {

    { "Times New Roman", 0, "Regular/Bold Class", 'N' },
    { "Georgia", 0, "Regular/Bold Class", 'N' },
  };





  static const SPH_TweakRule SKIP_OFFPIXEL_Y_MOVES_Rules
                              [1] =
  {
    { "-", 0, "", 0 },
  };




  static const SPH_TweakRule SKIP_OFFPIXEL_Y_MOVES_Rules_Exceptions
                              [1] =
  {
    { "-", 0, "", 0 },
  };





  static const SPH_TweakRule ROUND_NONPIXEL_Y_MOVES_Rules
                              [2] =
  {

    { "Droid Sans", 0, "Regular/Italic Class", 0 },
    { "Droid Sans Mono", 0, "", 0 },
  };




  static const SPH_TweakRule ROUND_NONPIXEL_Y_MOVES_Rules_Exceptions
                              [1] =
  {
    { "-", 0, "", 0 },
  };





  static const SPH_TweakRule ALLOW_X_DMOVE_Rules
                              [1] =
  {

    { "Verdana", 0, "Regular", '4' },
  };





  static const SPH_TweakRule RASTERIZER_35_Rules
                              [8] =
  {

    { "Times New Roman", 0, "Regular", 'i' },
    { "Times New Roman", 0, "Regular", 'j' },
    { "Times New Roman", 0, "Regular", 'm' },
    { "Times New Roman", 0, "Regular", 'r' },
    { "Times New Roman", 0, "Regular", 'a' },
    { "Times New Roman", 0, "Regular", 'n' },
    { "Times New Roman", 0, "Regular", 'p' },
    { "Times", 0, "", 0 },
  };





  static const SPH_TweakRule NORMAL_ROUND_Rules
                              [1] =
  {


    { "Courier New", 0, "", 0 },
  };





  static const SPH_TweakRule SKIP_IUP_Rules
                              [1] =
  {
    { "Arial", 13, "Regular", 'a' },
  };





  static const SPH_TweakRule MIAP_HACK_Rules
                              [1] =
  {
    { "Geneva", 12, "", 0 },
  };





  static const SPH_TweakRule ALWAYS_SKIP_DELTAP_Rules
                              [23] =
  {
    { "Georgia", 0, "Regular", 'k' },

    { "Trebuchet MS", 14, "Regular", 'e' },
    { "Trebuchet MS", 13, "Regular", 'e' },
    { "Trebuchet MS", 15, "Regular", 'e' },
    { "Trebuchet MS", 0, "Italic", 'v' },
    { "Trebuchet MS", 0, "Italic", 'w' },
    { "Trebuchet MS", 0, "Regular", 'Y' },
    { "Arial", 11, "Regular", 's' },

    { "Verdana", 10, "Regular", 0 },
    { "Verdana", 9, "Regular", 0 },

    { "Legacy Sans Fonts", 0, "", 0x438 },
    { "Legacy Sans Fonts", 0, "", 0x439 },
    { "Arial", 10, "Regular", '6' },
    { "Arial", 0, "Bold/BoldItalic Class", 'a' },

    { "Arial", 24, "Bold", 'a' },
    { "Arial", 25, "Bold", 'a' },
    { "Arial", 24, "Bold", 's' },
    { "Arial", 25, "Bold", 's' },
    { "Arial", 34, "Bold", 's' },
    { "Arial", 35, "Bold", 's' },
    { "Arial", 36, "Bold", 's' },
    { "Arial", 25, "Regular", 's' },
    { "Arial", 26, "Regular", 's' },
  };





  static const SPH_TweakRule ALWAYS_DO_DELTAP_Rules
                              [1] =
  {
    { "-", 0, "", 0 },
  };





  static const SPH_TweakRule NO_ALIGNRP_AFTER_IUP_Rules
                              [1] =
  {

    { "-", 0, "", 0 },
  };





  static const SPH_TweakRule NO_DELTAP_AFTER_IUP_Rules
                              [1] =
  {
    { "-", 0, "", 0 },
  };





  static const SPH_TweakRule NO_CALL_AFTER_IUP_Rules
                              [1] =
  {

    { "-", 0, "", 0 },
  };





  static const SPH_TweakRule DEEMBOLDEN_Rules
                              [9] =
  {
    { "Courier New", 0, "Bold", 'A' },
    { "Courier New", 0, "Bold", 'W' },
    { "Courier New", 0, "Bold", 'w' },
    { "Courier New", 0, "Bold", 'M' },
    { "Courier New", 0, "Bold", 'X' },
    { "Courier New", 0, "Bold", 'K' },
    { "Courier New", 0, "Bold", 'x' },
    { "Courier New", 0, "Bold", 'z' },
    { "Courier New", 0, "Bold", 'v' },
  };





  static const SPH_TweakRule EMBOLDEN_Rules
                              [2] =
  {
    { "Courier New", 0, "Regular", 0 },
    { "Courier New", 0, "Italic", 0 },
  };






  static const SPH_TweakRule TIMES_NEW_ROMAN_HACK_Rules
                              [12] =
  {
    { "Times New Roman", 16, "Italic", '2' },
    { "Times New Roman", 16, "Italic", '5' },
    { "Times New Roman", 16, "Italic", '7' },
    { "Times New Roman", 16, "Regular", '2' },
    { "Times New Roman", 16, "Regular", '5' },
    { "Times New Roman", 16, "Regular", '7' },
    { "Times New Roman", 17, "Italic", '2' },
    { "Times New Roman", 17, "Italic", '5' },
    { "Times New Roman", 17, "Italic", '7' },
    { "Times New Roman", 17, "Regular", '2' },
    { "Times New Roman", 17, "Regular", '5' },
    { "Times New Roman", 17, "Regular", '7' },
  };






  static const SPH_TweakRule COURIER_NEW_2_HACK_Rules
                              [15] =
  {
    { "Courier New", 10, "Regular", '2' },
    { "Courier New", 11, "Regular", '2' },
    { "Courier New", 12, "Regular", '2' },
    { "Courier New", 13, "Regular", '2' },
    { "Courier New", 14, "Regular", '2' },
    { "Courier New", 15, "Regular", '2' },
    { "Courier New", 16, "Regular", '2' },
    { "Courier New", 17, "Regular", '2' },
    { "Courier New", 18, "Regular", '2' },
    { "Courier New", 19, "Regular", '2' },
    { "Courier New", 20, "Regular", '2' },
    { "Courier New", 21, "Regular", '2' },
    { "Courier New", 22, "Regular", '2' },
    { "Courier New", 23, "Regular", '2' },
    { "Courier New", 24, "Regular", '2' },
  };
# 614 "../../../libs/freetype/src/truetype/ttsubpix.c"
  static const SPH_TweakRule COMPATIBLE_WIDTHS_Rules
                              [38] =
  {
    { "Arial Unicode MS", 12, "Regular Class", 'm' },
    { "Arial Unicode MS", 14, "Regular Class", 'm' },

    { "Arial", 10, "Regular Class", 0x448 },
    { "Arial", 11, "Regular Class", 'm' },
    { "Arial", 12, "Regular Class", 'm' },

    { "Arial", 12, "Regular Class", 0x448 },
    { "Arial", 13, "Regular Class", 0x448 },
    { "Arial", 14, "Regular Class", 'm' },

    { "Arial", 14, "Regular Class", 0x448 },
    { "Arial", 15, "Regular Class", 0x448 },
    { "Arial", 17, "Regular Class", 'm' },
    { "DejaVu Sans", 15, "Regular Class", 0 },
    { "Microsoft Sans Serif", 11, "Regular Class", 0 },
    { "Microsoft Sans Serif", 12, "Regular Class", 0 },
    { "Segoe UI", 11, "Regular Class", 0 },
    { "Monaco", 0, "Regular Class", 0 },
    { "Segoe UI", 12, "Regular Class", 'm' },
    { "Segoe UI", 14, "Regular Class", 'm' },
    { "Tahoma", 11, "Regular Class", 0 },
    { "Times New Roman", 16, "Regular Class", 'c' },
    { "Times New Roman", 16, "Regular Class", 'm' },
    { "Times New Roman", 16, "Regular Class", 'o' },
    { "Times New Roman", 16, "Regular Class", 'w' },
    { "Trebuchet MS", 11, "Regular Class", 0 },
    { "Trebuchet MS", 12, "Regular Class", 0 },
    { "Trebuchet MS", 14, "Regular Class", 0 },
    { "Trebuchet MS", 15, "Regular Class", 0 },
    { "Ubuntu", 12, "Regular Class", 'm' },

    { "Verdana", 10, "Regular Class", 0x448 },
    { "Verdana", 11, "Regular Class", 0x448 },
    { "Verdana and Clones", 12, "Regular Class", 'i' },
    { "Verdana and Clones", 12, "Regular Class", 'j' },
    { "Verdana and Clones", 12, "Regular Class", 'l' },
    { "Verdana and Clones", 12, "Regular Class", 'm' },
    { "Verdana and Clones", 13, "Regular Class", 'i' },
    { "Verdana and Clones", 13, "Regular Class", 'j' },
    { "Verdana and Clones", 13, "Regular Class", 'l' },
    { "Verdana and Clones", 14, "Regular Class", 'm' },
  };
# 669 "../../../libs/freetype/src/truetype/ttsubpix.c"
  static const SPH_ScaleRule X_SCALING_Rules[50] =
  {
    { "DejaVu Sans", 12, "Regular Class", 'm', 950 },
    { "Verdana and Clones", 12, "Regular Class", 'a', 1100 },
    { "Verdana and Clones", 13, "Regular Class", 'a', 1050 },
    { "Arial", 11, "Regular Class", 'm', 975 },
    { "Arial", 12, "Regular Class", 'm', 1050 },

    { "Arial", 13, "Regular Class", 0x43B, 950 },
    { "Arial", 13, "Regular Class", 'o', 950 },
    { "Arial", 13, "Regular Class", 'e', 950 },
    { "Arial", 14, "Regular Class", 'm', 950 },

    { "Arial", 15, "Regular Class", 0x43B, 925 },
    { "Bitstream Vera Sans", 10, "Regular/Italic Class", 0, 1100 },
    { "Bitstream Vera Sans", 12, "Regular/Italic Class", 0, 1050 },
    { "Bitstream Vera Sans", 16, "Regular Class", 0, 1050 },
    { "Bitstream Vera Sans", 9, "Regular/Italic Class", 0, 1050 },
    { "DejaVu Sans", 12, "Regular Class", 'l', 975 },
    { "DejaVu Sans", 12, "Regular Class", 'i', 975 },
    { "DejaVu Sans", 12, "Regular Class", 'j', 975 },
    { "DejaVu Sans", 13, "Regular Class", 'l', 950 },
    { "DejaVu Sans", 13, "Regular Class", 'i', 950 },
    { "DejaVu Sans", 13, "Regular Class", 'j', 950 },
    { "DejaVu Sans", 10, "Regular/Italic Class", 0, 1100 },
    { "DejaVu Sans", 12, "Regular/Italic Class", 0, 1050 },
    { "Georgia", 10, "", 0, 1050 },
    { "Georgia", 11, "", 0, 1100 },
    { "Georgia", 12, "", 0, 1025 },
    { "Georgia", 13, "", 0, 1050 },
    { "Georgia", 16, "", 0, 1050 },
    { "Georgia", 17, "", 0, 1030 },
    { "Liberation Sans", 12, "Regular Class", 'm', 1100 },
    { "Lucida Grande", 11, "Regular Class", 'm', 1100 },
    { "Microsoft Sans Serif", 11, "Regular Class", 'm', 950 },
    { "Microsoft Sans Serif", 12, "Regular Class", 'm', 1050 },
    { "Segoe UI", 12, "Regular Class", 'H', 1050 },
    { "Segoe UI", 12, "Regular Class", 'm', 1050 },
    { "Segoe UI", 14, "Regular Class", 'm', 1050 },
    { "Tahoma", 11, "Regular Class", 'i', 975 },
    { "Tahoma", 11, "Regular Class", 'l', 975 },
    { "Tahoma", 11, "Regular Class", 'j', 900 },
    { "Tahoma", 11, "Regular Class", 'm', 918 },
    { "Verdana", 10, "Regular/Italic Class", 0, 1100 },
    { "Verdana", 12, "Regular Class", 'm', 975 },
    { "Verdana", 12, "Regular/Italic Class", 0, 1050 },
    { "Verdana", 13, "Regular/Italic Class", 'i', 950 },
    { "Verdana", 13, "Regular/Italic Class", 'j', 950 },
    { "Verdana", 13, "Regular/Italic Class", 'l', 950 },
    { "Verdana", 16, "Regular Class", 0, 1050 },
    { "Verdana", 9, "Regular/Italic Class", 0, 1050 },
    { "Times New Roman", 16, "Regular Class", 'm', 918 },
    { "Trebuchet MS", 11, "Regular Class", 'm', 800 },
    { "Trebuchet MS", 12, "Regular Class", 'm', 800 },
  };
# 747 "../../../libs/freetype/src/truetype/ttsubpix.c"
  static FT_Bool
  is_member_of_family_class( const FT_String* detected_font_name,
                             const FT_String* rule_font_name )
  {
    FT_UInt i, j;



    if ( strcmp( detected_font_name, rule_font_name ) == 0 )
      return 1;


    if ( strcmp( rule_font_name, "" ) == 0 )
      return 1;


    for ( i = 0; i < 7; i++ )
    {
      if ( strcmp( FAMILY_CLASS_Rules[i].name, rule_font_name ) == 0 )
      {
        for ( j = 0; j < 100; j++ )
        {
          if ( strcmp( FAMILY_CLASS_Rules[i].member[j], "" ) == 0 )
            continue;
          if ( strcmp( FAMILY_CLASS_Rules[i].member[j],
                       detected_font_name ) == 0 )
            return 1;
        }
      }
    }

    return 0;
  }


  static FT_Bool
  is_member_of_style_class( const FT_String* detected_font_style,
                            const FT_String* rule_font_style )
  {
    FT_UInt i, j;



    if ( strcmp( detected_font_style, rule_font_style ) == 0 )
      return 1;


    if ( strcmp( rule_font_style, "" ) == 0 )
      return 1;


    for ( i = 0; i < 5; i++ )
    {
      if ( strcmp( STYLE_CLASS_Rules[i].name, rule_font_style ) == 0 )
      {
        for ( j = 0; j < 100; j++ )
        {
          if ( strcmp( STYLE_CLASS_Rules[i].member[j], "" ) == 0 )
            continue;
          if ( strcmp( STYLE_CLASS_Rules[i].member[j],
                       detected_font_style ) == 0 )
            return 1;
        }
      }
    }

    return 0;
  }


  static FT_Bool
  sph_test_tweak( TT_Face face,
                  const FT_String* family,
                  FT_UInt ppem,
                  const FT_String* style,
                  FT_UInt glyph_index,
                  const SPH_TweakRule* rule,
                  FT_UInt num_rules )
  {
    FT_UInt i;



    for ( i = 0; i < num_rules; i++ )
    {
      if ( family &&
           ( is_member_of_family_class ( family, rule[i].family ) ) )
        if ( rule[i].ppem == 0 ||
             rule[i].ppem == ppem )
          if ( style &&
               is_member_of_style_class ( style, rule[i].style ) )
            if ( rule[i].glyph == 0 ||
                 FT_Get_Char_Index( (FT_Face)face,
                                    rule[i].glyph ) == glyph_index )
        return 1;
    }

    return 0;
  }


  static FT_UInt
  scale_test_tweak( TT_Face face,
                    const FT_String* family,
                    FT_UInt ppem,
                    const FT_String* style,
                    FT_UInt glyph_index,
                    const SPH_ScaleRule* rule,
                    FT_UInt num_rules )
  {
    FT_UInt i;



    for ( i = 0; i < num_rules; i++ )
    {
      if ( family &&
           ( is_member_of_family_class ( family, rule[i].family ) ) )
        if ( rule[i].ppem == 0 ||
             rule[i].ppem == ppem )
          if ( style &&
               is_member_of_style_class( style, rule[i].style ) )
            if ( rule[i].glyph == 0 ||
                 FT_Get_Char_Index( (FT_Face)face,
                                    rule[i].glyph ) == glyph_index )
        return rule[i].scale;
    }

    return 1000;
  }


  static FT_UInt
  sph_test_tweak_x_scaling( TT_Face face,
                            const FT_String* family,
                            FT_UInt ppem,
                            const FT_String* style,
                            FT_UInt glyph_index )
  {
    return scale_test_tweak( face, family, ppem, style, glyph_index,
                             X_SCALING_Rules, 50 );
  }
# 902 "../../../libs/freetype/src/truetype/ttsubpix.c"
  static void
  sph_set_tweaks( TT_Loader loader,
                  FT_UInt glyph_index )
  {
    TT_Face face = loader->face;
    FT_String* family = face->root.family_name;
    FT_UInt ppem = loader->size->metrics.x_ppem;
    FT_String* style = face->root.style_name;



    if ( !face->root.style_name )
      return;






    if ( sph_test_tweak( face, family, ppem, style, glyph_index, PIXEL_HINTING_Rules, 2 ) ) loader->exec->sph_tweak_flags |= 0x0001000UL;;

    if ( loader->exec->sph_tweak_flags & 0x0001000UL )
    {
      loader->exec->ignore_x_mode = 0;
      return;
    }

    if ( sph_test_tweak( face, family, ppem, style, glyph_index, ALLOW_X_DMOVE_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000001UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, ALWAYS_DO_DELTAP_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000002UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, ALWAYS_SKIP_DELTAP_Rules, 23 ) ) loader->exec->sph_tweak_flags |= 0x0000004UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, DEEMBOLDEN_Rules, 9 ) ) loader->exec->sph_tweak_flags |= 0x0000010UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, DO_SHPIX_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000020UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, EMBOLDEN_Rules, 2 ) ) loader->exec->sph_tweak_flags |= 0x0000040UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, MIAP_HACK_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000080UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, NORMAL_ROUND_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000100UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, NO_ALIGNRP_AFTER_IUP_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000200UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, NO_CALL_AFTER_IUP_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000400UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, NO_DELTAP_AFTER_IUP_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0000800UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, RASTERIZER_35_Rules, 8 ) ) loader->exec->sph_tweak_flags |= 0x0002000UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, SKIP_IUP_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0008000UL;;

    if ( sph_test_tweak( face, family, ppem, style, glyph_index, SKIP_OFFPIXEL_Y_MOVES_Rules, 1 ) ) loader->exec->sph_tweak_flags |= 0x0020000UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, SKIP_OFFPIXEL_Y_MOVES_Rules_Exceptions, 1 ) ) loader->exec->sph_tweak_flags &= ~0x0020000UL;;

    if ( sph_test_tweak( face, family, ppem, style, glyph_index, SKIP_NONPIXEL_Y_MOVES_DELTAP_Rules, 2 ) ) loader->exec->sph_tweak_flags |= 0x0080000UL;;

    if ( sph_test_tweak( face, family, ppem, style, glyph_index, SKIP_NONPIXEL_Y_MOVES_Rules, 4 ) ) loader->exec->sph_tweak_flags |= 0x0010000UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, SKIP_NONPIXEL_Y_MOVES_Rules_Exceptions, 1 ) ) loader->exec->sph_tweak_flags &= ~0x0010000UL;;

    if ( sph_test_tweak( face, family, ppem, style, glyph_index, ROUND_NONPIXEL_Y_MOVES_Rules, 2 ) ) loader->exec->sph_tweak_flags |= 0x0004000UL;;
    if ( sph_test_tweak( face, family, ppem, style, glyph_index, ROUND_NONPIXEL_Y_MOVES_Rules_Exceptions, 1 ) ) loader->exec->sph_tweak_flags &= ~0x0004000UL;;

    if ( loader->exec->sph_tweak_flags & 0x0002000UL )
    {
      if ( loader->exec->rasterizer_version != 35 )
      {
        loader->exec->rasterizer_version = 35;
        loader->exec->size->cvt_ready = -1;

        tt_size_ready_bytecode(
          loader->exec->size,
          ( (FT_Bool)( loader->load_flags & ( 1L << 7 ) ) ) );
      }
      else
        loader->exec->rasterizer_version = 35;
    }
    else
    {
      if ( loader->exec->rasterizer_version !=
           38 )
      {
        loader->exec->rasterizer_version = 38;
        loader->exec->size->cvt_ready = -1;

        tt_size_ready_bytecode(
          loader->exec->size,
          ( (FT_Bool)( loader->load_flags & ( 1L << 7 ) ) ) );
      }
      else
        loader->exec->rasterizer_version = 38;
    }

    if ( ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) )
    {
      if ( sph_test_tweak( face, family, ppem, style, glyph_index, TIMES_NEW_ROMAN_HACK_Rules, 12 ) ) loader->exec->sph_tweak_flags |= 0x0040000UL;;
      if ( sph_test_tweak( face, family, ppem, style, glyph_index, COURIER_NEW_2_HACK_Rules, 15 ) ) loader->exec->sph_tweak_flags |= 0x0000008UL;;
    }

    if ( sph_test_tweak( face, family, ppem, style, glyph_index,
           COMPATIBILITY_MODE_Rules, 1 ) )
      loader->exec->face->sph_compatibility_mode = 1;


    if ( ( ( loader->load_flags & ( 1L << 1 ) ) == 0 ) )
    {
      if ( sph_test_tweak( face, family, ppem, style, glyph_index,
             COMPATIBLE_WIDTHS_Rules, 38 ) )
        loader->exec->compatible_widths |= 1;
    }
  }
# 31 "../../../libs/freetype/src/truetype/truetype.c" 2



# 1 "../../../libs/freetype/src/truetype/ttgxvar.c" 1
# 126 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_UShort*
  ft_var_readpackedpoints( FT_Stream stream,
                           FT_ULong size,
                           FT_UInt *point_cnt )
  {
    FT_UShort *points = ((void *)0);
    FT_UInt n;
    FT_UInt runcnt;
    FT_UInt i, j;
    FT_UShort first;
    FT_Memory memory = stream->memory;
    FT_Error error = FT_Err_Ok;

    ( (error) = (error) );


    *point_cnt = 0;

    n = ( (FT_Byte)FT_Stream_GetChar( stream ) );
    if ( n == 0 )
      return (FT_UShort*)~(FT_PtrDist)0;

    if ( n & 0x80U )
    {
      n &= 0x7FU;
      n <<= 8;
      n |= ( (FT_Byte)FT_Stream_GetChar( stream ) );
    }

    if ( n > size )
    {
      do { } while ( 0 );
      return ((void *)0);
    }

    if ( ( ((points) = (ft_mem_realloc( memory, sizeof ( *(points) ), 0, (FT_Long)(n), ((void *)0), &error ))), error != 0 ) )
      return ((void *)0);

    *point_cnt = n;

    i = 0;
    while ( i < n )
    {
      runcnt = ( (FT_Byte)FT_Stream_GetChar( stream ) );
      if ( runcnt & 0x80U )
      {
        runcnt &= 0x7FU;
        first = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
        points[i++] = first;

        if ( runcnt < 1 || i + runcnt > n )
          goto Exit;


        for ( j = 0; j < runcnt; j++ )
        {
          first += ( (FT_UShort)FT_Stream_GetUShort( stream ) );
          points[i++] = first;
        }
      }
      else
      {
        first = ( (FT_Byte)FT_Stream_GetChar( stream ) );
        points[i++] = first;

        if ( runcnt < 1 || i + runcnt > n )
          goto Exit;

        for ( j = 0; j < runcnt; j++ )
        {
          first += ( (FT_Byte)FT_Stream_GetChar( stream ) );
          points[i++] = first;
        }
      }
    }

  Exit:
    return points;
  }
# 234 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Short*
  ft_var_readpackeddeltas( FT_Stream stream,
                           FT_ULong size,
                           FT_UInt delta_cnt )
  {
    FT_Short *deltas = ((void *)0);
    FT_UInt runcnt, cnt;
    FT_UInt i, j;
    FT_Memory memory = stream->memory;
    FT_Error error = FT_Err_Ok;

    ( (error) = (error) );


    if ( delta_cnt > size )
    {
      do { } while ( 0 );
      return ((void *)0);
    }

    if ( ( ((deltas) = (ft_mem_realloc( memory, sizeof ( *(deltas) ), 0, (FT_Long)(delta_cnt), ((void *)0), &error ))), error != 0 ) )
      return ((void *)0);

    i = 0;
    while ( i < delta_cnt )
    {
      runcnt = ( (FT_Byte)FT_Stream_GetChar( stream ) );
      cnt = runcnt & 0x3FU;

      if ( runcnt & 0x80U )
      {

        for ( j = 0; j <= cnt && i < delta_cnt; j++ )
          deltas[i++] = 0;
      }
      else if ( runcnt & 0x40U )
      {

        for ( j = 0; j <= cnt && i < delta_cnt; j++ )
          deltas[i++] = ( (FT_Short)FT_Stream_GetUShort( stream ) );
      }
      else
      {

        for ( j = 0; j <= cnt && i < delta_cnt; j++ )
          deltas[i++] = ( (FT_Char)FT_Stream_GetChar( stream ) );
      }

      if ( j <= cnt )
      {

        do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );
        return ((void *)0);
      }
    }

    return deltas;
  }
# 306 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static void
  ft_var_load_avar( TT_Face face )
  {
    FT_Stream stream = ((FT_Face)(face))->stream;
    FT_Memory memory = stream->memory;
    GX_Blend blend = face->blend;
    GX_AVarSegment segment;
    FT_Error error = FT_Err_Ok;
    FT_Long version;
    FT_Long axisCount;
    FT_Int i, j;
    FT_ULong table_len;

    ( (error) = (error) );


    do { } while ( 0 );

    blend->avar_checked = 1;
    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'a' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ), stream, &table_len );
    if ( error )
    {
      do { } while ( 0 );
      return;
    }

    if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(table_len) ))) ) != 0 ) )
      return;

    version = ( (FT_Long)FT_Stream_GetULong( stream ) );
    axisCount = ( (FT_Long)FT_Stream_GetULong( stream ) );

    if ( version != 0x00010000L )
    {
      do { } while ( 0 );
      goto Exit;
    }

    do { } while ( 0 );

    if ( axisCount != (FT_Long)blend->mmvar->num_axis )
    {
      do { } while ( 0 )
                                                              ;
      goto Exit;
    }

    if ( ( ((blend->avar_segment) = (ft_mem_realloc( memory, sizeof ( *(blend->avar_segment) ), 0, (FT_Long)(axisCount), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    segment = &blend->avar_segment[0];
    for ( i = 0; i < axisCount; i++, segment++ )
    {
      do { } while ( 0 );

      segment->pairCount = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
      if ( (FT_ULong)segment->pairCount * 4 > table_len ||
           ( ((segment->correspondence) = (ft_mem_realloc( memory, sizeof ( *(segment->correspondence) ), 0, (FT_Long)(segment->pairCount), ((void *)0), &error ))), error != 0 ) )
      {



        for ( j = i - 1; j >= 0; j-- )
          do { ft_mem_free( memory, (blend->avar_segment[j].correspondence) ); (blend->avar_segment[j].correspondence) = ((void *)0); } while ( 0 );

        do { ft_mem_free( memory, (blend->avar_segment) ); (blend->avar_segment) = ((void *)0); } while ( 0 );
        blend->avar_segment = ((void *)0);
        goto Exit;
      }

      for ( j = 0; j < segment->pairCount; j++ )
      {

        segment->correspondence[j].fromCoord = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;
        segment->correspondence[j].toCoord = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;

        do { } while ( 0 )

                                                                   ;
      }

      do { } while ( 0 );
    }

  Exit:
    (FT_Stream_ExitFrame( stream ));
  }


  typedef struct GX_GVar_Head_
  {
    FT_Long version;
    FT_UShort axisCount;
    FT_UShort globalCoordCount;
    FT_ULong offsetToCoord;
    FT_UShort glyphCount;
    FT_UShort flags;
    FT_ULong offsetToData;

  } GX_GVar_Head;
# 423 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  ft_var_load_gvar( TT_Face face )
  {
    FT_Stream stream = ((FT_Face)(face))->stream;
    FT_Memory memory = stream->memory;
    GX_Blend blend = face->blend;
    FT_Error error;
    FT_UInt i, j;
    FT_ULong table_len;
    FT_ULong gvar_start;
    FT_ULong offsetToData;
    GX_GVar_Head gvar_head;

    static const FT_Frame_Field gvar_fields[] =
    {




      { ft_frame_start, 0, 20 },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->version ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, version) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->axisCount ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, axisCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->globalCoordCount ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, globalCoordCount) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->offsetToCoord ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, offsetToCoord) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->glyphCount ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, glyphCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->flags ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, flags) ) },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_GVar_Head*)0)->offsetToData ), (FT_UShort)( __builtin_offsetof (GX_GVar_Head, offsetToData) ) },
      { ft_frame_end, 0, 0 }
    };


    do { } while ( 0 );

    if ( ( error = face->goto_table( face,
                                     (FT_Tag) ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ),
                                     stream,
                                     &table_len ) ) != 0 )
    {
      do { } while ( 0 );
      goto Exit;
    }

    gvar_start = FT_Stream_Pos( stream );
    if ( ( ( error = (FT_Stream_ReadFields( stream, gvar_fields, &gvar_head )) ) != 0 ) )
      goto Exit;

    if ( gvar_head.version != 0x00010000L )
    {
      do { } while ( 0 );
      error = TT_Err_Invalid_Table;
      goto Exit;
    }

    if ( gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
    {
      do { } while ( 0 )
                                                              ;
      error = TT_Err_Invalid_Table;
      goto Exit;
    }


    if ( (FT_ULong)gvar_head.globalCoordCount * gvar_head.axisCount >
           table_len / 2 )
    {
      do { } while ( 0 )
                                                              ;
      error = TT_Err_Invalid_Table;
      goto Exit;
    }



    if ( (FT_ULong)gvar_head.glyphCount *
           ( ( gvar_head.flags & 1 ) ? 8 : 6 ) > table_len )
    {
      do { } while ( 0 );
      error = TT_Err_Invalid_Table;
      goto Exit;
    }

    do { } while ( 0 );

    blend->gvar_size = table_len;
    blend->tuplecount = gvar_head.globalCoordCount;
    blend->gv_glyphcnt = gvar_head.glyphCount;
    offsetToData = gvar_start + gvar_head.offsetToData;

    do { } while ( 0 )
                                    ;

    if ( ( ((blend->glyphoffsets) = (ft_mem_realloc( memory, sizeof ( *(blend->glyphoffsets) ), 0, (FT_Long)(blend->gv_glyphcnt + 1), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    if ( gvar_head.flags & 1 )
    {

      if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(( blend->gv_glyphcnt + 1 ) * 4L) ))) ) != 0 ) )
        goto Exit;

      for ( i = 0; i <= blend->gv_glyphcnt; i++ )
        blend->glyphoffsets[i] = offsetToData + ( (FT_ULong)FT_Stream_GetULong( stream ) );

      (FT_Stream_ExitFrame( stream ));
    }
    else
    {

      if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(( blend->gv_glyphcnt + 1 ) * 2L) ))) ) != 0 ) )
        goto Exit;

      for ( i = 0; i <= blend->gv_glyphcnt; i++ )
        blend->glyphoffsets[i] = offsetToData + ( (FT_UShort)FT_Stream_GetUShort( stream ) ) * 2;


      (FT_Stream_ExitFrame( stream ));
    }

    if ( blend->tuplecount != 0 )
    {
      if ( ( ((blend->tuplecoords) = (ft_mem_realloc( memory, sizeof ( *(blend->tuplecoords) ), 0, (FT_Long)(gvar_head.axisCount * blend->tuplecount), ((void *)0), &error ))), error != 0 )
                                                                   )
        goto Exit;

      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(gvar_start + gvar_head.offsetToCoord) )) ) != 0 ) ||
           ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(blend->tuplecount * gvar_head.axisCount * 2L) ))) ) != 0 ) )
        goto Exit;

      for ( i = 0; i < blend->tuplecount; i++ )
      {
        do { } while ( 0 );
        for ( j = 0 ; j < (FT_UInt)gvar_head.axisCount; j++ )
        {
          blend->tuplecoords[i * gvar_head.axisCount + j] =
            ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;
          do { } while ( 0 )
                                                                        ;
        }
        do { } while ( 0 );
      }

      do { } while ( 0 );

      (FT_Stream_ExitFrame( stream ));
    }

  Exit:
    return error;
  }
# 601 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Fixed
  ft_var_apply_tuple( GX_Blend blend,
                      FT_UShort tupleIndex,
                      FT_Fixed* tuple_coords,
                      FT_Fixed* im_start_coords,
                      FT_Fixed* im_end_coords )
  {
    FT_UInt i;
    FT_Fixed apply = 0x10000L;


    for ( i = 0; i < blend->num_axis; i++ )
    {
      do { } while ( 0 )
                                                            ;






      if ( tuple_coords[i] == 0 )
      {
        do { } while ( 0 );
        continue;
      }

      else if ( blend->normalizedcoords[i] == 0 )
      {
        do { } while ( 0 );
        apply = 0;
        break;
      }

      else if ( ( blend->normalizedcoords[i] < 0 && tuple_coords[i] > 0 ) ||
                ( blend->normalizedcoords[i] > 0 && tuple_coords[i] < 0 ) )
      {
        do { } while ( 0 )
                                                ;
        apply = 0;
        break;
      }

      else if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
      {
        do { } while ( 0 )
                                                ;

        apply = FT_MulFix_arm( (FT_Int32)(apply), (FT_Int32)(blend->normalizedcoords[i] > 0 ? blend->normalizedcoords[i] : -blend->normalizedcoords[i]) )


                                                            ;
      }

      else if ( blend->normalizedcoords[i] < im_start_coords[i] ||
                blend->normalizedcoords[i] > im_end_coords[i] )
      {
        do { } while ( 0 )


                                                 ;
        apply = 0;
        break;
      }

      else if ( blend->normalizedcoords[i] < tuple_coords[i] )
      {
        do { } while ( 0 )

                                                 ;
        apply = FT_MulDiv( apply,
                           blend->normalizedcoords[i] - im_start_coords[i],
                           tuple_coords[i] - im_start_coords[i] );
      }

      else
      {
        do { } while ( 0 )

                                                 ;
        apply = FT_MulDiv( apply,
                           im_end_coords[i] - blend->normalizedcoords[i],
                           im_end_coords[i] - tuple_coords[i] );
      }
    }

    do { } while ( 0 );

    return apply;
  }
# 702 "../../../libs/freetype/src/truetype/ttgxvar.c"
  typedef struct GX_FVar_Head_
  {
    FT_Long version;
    FT_UShort offsetToData;
    FT_UShort countSizePairs;
    FT_UShort axisCount;
    FT_UShort axisSize;
    FT_UShort instanceCount;
    FT_UShort instanceSize;

  } GX_FVar_Head;


  typedef struct fvar_axis_
  {
    FT_ULong axisTag;
    FT_Fixed minValue;
    FT_Fixed defaultValue;
    FT_Fixed maxValue;
    FT_UShort flags;
    FT_UShort nameID;

  } GX_FVar_Axis;
# 747 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Get_MM_Var( TT_Face face,
                 FT_MM_Var* *master )
  {
    FT_Stream stream = face->root.stream;
    FT_Memory memory = face->root.memory;
    FT_ULong table_len;
    FT_Error error = FT_Err_Ok;
    FT_ULong fvar_start;
    FT_Int i, j;
    FT_MM_Var* mmvar = ((void *)0);
    FT_Fixed* next_coords;
    FT_String* next_name;
    FT_Var_Axis* a;
    FT_Var_Named_Style* ns;
    GX_FVar_Head fvar_head;

    static const FT_Frame_Field fvar_fields[] =
    {




      { ft_frame_start, 0, 16 },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->version ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, version) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->offsetToData ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, offsetToData) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->countSizePairs ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, countSizePairs) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->axisCount ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, axisCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->axisSize ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, axisSize) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->instanceCount ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, instanceCount) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Head*)0)->instanceSize ), (FT_UShort)( __builtin_offsetof (GX_FVar_Head, instanceSize) ) },
      { ft_frame_end, 0, 0 }
    };

    static const FT_Frame_Field fvaraxis_fields[] =
    {




      { ft_frame_start, 0, 20 },
        { ft_frame_ulong_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->axisTag ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, axisTag) ) },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->minValue ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, minValue) ) },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->defaultValue ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, defaultValue) ) },
        { ft_frame_long_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->maxValue ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, maxValue) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->flags ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, flags) ) },
        { ft_frame_ushort_be, (FT_Byte)sizeof ( ((GX_FVar_Axis*)0)->nameID ), (FT_UShort)( __builtin_offsetof (GX_FVar_Axis, nameID) ) },
      { ft_frame_end, 0, 0 }
    };





    if ( face->blend == ((void *)0) )
    {
      do { } while ( 0 );


      if ( ( error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'g' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ),
                                       stream, &table_len ) ) != 0 )
      {
        do { } while ( 0 )
                                                                 ;
        goto Exit;
      }

      if ( ( error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'f' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ),
                                       stream, &table_len ) ) != 0 )
      {
        do { } while ( 0 );
        goto Exit;
      }

      fvar_start = FT_Stream_Pos( stream );

      if ( ( ( error = (FT_Stream_ReadFields( stream, fvar_fields, &fvar_head )) ) != 0 ) )
        goto Exit;

      if ( fvar_head.version != (FT_Long)0x00010000L ||






           fvar_head.axisSize != 20 ||

           fvar_head.axisCount > 0x3FFE ||
           fvar_head.instanceSize != 4 + 4 * fvar_head.axisCount ||

           fvar_head.instanceCount > 0x7EFF ||
           fvar_head.offsetToData + fvar_head.axisCount * 20U +
             fvar_head.instanceCount * fvar_head.instanceSize > table_len )
      {
        do { } while ( 0 )
                                                               ;
        error = TT_Err_Invalid_Table;
        goto Exit;
      }

      do { } while ( 0 );

      do { } while ( 0 );

      if ( ( ((face->blend) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *(face->blend) )), &error ))), error != 0 ) )
        goto Exit;


      face->blend->mmvar_len =
        sizeof ( FT_MM_Var ) +
        fvar_head.axisCount * sizeof ( FT_Var_Axis ) +
        fvar_head.instanceCount * sizeof ( FT_Var_Named_Style ) +
        fvar_head.instanceCount * fvar_head.axisCount * sizeof ( FT_Fixed ) +
        5 * fvar_head.axisCount;

      if ( ( ((mmvar) = (ft_mem_alloc( memory, (FT_Long)(face->blend->mmvar_len), &error ))), error != 0 ) )
        goto Exit;
      face->blend->mmvar = mmvar;




      mmvar->num_axis =
        fvar_head.axisCount;
      mmvar->num_designs =
        ~0U;


      mmvar->num_namedstyles =
        fvar_head.instanceCount;
      mmvar->axis =
        (FT_Var_Axis*)&( mmvar[1] );
      mmvar->namedstyle =
        (FT_Var_Named_Style*)&( mmvar->axis[fvar_head.axisCount] );

      next_coords =
        (FT_Fixed*)&( mmvar->namedstyle[fvar_head.instanceCount] );
      for ( i = 0; i < fvar_head.instanceCount; i++ )
      {
        mmvar->namedstyle[i].coords = next_coords;
        next_coords += fvar_head.axisCount;
      }

      next_name = (FT_String*)next_coords;
      for ( i = 0; i < fvar_head.axisCount; i++ )
      {
        mmvar->axis[i].name = next_name;
        next_name += 5;
      }



      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(fvar_start + fvar_head.offsetToData) )) ) != 0 ) )
        goto Exit;

      a = mmvar->axis;
      for ( i = 0; i < fvar_head.axisCount; i++ )
      {
        GX_FVar_Axis axis_rec;


        if ( ( ( error = (FT_Stream_ReadFields( stream, fvaraxis_fields, &axis_rec )) ) != 0 ) )
          goto Exit;
        a->tag = axis_rec.axisTag;
        a->minimum = axis_rec.minValue;
        a->def = axis_rec.defaultValue;
        a->maximum = axis_rec.maxValue;
        a->strid = axis_rec.nameID;

        a->name[0] = (FT_String)( a->tag >> 24 );
        a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
        a->name[2] = (FT_String)( ( a->tag >> 8 ) & 0xFF );
        a->name[3] = (FT_String)( ( a->tag ) & 0xFF );
        a->name[4] = '\0';

        do { } while ( 0 )



                                           ;

        a++;
      }

      do { } while ( 0 );

      ns = mmvar->namedstyle;
      for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )
      {
        if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(4L + 4L * fvar_head.axisCount) ))) ) != 0 ) )
          goto Exit;

        ns->strid = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
        (void) ( (FT_UShort)FT_Stream_GetUShort( stream ) );

        for ( j = 0; j < fvar_head.axisCount; j++ )
          ns->coords[j] = ( (FT_Long)FT_Stream_GetULong( stream ) );

        (FT_Stream_ExitFrame( stream ));
      }
    }



    if ( master != ((void *)0) )
    {
      FT_UInt n;


      if ( ( ((mmvar) = (ft_mem_alloc( memory, (FT_Long)(face->blend->mmvar_len), &error ))), error != 0 ) )
        goto Exit;
      memcpy( mmvar, face->blend->mmvar, (FT_Offset)(face->blend->mmvar_len) );

      mmvar->axis =
        (FT_Var_Axis*)&( mmvar[1] );
      mmvar->namedstyle =
        (FT_Var_Named_Style*)&( mmvar->axis[mmvar->num_axis] );
      next_coords =
        (FT_Fixed*)&( mmvar->namedstyle[mmvar->num_namedstyles] );

      for ( n = 0; n < mmvar->num_namedstyles; n++ )
      {
        mmvar->namedstyle[n].coords = next_coords;
        next_coords += mmvar->num_axis;
      }

      a = mmvar->axis;
      next_name = (FT_String*)next_coords;
      for ( n = 0; n < mmvar->num_axis; n++ )
      {
        a->name = next_name;


        if ( a->tag == (FT_Tag) ( ( (FT_ULong)'w' << 24 ) | ( (FT_ULong)'g' << 16 ) | ( (FT_ULong)'h' << 8 ) | (FT_ULong)'t' ) )
          a->name = (char*)"Weight";
        else if ( a->tag == (FT_Tag) ( ( (FT_ULong)'w' << 24 ) | ( (FT_ULong)'d' << 16 ) | ( (FT_ULong)'t' << 8 ) | (FT_ULong)'h' ) )
          a->name = (char*)"Width";
        else if ( a->tag == (FT_Tag) ( ( (FT_ULong)'o' << 24 ) | ( (FT_ULong)'p' << 16 ) | ( (FT_ULong)'s' << 8 ) | (FT_ULong)'z' ) )
          a->name = (char*)"OpticalSize";
        else if ( a->tag == (FT_Tag) ( ( (FT_ULong)'s' << 24 ) | ( (FT_ULong)'l' << 16 ) | ( (FT_ULong)'n' << 8 ) | (FT_ULong)'t' ) )
          a->name = (char*)"Slant";

        next_name += 5;
        a++;
      }

      *master = mmvar;
    }

  Exit:
    return error;
  }
# 1027 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Set_MM_Blend( TT_Face face,
                   FT_UInt num_coords,
                   FT_Fixed* coords )
  {
    FT_Error error = FT_Err_Ok;
    GX_Blend blend;
    FT_MM_Var* mmvar;
    FT_UInt i;
    FT_Memory memory = face->root.memory;

    enum
    {
      mcvt_retain,
      mcvt_modify,
      mcvt_load

    } manageCvt;


    face->doblend = 0;

    if ( face->blend == ((void *)0) )
    {
      if ( ( error = TT_Get_MM_Var( face, ((void *)0) ) ) != 0 )
        goto Exit;
    }

    blend = face->blend;
    mmvar = blend->mmvar;

    if ( num_coords > mmvar->num_axis )
    {
      do { } while ( 0 )
                                                ;
      num_coords = mmvar->num_axis;
    }

    do { } while ( 0 );

    for ( i = 0; i < num_coords; i++ )
    {
      do { } while ( 0 );
      if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
      {
        do { } while ( 0 )

                                          ;
        error = TT_Err_Invalid_Argument;
        goto Exit;
      }
    }

    do { } while ( 0 );

    if ( blend->glyphoffsets == ((void *)0) )
      if ( ( error = ft_var_load_gvar( face ) ) != 0 )
        goto Exit;

    if ( blend->normalizedcoords == ((void *)0) )
    {
      if ( ( ((blend->normalizedcoords) = (ft_mem_realloc( memory, sizeof ( *(blend->normalizedcoords) ), 0, (FT_Long)(mmvar->num_axis), ((void *)0), &error ))), error != 0 ) )
        goto Exit;

      manageCvt = mcvt_modify;




    }
    else
    {
      manageCvt = mcvt_retain;

      for ( i = 0; i < num_coords; i++ )
      {
        if ( blend->normalizedcoords[i] != coords[i] )
        {
          manageCvt = mcvt_load;
          break;
        }
      }

      for ( ; i < mmvar->num_axis; i++ )
      {
        if ( blend->normalizedcoords[i] != 0 )
        {
          manageCvt = mcvt_load;
          break;
        }
      }





    }

    blend->num_axis = mmvar->num_axis;
    memcpy( blend->normalizedcoords, coords, (FT_Offset)(num_coords * sizeof ( FT_Fixed )) )

                                                   ;

    face->doblend = 1;

    if ( face->cvt != ((void *)0) )
    {
      switch ( manageCvt )
      {
      case mcvt_load:


        do { ft_mem_free( memory, (face->cvt) ); (face->cvt) = ((void *)0); } while ( 0 );
        face->cvt = ((void *)0);

        error = tt_face_load_cvt( face, face->root.stream );
        break;

      case mcvt_modify:


        error = tt_face_vary_cvt( face, face->root.stream );
        break;

      case mcvt_retain:

        break;
      }
    }

  Exit:
    return error;
  }
# 1187 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Set_Var_Design( TT_Face face,
                     FT_UInt num_coords,
                     FT_Fixed* coords )
  {
    FT_Error error = FT_Err_Ok;
    FT_Fixed* normalized = ((void *)0);
    GX_Blend blend;
    FT_MM_Var* mmvar;
    FT_UInt i, j;
    FT_Var_Axis* a;
    GX_AVarSegment av;
    FT_Memory memory = face->root.memory;


    if ( face->blend == ((void *)0) )
    {
      if ( ( error = TT_Get_MM_Var( face, ((void *)0) ) ) != 0 )
        goto Exit;
    }

    blend = face->blend;
    mmvar = blend->mmvar;

    if ( num_coords > mmvar->num_axis )
    {
      do { } while ( 0 )

                                                ;
      num_coords = mmvar->num_axis;
    }





    if ( ( ((normalized) = (ft_mem_realloc( memory, sizeof ( *(normalized) ), 0, (FT_Long)(mmvar->num_axis), ((void *)0), &error ))), error != 0 ) )
      goto Exit;

    do { } while ( 0 );

    a = mmvar->axis;
    for ( i = 0; i < num_coords; i++, a++ )
    {
      do { } while ( 0 );
      if ( coords[i] > a->maximum || coords[i] < a->minimum )
      {
        do { } while ( 0 )



                                           ;
        error = TT_Err_Invalid_Argument;
        goto Exit;
      }

      if ( coords[i] < a->def )
        normalized[i] = -FT_DivFix( coords[i] - a->def,
                                    a->minimum - a->def );
      else if ( a->maximum == a->def )
        normalized[i] = 0;
      else
        normalized[i] = FT_DivFix( coords[i] - a->def,
                                   a->maximum - a->def );
    }

    do { } while ( 0 );

    for ( ; i < mmvar->num_axis; i++ )
      normalized[i] = 0;

    if ( !blend->avar_checked )
      ft_var_load_avar( face );

    if ( blend->avar_segment != ((void *)0) )
    {
      do { } while ( 0 )
                                                      ;

      av = blend->avar_segment;
      for ( i = 0; i < mmvar->num_axis; i++, av++ )
      {
        for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
        {
          do { } while ( 0 );
          if ( normalized[i] < av->correspondence[j].fromCoord )
          {
            normalized[i] =
              FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,
                         av->correspondence[j].toCoord -
                           av->correspondence[j - 1].toCoord,
                         av->correspondence[j].fromCoord -
                           av->correspondence[j - 1].fromCoord ) +
              av->correspondence[j - 1].toCoord;
            break;
          }
        }
      }
    }

    error = TT_Set_MM_Blend( face, mmvar->num_axis, normalized );

  Exit:
    do { ft_mem_free( memory, (normalized) ); (normalized) = ((void *)0); } while ( 0 );
    return error;
  }
# 1325 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  tt_face_vary_cvt( TT_Face face,
                    FT_Stream stream )
  {
    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_ULong table_start;
    FT_ULong table_len;
    FT_UInt tupleCount;
    FT_ULong offsetToData;
    FT_ULong here;
    FT_UInt i, j;
    FT_Fixed* tuple_coords = ((void *)0);
    FT_Fixed* im_start_coords = ((void *)0);
    FT_Fixed* im_end_coords = ((void *)0);
    GX_Blend blend = face->blend;
    FT_UInt point_count;
    FT_UShort* localpoints;
    FT_Short* deltas;


    do { } while ( 0 );

    if ( blend == ((void *)0) )
    {
      do { } while ( 0 )
                                                             ;
      error = FT_Err_Ok;
      goto Exit;
    }

    if ( face->cvt == ((void *)0) )
    {
      do { } while ( 0 )
                                                          ;
      error = FT_Err_Ok;
      goto Exit;
    }

    error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'c' << 24 ) | ( (FT_ULong)'v' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'r' ), stream, &table_len );
    if ( error )
    {
      do { } while ( 0 );

      error = FT_Err_Ok;
      goto Exit;
    }

    if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(table_len) ))) ) != 0 ) )
    {
      error = FT_Err_Ok;
      goto Exit;
    }

    table_start = (FT_ULong)( (stream)->cursor - (stream)->base );
    if ( ( (FT_Long)FT_Stream_GetULong( stream ) ) != 0x00010000L )
    {
      do { } while ( 0 );

      error = FT_Err_Ok;
      goto FExit;
    }

    do { } while ( 0 );

    if ( ( ((tuple_coords) = (ft_mem_realloc( memory, sizeof ( *(tuple_coords) ), 0, (FT_Long)(blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_start_coords) = (ft_mem_realloc( memory, sizeof ( *(im_start_coords) ), 0, (FT_Long)(blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_end_coords) = (ft_mem_realloc( memory, sizeof ( *(im_end_coords) ), 0, (FT_Long)(blend->num_axis), ((void *)0), &error ))), error != 0 ) )
      goto FExit;

    tupleCount = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
    offsetToData = ( (FT_UShort)FT_Stream_GetUShort( stream ) );


    if ( offsetToData + tupleCount * 4 > table_len )
    {
      do { } while ( 0 )
                                                            ;

      error = TT_Err_Invalid_Table;
      goto FExit;
    }

    offsetToData += table_start;





    do { } while ( 0 );

    for ( i = 0; i < ( tupleCount & 0xFFF ); i++ )
    {
      FT_UInt tupleDataSize;
      FT_UInt tupleIndex;
      FT_Fixed apply;


      do { } while ( 0 );

      tupleDataSize = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
      tupleIndex = ( (FT_UShort)FT_Stream_GetUShort( stream ) );




      if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
      {
        for ( j = 0; j < blend->num_axis; j++ )
          tuple_coords[j] = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;

      }
      else
      {


        if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
          for ( j = 0; j < 2 * blend->num_axis; j++ )
            (void)( (FT_Short)FT_Stream_GetUShort( stream ) );

        offsetToData += tupleDataSize;
        continue;
      }

      if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
      {
        for ( j = 0; j < blend->num_axis; j++ )
          im_start_coords[j] = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;
        for ( j = 0; j < blend->num_axis; j++ )
          im_end_coords[j] = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;
      }

      apply = ft_var_apply_tuple( blend,
                                  (FT_UShort)tupleIndex,
                                  tuple_coords,
                                  im_start_coords,
                                  im_end_coords );
      if (
           apply == 0 ||


           !( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS ) )
      {
        offsetToData += tupleDataSize;
        continue;
      }

      here = (FT_ULong)( (stream)->cursor - (stream)->base );

      ( (stream)->cursor = (stream)->base + (offsetToData) );

      localpoints = ft_var_readpackedpoints( stream,
                                             table_len,
                                             &point_count );
      deltas = ft_var_readpackeddeltas( stream,
                                             table_len,
                                             point_count == 0 ? face->cvt_size
                                                              : point_count );
      if ( localpoints == ((void *)0) || deltas == ((void *)0) )
        ;

      else if ( localpoints == (FT_UShort*)~(FT_PtrDist)0 )
      {





        do { } while ( 0 );


        for ( j = 0; j < face->cvt_size; j++ )
        {
          FT_Long orig_cvt = face->cvt[j];


          face->cvt[j] = (FT_Short)( orig_cvt +
                                     FT_MulFix_arm( (FT_Int32)(deltas[j]), (FT_Int32)(apply) ) );
# 1512 "../../../libs/freetype/src/truetype/ttgxvar.c"
        }





      }

      else
      {





        do { } while ( 0 );

        for ( j = 0; j < point_count; j++ )
        {
          int pindex = localpoints[j];
          FT_Long orig_cvt = face->cvt[pindex];


          face->cvt[pindex] = (FT_Short)( orig_cvt +
                                          FT_MulFix_arm( (FT_Int32)(deltas[j]), (FT_Int32)(apply) ) );
# 1546 "../../../libs/freetype/src/truetype/ttgxvar.c"
        }





      }

      if ( localpoints != (FT_UShort*)~(FT_PtrDist)0 )
        do { ft_mem_free( memory, (localpoints) ); (localpoints) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (deltas) ); (deltas) = ((void *)0); } while ( 0 );

      offsetToData += tupleDataSize;

      ( (stream)->cursor = (stream)->base + (here) );
    }

    do { } while ( 0 );

  FExit:
    (FT_Stream_ExitFrame( stream ));

  Exit:
    do { ft_mem_free( memory, (tuple_coords) ); (tuple_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_start_coords) ); (im_start_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_end_coords) ); (im_end_coords) = ((void *)0); } while ( 0 );

    return error;
  }







  static void
  tt_delta_shift( int p1,
                  int p2,
                  int ref,
                  FT_Vector* in_points,
                  FT_Vector* out_points )
  {
    int p;
    FT_Vector delta;


    delta.x = out_points[ref].x - in_points[ref].x;
    delta.y = out_points[ref].y - in_points[ref].y;

    if ( delta.x == 0 && delta.y == 0 )
      return;

    for ( p = p1; p < ref; p++ )
    {
      out_points[p].x += delta.x;
      out_points[p].y += delta.y;
    }

    for ( p = ref + 1; p <= p2; p++ )
    {
      out_points[p].x += delta.x;
      out_points[p].y += delta.y;
    }
  }
# 1620 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static void
  tt_delta_interpolate( int p1,
                        int p2,
                        int ref1,
                        int ref2,
                        FT_Vector* in_points,
                        FT_Vector* out_points )
  {
    int p, i;

    FT_Pos out, in1, in2, out1, out2, d1, d2;


    if ( p1 > p2 )
      return;


    for ( i = 0; i <= 1; i++ )
    {

      in_points = (FT_Vector*)( (FT_Pos*)in_points + i );
      out_points = (FT_Vector*)( (FT_Pos*)out_points + i );

      if ( in_points[ref1].x > in_points[ref2].x )
      {
        p = ref1;
        ref1 = ref2;
        ref2 = p;
      }

      in1 = in_points[ref1].x;
      in2 = in_points[ref2].x;
      out1 = out_points[ref1].x;
      out2 = out_points[ref2].x;
      d1 = out1 - in1;
      d2 = out2 - in2;

      if ( out1 == out2 || in1 == in2 )
      {
        for ( p = p1; p <= p2; p++ )
        {
          out = in_points[p].x;

          if ( out <= in1 )
            out += d1;
          else if ( out >= in2 )
            out += d2;
          else
            out = out1;

          out_points[p].x = out;
        }
      }
      else
      {
        FT_Fixed scale = FT_DivFix( out2 - out1, in2 - in1 );


        for ( p = p1; p <= p2; p++ )
        {
          out = in_points[p].x;

          if ( out <= in1 )
            out += d1;
          else if ( out >= in2 )
            out += d2;
          else
            out = out1 + FT_MulFix_arm( (FT_Int32)(out - in1), (FT_Int32)(scale) );

          out_points[p].x = out;
        }
      }
    }
  }







  static void
  tt_handle_deltas( FT_Outline* outline,
                    FT_Vector* in_points,
                    FT_Bool* has_delta )
  {
    FT_Vector* out_points;

    FT_Int first_point;
    FT_Int end_point;

    FT_Int first_delta;
    FT_Int cur_delta;

    FT_Int point;
    FT_Short contour;



    if ( !outline->n_contours )
      return;

    out_points = outline->points;

    contour = 0;
    point = 0;

    do
    {
      end_point = outline->contours[contour];
      first_point = point;


      while ( point <= end_point && !has_delta[point] )
        point++;

      if ( point <= end_point )
      {
        first_delta = point;
        cur_delta = point;

        point++;

        while ( point <= end_point )
        {


          if ( has_delta[point] )
          {
            tt_delta_interpolate( cur_delta + 1,
                                  point - 1,
                                  cur_delta,
                                  point,
                                  in_points,
                                  out_points );
            cur_delta = point;
          }

          point++;
        }


        if ( cur_delta == first_delta )
          tt_delta_shift( first_point,
                          end_point,
                          cur_delta,
                          in_points,
                          out_points );
        else
        {


          tt_delta_interpolate( cur_delta + 1,
                                end_point,
                                cur_delta,
                                first_delta,
                                in_points,
                                out_points );

          if ( first_delta > 0 )
            tt_delta_interpolate( first_point,
                                  first_delta - 1,
                                  cur_delta,
                                  first_delta,
                                  in_points,
                                  out_points );
        }
      }
      contour++;

    } while ( contour < outline->n_contours );
  }
# 1816 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static FT_Error
  TT_Vary_Apply_Glyph_Deltas( TT_Face face,
                              FT_UInt glyph_index,
                              FT_Outline* outline,
                              FT_UInt n_points )
  {
    FT_Stream stream = face->root.stream;
    FT_Memory memory = stream->memory;
    GX_Blend blend = face->blend;

    FT_Vector* points_org = ((void *)0);
    FT_Bool* has_delta = ((void *)0);

    FT_Error error;
    FT_ULong glyph_start;
    FT_UInt tupleCount;
    FT_ULong offsetToData;
    FT_ULong here;
    FT_UInt i, j;
    FT_Fixed* tuple_coords = ((void *)0);
    FT_Fixed* im_start_coords = ((void *)0);
    FT_Fixed* im_end_coords = ((void *)0);
    FT_UInt point_count, spoint_count = 0;
    FT_UShort* sharedpoints = ((void *)0);
    FT_UShort* localpoints = ((void *)0);
    FT_UShort* points;
    FT_Short *deltas_x, *deltas_y;


    if ( !face->doblend || blend == ((void *)0) )
      return TT_Err_Invalid_Argument;

    if ( glyph_index >= blend->gv_glyphcnt ||
         blend->glyphoffsets[glyph_index] ==
           blend->glyphoffsets[glyph_index + 1] )
    {
      do { } while ( 0 )
                                                          ;
      return FT_Err_Ok;
    }

    if ( ( ((points_org) = (ft_mem_realloc( memory, sizeof ( *(points_org) ), 0, (FT_Long)(n_points), ((void *)0), &error ))), error != 0 ) ||
         ( ((has_delta) = (ft_mem_realloc( memory, sizeof ( *(has_delta) ), 0, (FT_Long)(n_points), ((void *)0), &error ))), error != 0 ) )
      goto Fail1;

    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(blend->glyphoffsets[glyph_index]) )) ) != 0 ) ||
         ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(blend->glyphoffsets[glyph_index + 1] - blend->glyphoffsets[glyph_index]) ))) ) != 0 )
                                                              )
      goto Fail1;

    glyph_start = (FT_ULong)( (stream)->cursor - (stream)->base );




    if ( ( ((tuple_coords) = (ft_mem_realloc( memory, sizeof ( *(tuple_coords) ), 0, (FT_Long)(blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_start_coords) = (ft_mem_realloc( memory, sizeof ( *(im_start_coords) ), 0, (FT_Long)(blend->num_axis), ((void *)0), &error ))), error != 0 ) ||
         ( ((im_end_coords) = (ft_mem_realloc( memory, sizeof ( *(im_end_coords) ), 0, (FT_Long)(blend->num_axis), ((void *)0), &error ))), error != 0 ) )
      goto Fail2;

    tupleCount = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
    offsetToData = ( (FT_UShort)FT_Stream_GetUShort( stream ) );


    if ( offsetToData + tupleCount * 4 > blend->gvar_size )
    {
      do { } while ( 0 )
                                                              ;

      error = TT_Err_Invalid_Table;
      goto Fail2;
    }

    offsetToData += glyph_start;

    if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
    {
      here = (FT_ULong)( (stream)->cursor - (stream)->base );

      ( (stream)->cursor = (stream)->base + (offsetToData) );

      sharedpoints = ft_var_readpackedpoints( stream,
                                              blend->gvar_size,
                                              &spoint_count );
      offsetToData = (FT_ULong)( (stream)->cursor - (stream)->base );

      ( (stream)->cursor = (stream)->base + (here) );
    }

    do { } while ( 0 )
                                                      ;

    for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); i++ )
    {
      FT_UInt tupleDataSize;
      FT_UInt tupleIndex;
      FT_Fixed apply;


      do { } while ( 0 );

      tupleDataSize = ( (FT_UShort)FT_Stream_GetUShort( stream ) );
      tupleIndex = ( (FT_UShort)FT_Stream_GetUShort( stream ) );

      if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
      {
        for ( j = 0; j < blend->num_axis; j++ )
          tuple_coords[j] = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;

      }
      else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
      {
        do { } while ( 0 )
                                               ;

        error = TT_Err_Invalid_Table;
        goto Fail2;
      }
      else
        memcpy( tuple_coords, &blend->tuplecoords[( tupleIndex & 0xFFF ) * blend->num_axis], (FT_Offset)(blend->num_axis * sizeof ( FT_Fixed )) )


                                                 ;

      if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
      {
        for ( j = 0; j < blend->num_axis; j++ )
          im_start_coords[j] = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;
        for ( j = 0; j < blend->num_axis; j++ )
          im_end_coords[j] = ( (FT_Short)FT_Stream_GetUShort( stream ) ) * 4;
      }

      apply = ft_var_apply_tuple( blend,
                                  (FT_UShort)tupleIndex,
                                  tuple_coords,
                                  im_start_coords,
                                  im_end_coords );

      if ( apply == 0 )
      {
        offsetToData += tupleDataSize;
        continue;
      }

      here = (FT_ULong)( (stream)->cursor - (stream)->base );

      if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
      {
        ( (stream)->cursor = (stream)->base + (offsetToData) );

        localpoints = ft_var_readpackedpoints( stream,
                                               blend->gvar_size,
                                               &point_count );
        points = localpoints;
      }
      else
      {
        points = sharedpoints;
        point_count = spoint_count;
      }

      deltas_x = ft_var_readpackeddeltas( stream,
                                          blend->gvar_size,
                                          point_count == 0 ? n_points
                                                           : point_count );
      deltas_y = ft_var_readpackeddeltas( stream,
                                          blend->gvar_size,
                                          point_count == 0 ? n_points
                                                           : point_count );

      if ( points == ((void *)0) || deltas_y == ((void *)0) || deltas_x == ((void *)0) )
        ;

      else if ( points == (FT_UShort*)~(FT_PtrDist)0 )
      {





        do { } while ( 0 );


        for ( j = 0; j < n_points; j++ )
        {





          outline->points[j].x += FT_MulFix_arm( (FT_Int32)(deltas_x[j]), (FT_Int32)(apply) );
          outline->points[j].y += FT_MulFix_arm( (FT_Int32)(deltas_y[j]), (FT_Int32)(apply) );
# 2022 "../../../libs/freetype/src/truetype/ttgxvar.c"
        }





      }

      else if ( localpoints == ((void *)0) )
        ;

      else
      {







        for ( j = 0; j < n_points; j++ )
        {
          points_org[j] = outline->points[j];
          has_delta[j] = 0;
        }

        for ( j = 0; j < point_count; j++ )
        {
          FT_UShort idx = localpoints[j];


          if ( idx >= n_points )
            continue;

          has_delta[idx] = 1;

          outline->points[idx].x += FT_MulFix_arm( (FT_Int32)(deltas_x[j]), (FT_Int32)(apply) );
          outline->points[idx].y += FT_MulFix_arm( (FT_Int32)(deltas_y[j]), (FT_Int32)(apply) );
        }



        tt_handle_deltas( outline,
                          points_org,
                          has_delta );
# 2089 "../../../libs/freetype/src/truetype/ttgxvar.c"
      }

      if ( localpoints != (FT_UShort*)~(FT_PtrDist)0 )
        do { ft_mem_free( memory, (localpoints) ); (localpoints) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (deltas_x) ); (deltas_x) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (deltas_y) ); (deltas_y) = ((void *)0); } while ( 0 );

      offsetToData += tupleDataSize;

      ( (stream)->cursor = (stream)->base + (here) );
    }

    do { } while ( 0 );

  Fail2:
    if ( sharedpoints != (FT_UShort*)~(FT_PtrDist)0 )
      do { ft_mem_free( memory, (sharedpoints) ); (sharedpoints) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (tuple_coords) ); (tuple_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_start_coords) ); (im_start_coords) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (im_end_coords) ); (im_end_coords) = ((void *)0); } while ( 0 );

    (FT_Stream_ExitFrame( stream ));

  Fail1:
    do { ft_mem_free( memory, (points_org) ); (points_org) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (has_delta) ); (has_delta) = ((void *)0); } while ( 0 );

    return error;
  }
# 2128 "../../../libs/freetype/src/truetype/ttgxvar.c"
  static void
  tt_done_blend( FT_Memory memory,
                 GX_Blend blend )
  {
    if ( blend != ((void *)0) )
    {
      FT_UInt i;


      do { ft_mem_free( memory, (blend->normalizedcoords) ); (blend->normalizedcoords) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (blend->mmvar) ); (blend->mmvar) = ((void *)0); } while ( 0 );

      if ( blend->avar_segment != ((void *)0) )
      {
        for ( i = 0; i < blend->num_axis; i++ )
          do { ft_mem_free( memory, (blend->avar_segment[i].correspondence) ); (blend->avar_segment[i].correspondence) = ((void *)0); } while ( 0 );
        do { ft_mem_free( memory, (blend->avar_segment) ); (blend->avar_segment) = ((void *)0); } while ( 0 );
      }

      do { ft_mem_free( memory, (blend->tuplecoords) ); (blend->tuplecoords) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (blend->glyphoffsets) ); (blend->glyphoffsets) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (blend) ); (blend) = ((void *)0); } while ( 0 );
    }
  }
# 35 "../../../libs/freetype/src/truetype/truetype.c" 2
