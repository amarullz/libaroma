# 1 "../../../libs/freetype/src/cff/cff.c"
# 1 "<command-line>"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "../../../libs/freetype/src/cff/cff.c"
# 21 "../../../libs/freetype/src/cff/cff.c"
# 1 "../../../libs/freetype/include/ft2build.h" 1
# 37 "../../../libs/freetype/include/ft2build.h"
# 1 "../../../libs/freetype/include/freetype/config/ftheader.h" 1
# 827 "../../../libs/freetype/include/freetype/config/ftheader.h"
# 1 "../../../libs/freetype/include/freetype/internal/internal.h" 1
# 828 "../../../libs/freetype/include/freetype/config/ftheader.h" 2
# 38 "../../../libs/freetype/include/ft2build.h" 2
# 22 "../../../libs/freetype/src/cff/cff.c" 2

# 1 "../../../libs/freetype/src/cff/cffpic.c" 1
# 20 "../../../libs/freetype/src/cff/cffpic.c"
# 1 "../../../libs/freetype/include/freetype/freetype.h" 1
# 33 "../../../libs/freetype/include/freetype/freetype.h"
# 1 "../../../libs/freetype/include/freetype/config/ftconfig.h" 1
# 42 "../../../libs/freetype/include/freetype/config/ftconfig.h"
# 1 "../../../libs/freetype/include/freetype/config/ftoption.h" 1
# 26 "../../../libs/freetype/include/freetype/config/ftoption.h"

# 896 "../../../libs/freetype/include/freetype/config/ftoption.h"

# 43 "../../../libs/freetype/include/freetype/config/ftconfig.h" 2
# 1 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 1
# 36 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 147 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 212 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 324 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef unsigned int wchar_t;
# 37 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 60 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 1 3 4
# 34 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\syslimits.h" 1 3 4






# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 1 3 4
# 168 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 1 3 4
# 25 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 1 3 4
# 378 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 1 3 4
# 385 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 386 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 2 3 4
# 379 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 2 3 4
# 402 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 1 3 4
# 10 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs-hard.h" 1 3 4
# 11 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 2 3 4
# 403 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 2 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4
# 143 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 1 3 4
# 160 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 1 3 4
# 38 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\linux\\limits.h" 1 3 4
# 39 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 2 3 4
# 161 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 2 3 4
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4



# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix2_lim.h" 1 3 4
# 148 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4
# 169 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 2 3 4
# 8 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\syslimits.h" 2 3 4
# 35 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 2 3 4
# 61 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 78 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4





# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 2 3 4
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 127 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\xlocale.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 164 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4

# 236 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 282 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 427 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 445 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 534 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 644 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4

# 79 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 102 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 1 3 4
# 29 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4




# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4

# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 28 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 121 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\typesizes.h" 1 3 4
# 122 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;


__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t;


__extension__ typedef long int __syscall_slong_t;

__extension__ typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 36 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 1 3 4
# 15 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 16 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 2 3 4




# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\wchar.h" 1 3 4
# 82 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 2 3 4
# 49 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 1 3 4
# 40 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 2 3 4
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
  __off64_t _offset;
# 302 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef __off_t off_t;
# 102 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;




# 164 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\stdio_lim.h" 1 3 4
# 165 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 306 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 665 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 824 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sys_errlist.h" 1 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 913 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 103 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 120 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 1 3 4
# 32 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4








# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitflags.h" 1 3 4
# 42 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 1 3 4
# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 1 3 4
# 36 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\endian.h" 1 3 4
# 37 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 2 3 4
# 60 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 1 3 4
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap-16.h" 1 3 4
# 35 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 2 3 4
# 43 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 74 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 2 3 4
# 65 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 67 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __daddr_t daddr_t;

typedef __caddr_t caddr_t;







typedef __key_t key_t;
# 135 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 1 3 4
# 57 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4


typedef __clock_t clock_t;



# 73 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4


typedef __time_t time_t;



# 91 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
typedef __timer_t timer_t;
# 136 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4
# 149 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 150 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 197 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 222 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 1 3 4
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\select.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 1 3 4
# 22 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 1 3 4
# 120 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4

# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\time.h" 1 3 4
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4

# 106 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4

# 223 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 1 3 4
# 24 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 3 4

# 226 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 1 3 4
# 37 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 3 4
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;

    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 274 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4



# 315 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 1 3 4
# 24 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 25 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 513 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 530 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4





extern int system (const char *__command) ;

# 734 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 752 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 812 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 899 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 951 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\stdlib-float.h" 1 3 4
# 956 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 968 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4

# 121 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 198 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\setjmp.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\setjmp.h" 3 4
typedef int __jmp_buf[64] __attribute__((__aligned__ (8)));
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));










extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 102 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 112 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4

# 199 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 211 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 1 3 4
# 212 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 44 "../../../libs/freetype/include/freetype/config/ftconfig.h" 2



# 162 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef signed short FT_Int16;
# 173 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef unsigned short FT_UInt16;
# 233 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef signed int FT_Int32;
  typedef unsigned int FT_UInt32;
# 249 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef int FT_Fast;
  typedef unsigned int FT_UFast;
# 461 "../../../libs/freetype/include/freetype/config/ftconfig.h"

# 34 "../../../libs/freetype/include/freetype/freetype.h" 2
# 1 "../../../libs/freetype/include/freetype/fttypes.h" 1
# 25 "../../../libs/freetype/include/freetype/fttypes.h"
# 1 "../../../libs/freetype/include/freetype/ftsystem.h" 1
# 26 "../../../libs/freetype/include/freetype/ftsystem.h"

# 66 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_MemoryRec_* FT_Memory;
# 88 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void*
  (*FT_Alloc_Func)( FT_Memory memory,
                    long size );
# 109 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void
  (*FT_Free_Func)( FT_Memory memory,
                   void* block );
# 142 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void*
  (*FT_Realloc_Func)( FT_Memory memory,
                      long cur_size,
                      long new_size,
                      void* block );
# 171 "../../../libs/freetype/include/freetype/ftsystem.h"
  struct FT_MemoryRec_
  {
    void* user;
    FT_Alloc_Func alloc;
    FT_Free_Func free;
    FT_Realloc_Func realloc;
  };
# 200 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_* FT_Stream;
# 213 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef union FT_StreamDesc_
  {
    long value;
    void* pointer;

  } FT_StreamDesc;
# 251 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream stream,
                       unsigned long offset,
                       unsigned char* buffer,
                       unsigned long count );
# 271 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream stream );
# 330 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_
  {
    unsigned char* base;
    unsigned long size;
    unsigned long pos;

    FT_StreamDesc descriptor;
    FT_StreamDesc pathname;
    FT_Stream_IoFunc read;
    FT_Stream_CloseFunc close;

    FT_Memory memory;
    unsigned char* cursor;
    unsigned char* limit;

  } FT_StreamRec;





# 26 "../../../libs/freetype/include/freetype/fttypes.h" 2
# 1 "../../../libs/freetype/include/freetype/ftimage.h" 1
# 37 "../../../libs/freetype/include/freetype/ftimage.h"

# 58 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef signed long FT_Pos;
# 74 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Vector_
  {
    FT_Pos x;
    FT_Pos y;

  } FT_Vector;
# 115 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_BBox_
  {
    FT_Pos xMin, yMin;
    FT_Pos xMax, yMax;

  } FT_BBox;
# 180 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef enum FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,

    FT_PIXEL_MODE_MAX

  } FT_Pixel_Mode;
# 261 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Bitmap_
  {
    unsigned int rows;
    unsigned int width;
    int pitch;
    unsigned char* buffer;
    unsigned short num_grays;
    unsigned char pixel_mode;
    unsigned char palette_mode;
    void* palette;

  } FT_Bitmap;
# 334 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_
  {
    short n_contours;
    short n_points;

    FT_Vector* points;
    char* tags;
    short* contours;

    int flags;

  } FT_Outline;
# 492 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector* to,
                            void* user );
# 519 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector* to,
                            void* user );
# 550 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector* control,
                             const FT_Vector* to,
                             void* user );
# 582 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector* control1,
                             const FT_Vector* control2,
                             const FT_Vector* to,
                             void* user );
# 628 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc move_to;
    FT_Outline_LineToFunc line_to;
    FT_Outline_ConicToFunc conic_to;
    FT_Outline_CubicToFunc cubic_to;

    int shift;
    FT_Pos delta;

  } FT_Outline_Funcs;
# 715 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef enum FT_Glyph_Format_
  {
    FT_GLYPH_FORMAT_NONE = ( ( (unsigned long)0 << 24 ) | ( (unsigned long)0 << 16 ) | ( (unsigned long)0 << 8 ) | (unsigned long)0 ),

    FT_GLYPH_FORMAT_COMPOSITE = ( ( (unsigned long)'c' << 24 ) | ( (unsigned long)'o' << 16 ) | ( (unsigned long)'m' << 8 ) | (unsigned long)'p' ),
    FT_GLYPH_FORMAT_BITMAP = ( ( (unsigned long)'b' << 24 ) | ( (unsigned long)'i' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'s' ),
    FT_GLYPH_FORMAT_OUTLINE = ( ( (unsigned long)'o' << 24 ) | ( (unsigned long)'u' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'l' ),
    FT_GLYPH_FORMAT_PLOTTER = ( ( (unsigned long)'p' << 24 ) | ( (unsigned long)'l' << 16 ) | ( (unsigned long)'o' << 8 ) | (unsigned long)'t' )

  } FT_Glyph_Format;
# 800 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_RasterRec_* FT_Raster;
# 828 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Span_
  {
    short x;
    unsigned short len;
    unsigned char coverage;

  } FT_Span;
# 873 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_SpanFunc)( int y,
                  int count,
                  const FT_Span* spans,
                  void* user );
# 890 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_BitTest_Func)( int y,
                             int x,
                             void* user );
# 904 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_BitSet_Func)( int y,
                            int x,
                            void* user );
# 1007 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Params_
  {
    const FT_Bitmap* target;
    const void* source;
    int flags;
    FT_SpanFunc gray_spans;
    FT_SpanFunc black_spans;
    FT_Raster_BitTest_Func bit_test;
    FT_Raster_BitSet_Func bit_set;
    void* user;
    FT_BBox clip_box;

  } FT_Raster_Params;
# 1046 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_NewFunc)( void* memory,
                        FT_Raster* raster );
# 1064 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster raster );
# 1096 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster raster,
                          unsigned char* pool_base,
                          unsigned long pool_size );
# 1122 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster raster,
                            unsigned long mode,
                            void* args );
# 1164 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster raster,
                           const FT_Raster_Params* params );
# 1190 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Funcs_
  {
    FT_Glyph_Format glyph_format;
    FT_Raster_NewFunc raster_new;
    FT_Raster_ResetFunc raster_reset;
    FT_Raster_SetModeFunc raster_set_mode;
    FT_Raster_RenderFunc raster_render;
    FT_Raster_DoneFunc raster_done;

  } FT_Raster_Funcs;





# 27 "../../../libs/freetype/include/freetype/fttypes.h" 2

# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 29 "../../../libs/freetype/include/freetype/fttypes.h" 2



# 108 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Bool;
# 120 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_FWord;
# 132 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UFWord;
# 143 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed char FT_Char;
# 154 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Byte;
# 165 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef const FT_Byte* FT_Bytes;
# 176 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef FT_UInt32 FT_Tag;
# 187 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef char FT_String;
# 198 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_Short;
# 209 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UShort;
# 220 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed int FT_Int;
# 231 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned int FT_UInt;
# 242 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Long;
# 253 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned long FT_ULong;
# 264 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_F2Dot14;
# 276 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_F26Dot6;
# 288 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Fixed;
# 300 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef int FT_Error;
# 311 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef void* FT_Pointer;
# 324 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef size_t FT_Offset;
# 337 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef ptrdiff_t FT_PtrDist;
# 354 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_UnitVector_
  {
    FT_F2Dot14 x;
    FT_F2Dot14 y;

  } FT_UnitVector;
# 385 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Matrix_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;

  } FT_Matrix;
# 406 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Data_
  {
    const FT_Byte* pointer;
    FT_Int length;

  } FT_Data;
# 428 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef void (*FT_Generic_Finalizer)(void* object);
# 459 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Generic_
  {
    void* data;
    FT_Generic_Finalizer finalizer;

  } FT_Generic;
# 515 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_* FT_ListNode;
# 526 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_* FT_List;
# 544 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_
  {
    FT_ListNode prev;
    FT_ListNode next;
    void* data;

  } FT_ListNodeRec;
# 567 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_
  {
    FT_ListNode head;
    FT_ListNode tail;

  } FT_ListRec;
# 597 "../../../libs/freetype/include/freetype/fttypes.h"

# 35 "../../../libs/freetype/include/freetype/freetype.h" 2
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 107 "../../../libs/freetype/include/freetype/fterrors.h"
# 1 "../../../libs/freetype/include/freetype/ftmoderr.h" 1
# 138 "../../../libs/freetype/include/freetype/ftmoderr.h"
  enum {



  FT_Mod_Err_Base = 0,
  FT_Mod_Err_Autofit = 0,
  FT_Mod_Err_BDF = 0,
  FT_Mod_Err_Bzip2 = 0,
  FT_Mod_Err_Cache = 0,
  FT_Mod_Err_CFF = 0,
  FT_Mod_Err_CID = 0,
  FT_Mod_Err_Gzip = 0,
  FT_Mod_Err_LZW = 0,
  FT_Mod_Err_OTvalid = 0,
  FT_Mod_Err_PCF = 0,
  FT_Mod_Err_PFR = 0,
  FT_Mod_Err_PSaux = 0,
  FT_Mod_Err_PShinter = 0,
  FT_Mod_Err_PSnames = 0,
  FT_Mod_Err_Raster = 0,
  FT_Mod_Err_SFNT = 0,
  FT_Mod_Err_Smooth = 0,
  FT_Mod_Err_TrueType = 0,
  FT_Mod_Err_Type1 = 0,
  FT_Mod_Err_Type42 = 0,
  FT_Mod_Err_Winfonts = 0,
  FT_Mod_Err_GXvalid = 0,



  FT_Mod_Err_Max };
# 108 "../../../libs/freetype/include/freetype/fterrors.h" 2
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  FT_Err_Ok = 0x00,


  FT_Err_Cannot_Open_Resource = 0x01 + 0,

  FT_Err_Unknown_File_Format = 0x02 + 0,

  FT_Err_Invalid_File_Format = 0x03 + 0,

  FT_Err_Invalid_Version = 0x04 + 0,

  FT_Err_Lower_Module_Version = 0x05 + 0,

  FT_Err_Invalid_Argument = 0x06 + 0,

  FT_Err_Unimplemented_Feature = 0x07 + 0,

  FT_Err_Invalid_Table = 0x08 + 0,

  FT_Err_Invalid_Offset = 0x09 + 0,

  FT_Err_Array_Too_Large = 0x0A + 0,

  FT_Err_Missing_Module = 0x0B + 0,

  FT_Err_Missing_Property = 0x0C + 0,




  FT_Err_Invalid_Glyph_Index = 0x10 + 0,

  FT_Err_Invalid_Character_Code = 0x11 + 0,

  FT_Err_Invalid_Glyph_Format = 0x12 + 0,

  FT_Err_Cannot_Render_Glyph = 0x13 + 0,

  FT_Err_Invalid_Outline = 0x14 + 0,

  FT_Err_Invalid_Composite = 0x15 + 0,

  FT_Err_Too_Many_Hints = 0x16 + 0,

  FT_Err_Invalid_Pixel_Size = 0x17 + 0,




  FT_Err_Invalid_Handle = 0x20 + 0,

  FT_Err_Invalid_Library_Handle = 0x21 + 0,

  FT_Err_Invalid_Driver_Handle = 0x22 + 0,

  FT_Err_Invalid_Face_Handle = 0x23 + 0,

  FT_Err_Invalid_Size_Handle = 0x24 + 0,

  FT_Err_Invalid_Slot_Handle = 0x25 + 0,

  FT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  FT_Err_Invalid_Cache_Handle = 0x27 + 0,

  FT_Err_Invalid_Stream_Handle = 0x28 + 0,




  FT_Err_Too_Many_Drivers = 0x30 + 0,

  FT_Err_Too_Many_Extensions = 0x31 + 0,




  FT_Err_Out_Of_Memory = 0x40 + 0,

  FT_Err_Unlisted_Object = 0x41 + 0,




  FT_Err_Cannot_Open_Stream = 0x51 + 0,

  FT_Err_Invalid_Stream_Seek = 0x52 + 0,

  FT_Err_Invalid_Stream_Skip = 0x53 + 0,

  FT_Err_Invalid_Stream_Read = 0x54 + 0,

  FT_Err_Invalid_Stream_Operation = 0x55 + 0,

  FT_Err_Invalid_Frame_Operation = 0x56 + 0,

  FT_Err_Nested_Frame_Access = 0x57 + 0,

  FT_Err_Invalid_Frame_Read = 0x58 + 0,




  FT_Err_Raster_Uninitialized = 0x60 + 0,

  FT_Err_Raster_Corrupted = 0x61 + 0,

  FT_Err_Raster_Overflow = 0x62 + 0,

  FT_Err_Raster_Negative_Height = 0x63 + 0,




  FT_Err_Too_Many_Caches = 0x70 + 0,




  FT_Err_Invalid_Opcode = 0x80 + 0,

  FT_Err_Too_Few_Arguments = 0x81 + 0,

  FT_Err_Stack_Overflow = 0x82 + 0,

  FT_Err_Code_Overflow = 0x83 + 0,

  FT_Err_Bad_Argument = 0x84 + 0,

  FT_Err_Divide_By_Zero = 0x85 + 0,

  FT_Err_Invalid_Reference = 0x86 + 0,

  FT_Err_Debug_OpCode = 0x87 + 0,

  FT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  FT_Err_Nested_DEFS = 0x89 + 0,

  FT_Err_Invalid_CodeRange = 0x8A + 0,

  FT_Err_Execution_Too_Long = 0x8B + 0,

  FT_Err_Too_Many_Function_Defs = 0x8C + 0,

  FT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  FT_Err_Table_Missing = 0x8E + 0,

  FT_Err_Horiz_Header_Missing = 0x8F + 0,

  FT_Err_Locations_Missing = 0x90 + 0,

  FT_Err_Name_Table_Missing = 0x91 + 0,

  FT_Err_CMap_Table_Missing = 0x92 + 0,

  FT_Err_Hmtx_Table_Missing = 0x93 + 0,

  FT_Err_Post_Table_Missing = 0x94 + 0,

  FT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  FT_Err_Invalid_CharMap_Format = 0x96 + 0,

  FT_Err_Invalid_PPem = 0x97 + 0,

  FT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  FT_Err_Could_Not_Find_Context = 0x99 + 0,

  FT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  FT_Err_Invalid_Post_Table = 0x9B + 0,




  FT_Err_Syntax_Error = 0xA0 + 0,

  FT_Err_Stack_Underflow = 0xA1 + 0,

  FT_Err_Ignore = 0xA2 + 0,

  FT_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  FT_Err_Glyph_Too_Big = 0xA4 + 0,




  FT_Err_Missing_Startfont_Field = 0xB0 + 0,

  FT_Err_Missing_Font_Field = 0xB1 + 0,

  FT_Err_Missing_Size_Field = 0xB2 + 0,

  FT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  FT_Err_Missing_Chars_Field = 0xB4 + 0,

  FT_Err_Missing_Startchar_Field = 0xB5 + 0,

  FT_Err_Missing_Encoding_Field = 0xB6 + 0,

  FT_Err_Missing_Bbx_Field = 0xB7 + 0,

  FT_Err_Bbx_Too_Big = 0xB8 + 0,

  FT_Err_Corrupted_Font_Header = 0xB9 + 0,

  FT_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  FT_Err_Max };
# 36 "../../../libs/freetype/include/freetype/freetype.h" 2



# 309 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Glyph_Metrics_
  {
    FT_Pos width;
    FT_Pos height;

    FT_Pos horiBearingX;
    FT_Pos horiBearingY;
    FT_Pos horiAdvance;

    FT_Pos vertBearingX;
    FT_Pos vertBearingY;
    FT_Pos vertAdvance;

  } FT_Glyph_Metrics;
# 363 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Bitmap_Size_
  {
    FT_Short height;
    FT_Short width;

    FT_Pos size;

    FT_Pos x_ppem;
    FT_Pos y_ppem;

  } FT_Bitmap_Size;
# 409 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_LibraryRec_ *FT_Library;
# 429 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_ModuleRec_* FT_Module;
# 441 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_DriverRec_* FT_Driver;
# 455 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_RendererRec_* FT_Renderer;
# 495 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_* FT_Face;
# 526 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_* FT_Size;
# 547 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_* FT_GlyphSlot;
# 579 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_* FT_CharMap;
# 757 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Encoding_
  {
    FT_ENCODING_NONE = ( ( (FT_UInt32)(0) << 24 ) | ( (FT_UInt32)(0) << 16 ) | ( (FT_UInt32)(0) << 8 ) | (FT_UInt32)(0) ),

    FT_ENCODING_MS_SYMBOL = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('y') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('b') ),
    FT_ENCODING_UNICODE = ( ( (FT_UInt32)('u') << 24 ) | ( (FT_UInt32)('n') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('c') ),

    FT_ENCODING_SJIS = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('j') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_GB2312 = ( ( (FT_UInt32)('g') << 24 ) | ( (FT_UInt32)('b') << 16 ) | ( (FT_UInt32)(' ') << 8 ) | (FT_UInt32)(' ') ),
    FT_ENCODING_BIG5 = ( ( (FT_UInt32)('b') << 24 ) | ( (FT_UInt32)('i') << 16 ) | ( (FT_UInt32)('g') << 8 ) | (FT_UInt32)('5') ),
    FT_ENCODING_WANSUNG = ( ( (FT_UInt32)('w') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('n') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_JOHAB = ( ( (FT_UInt32)('j') << 24 ) | ( (FT_UInt32)('o') << 16 ) | ( (FT_UInt32)('h') << 8 ) | (FT_UInt32)('a') ),


    FT_ENCODING_MS_SJIS = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312 = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5 = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB = FT_ENCODING_JOHAB,

    FT_ENCODING_ADOBE_STANDARD = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('O') << 8 ) | (FT_UInt32)('B') ),
    FT_ENCODING_ADOBE_EXPERT = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('E') ),
    FT_ENCODING_ADOBE_CUSTOM = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('C') ),
    FT_ENCODING_ADOBE_LATIN_1 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('1') ),

    FT_ENCODING_OLD_LATIN_2 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('2') ),

    FT_ENCODING_APPLE_ROMAN = ( ( (FT_UInt32)('a') << 24 ) | ( (FT_UInt32)('r') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('n') )

  } FT_Encoding;
# 831 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_
  {
    FT_Face face;
    FT_Encoding encoding;
    FT_UShort platform_id;
    FT_UShort encoding_id;

  } FT_CharMapRec;
# 862 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Face_InternalRec_* FT_Face_Internal;
# 1034 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_
  {
    FT_Long num_faces;
    FT_Long face_index;

    FT_Long face_flags;
    FT_Long style_flags;

    FT_Long num_glyphs;

    FT_String* family_name;
    FT_String* style_name;

    FT_Int num_fixed_sizes;
    FT_Bitmap_Size* available_sizes;

    FT_Int num_charmaps;
    FT_CharMap* charmaps;

    FT_Generic generic;




    FT_BBox bbox;

    FT_UShort units_per_EM;
    FT_Short ascender;
    FT_Short descender;
    FT_Short height;

    FT_Short max_advance_width;
    FT_Short max_advance_height;

    FT_Short underline_position;
    FT_Short underline_thickness;

    FT_GlyphSlot glyph;
    FT_Size size;
    FT_CharMap charmap;



    FT_Driver driver;
    FT_Memory memory;
    FT_Stream stream;

    FT_ListRec sizes_list;

    FT_Generic autohint;
    void* extensions;

    FT_Face_Internal internal;



  } FT_FaceRec;
# 1443 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_InternalRec_* FT_Size_Internal;
# 1501 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_Metrics_
  {
    FT_UShort x_ppem;
    FT_UShort y_ppem;

    FT_Fixed x_scale;
    FT_Fixed y_scale;

    FT_Pos ascender;
    FT_Pos descender;
    FT_Pos height;
    FT_Pos max_advance;

  } FT_Size_Metrics;
# 1536 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_
  {
    FT_Face face;
    FT_Generic generic;
    FT_Size_Metrics metrics;
    FT_Size_Internal internal;

  } FT_SizeRec;
# 1562 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SubGlyphRec_* FT_SubGlyph;
# 1574 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Slot_InternalRec_* FT_Slot_Internal;
# 1745 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_
  {
    FT_Library library;
    FT_Face face;
    FT_GlyphSlot next;
    FT_UInt reserved;
    FT_Generic generic;

    FT_Glyph_Metrics metrics;
    FT_Fixed linearHoriAdvance;
    FT_Fixed linearVertAdvance;
    FT_Vector advance;

    FT_Glyph_Format format;

    FT_Bitmap bitmap;
    FT_Int bitmap_left;
    FT_Int bitmap_top;

    FT_Outline outline;

    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

    void* control_data;
    long control_len;

    FT_Pos lsb_delta;
    FT_Pos rsb_delta;

    void* other;

    FT_Slot_Internal internal;

  } FT_GlyphSlotRec;
# 1817 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Init_FreeType( FT_Library *alibrary );
# 1836 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Done_FreeType( FT_Library library );
# 1899 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Parameter_
  {
    FT_ULong tag;
    FT_Pointer data;

  } FT_Parameter;
# 1965 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Open_Args_
  {
    FT_UInt flags;
    const FT_Byte* memory_base;
    FT_Long memory_size;
    FT_String* pathname;
    FT_Stream stream;
    FT_Module driver;
    FT_Int num_params;
    FT_Parameter* params;

  } FT_Open_Args;
# 2007 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_New_Face( FT_Library library,
               const char* filepathname,
               FT_Long face_index,
               FT_Face *aface );
# 2044 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_New_Memory_Face( FT_Library library,
                      const FT_Byte* file_base,
                      FT_Long file_size,
                      FT_Long face_index,
                      FT_Face *aface );
# 2192 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Open_Face( FT_Library library,
                const FT_Open_Args* args,
                FT_Long face_index,
                FT_Face *aface );
# 2216 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Attach_File( FT_Face face,
                  const char* filepathname );
# 2251 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Attach_Stream( FT_Face face,
                    FT_Open_Args* parameters );
# 2279 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Reference_Face( FT_Face face );
# 2302 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Done_Face( FT_Face face );
# 2324 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Select_Size( FT_Face face,
                  FT_Int strike_index );
# 2371 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;
# 2411 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_
  {
    FT_Size_Request_Type type;
    FT_Long width;
    FT_Long height;
    FT_UInt horiResolution;
    FT_UInt vertResolution;

  } FT_Size_RequestRec;
# 2430 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_ *FT_Size_Request;
# 2464 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Request_Size( FT_Face face,
                   FT_Size_Request req );
# 2505 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Char_Size( FT_Face face,
                    FT_F26Dot6 char_width,
                    FT_F26Dot6 char_height,
                    FT_UInt horz_resolution,
                    FT_UInt vert_resolution );
# 2540 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Pixel_Sizes( FT_Face face,
                      FT_UInt pixel_width,
                      FT_UInt pixel_height );
# 2582 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Load_Glyph( FT_Face face,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );
# 2617 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Load_Char( FT_Face face,
                FT_ULong char_code,
                FT_Int32 load_flags );
# 2925 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Set_Transform( FT_Face face,
                    FT_Matrix* matrix,
                    FT_Vector* delta );
# 2989 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;
# 3111 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Render_Glyph( FT_GlyphSlot slot,
                   FT_Render_Mode render_mode );
# 3142 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;
# 3192 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Kerning( FT_Face face,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_UInt kern_mode,
                  FT_Vector *akerning );
# 3233 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Track_Kerning( FT_Face face,
                        FT_Fixed point_size,
                        FT_Int degree,
                        FT_Fixed* akerning );
# 3279 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Glyph_Name( FT_Face face,
                     FT_UInt glyph_index,
                     FT_Pointer buffer,
                     FT_UInt buffer_max );
# 3305 "../../../libs/freetype/include/freetype/freetype.h"
  extern const char*
  FT_Get_Postscript_Name( FT_Face face );
# 3337 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Select_Charmap( FT_Face face,
                     FT_Encoding encoding );
# 3366 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Charmap( FT_Face face,
                  FT_CharMap charmap );
# 3388 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Int
  FT_Get_Charmap_Index( FT_CharMap charmap );
# 3422 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Get_Char_Index( FT_Face face,
                     FT_ULong charcode );
# 3477 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_ULong
  FT_Get_First_Char( FT_Face face,
                     FT_UInt *agindex );
# 3511 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_ULong
  FT_Get_Next_Char( FT_Face face,
                    FT_ULong char_code,
                    FT_UInt *agindex );
# 3534 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Get_Name_Index( FT_Face face,
                     FT_String* glyph_name );
# 3610 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_SubGlyph_Info( FT_GlyphSlot glyph,
                        FT_UInt sub_index,
                        FT_Int *p_index,
                        FT_UInt *p_flags,
                        FT_Int *p_arg1,
                        FT_Int *p_arg2,
                        FT_Matrix *p_transform );
# 3705 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UShort
  FT_Get_FSType_Flags( FT_Face face );
# 3791 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Face_GetCharVariantIndex( FT_Face face,
                               FT_ULong charcode,
                               FT_ULong variantSelector );
# 3827 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Int
  FT_Face_GetCharVariantIsDefault( FT_Face face,
                                   FT_ULong charcode,
                                   FT_ULong variantSelector );
# 3858 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetVariantSelectors( FT_Face face );
# 3891 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetVariantsOfChar( FT_Face face,
                             FT_ULong charcode );
# 3925 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetCharsOfVariant( FT_Face face,
                             FT_ULong variantSelector );
# 3982 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_MulDiv( FT_Long a,
             FT_Long b,
             FT_Long c );
# 4017 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_MulFix( FT_Long a,
             FT_Long b );
# 4039 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_DivFix( FT_Long a,
             FT_Long b );
# 4059 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_RoundFix( FT_Fixed a );
# 4078 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_CeilFix( FT_Fixed a );
# 4097 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_FloorFix( FT_Fixed a );
# 4118 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Vector_Transform( FT_Vector* vec,
                       const FT_Matrix* matrix );
# 4208 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Library_Version( FT_Library library,
                      FT_Int *amajor,
                      FT_Int *aminor,
                      FT_Int *apatch );
# 4242 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Bool
  FT_Face_CheckTrueTypePatents( FT_Face face );
# 4272 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Bool
  FT_Face_SetUnpatentedHinting( FT_Face face,
                                FT_Bool value );





# 21 "../../../libs/freetype/src/cff/cffpic.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
# 1 "../../../libs/freetype/include/freetype/ftrender.h" 1
# 24 "../../../libs/freetype/include/freetype/ftrender.h"
# 1 "../../../libs/freetype/include/freetype/ftmodapi.h" 1
# 33 "../../../libs/freetype/include/freetype/ftmodapi.h"

# 136 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Pointer FT_Module_Interface;
# 150 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Error
  (*FT_Module_Constructor)( FT_Module module );
# 165 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef void
  (*FT_Module_Destructor)( FT_Module module );
# 182 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Module_Interface
  (*FT_Module_Requester)( FT_Module module,
                          const char* name );
# 216 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef struct FT_Module_Class_
  {
    FT_ULong module_flags;
    FT_Long module_size;
    const FT_String* module_name;
    FT_Fixed module_version;
    FT_Fixed module_requires;

    const void* module_interface;

    FT_Module_Constructor module_init;
    FT_Module_Destructor module_done;
    FT_Module_Requester get_interface;

  } FT_Module_Class;
# 254 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Add_Module( FT_Library library,
                 const FT_Module_Class* clazz );
# 279 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Module
  FT_Get_Module( FT_Library library,
                 const char* module_name );
# 304 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Remove_Module( FT_Library library,
                    FT_Module module );
# 369 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Property_Set( FT_Library library,
                   const FT_String* module_name,
                   const FT_String* property_name,
                   const void* value );
# 433 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Property_Get( FT_Library library,
                   const FT_String* module_name,
                   const FT_String* property_name,
                   void* value );
# 463 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Reference_Library( FT_Library library );
# 499 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_New_Library( FT_Memory memory,
                  FT_Library *alibrary );
# 523 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Done_Library( FT_Library library );



  typedef void
  (*FT_DebugHook_Func)( void* arg );
# 559 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern void
  FT_Set_Debug_Hook( FT_Library library,
                     FT_UInt hook_index,
                     FT_DebugHook_Func debug_hook );
# 578 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern void
  FT_Add_Default_Modules( FT_Library library );
# 632 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef enum FT_TrueTypeEngineType_
  {
    FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED,
    FT_TRUETYPE_ENGINE_TYPE_PATENTED

  } FT_TrueTypeEngineType;
# 661 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_TrueTypeEngineType
  FT_Get_TrueType_Engine_Type( FT_Library library );





# 25 "../../../libs/freetype/include/freetype/ftrender.h" 2
# 1 "../../../libs/freetype/include/freetype/ftglyph.h" 1
# 46 "../../../libs/freetype/include/freetype/ftglyph.h"

# 69 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_Glyph_Class_ FT_Glyph_Class;
# 87 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_* FT_Glyph;
# 108 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_
  {
    FT_Library library;
    const FT_Glyph_Class* clazz;
    FT_Glyph_Format format;
    FT_Vector advance;

  } FT_GlyphRec;
# 127 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_* FT_BitmapGlyph;
# 160 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_
  {
    FT_GlyphRec root;
    FT_Int left;
    FT_Int top;
    FT_Bitmap bitmap;

  } FT_BitmapGlyphRec;
# 179 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_* FT_OutlineGlyph;
# 208 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_
  {
    FT_GlyphRec root;
    FT_Outline outline;

  } FT_OutlineGlyphRec;
# 234 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Get_Glyph( FT_GlyphSlot slot,
                FT_Glyph *aglyph );
# 258 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_Copy( FT_Glyph source,
                 FT_Glyph *target );
# 287 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_Transform( FT_Glyph glyph,
                      FT_Matrix* matrix,
                      FT_Vector* delta );
# 317 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef enum FT_Glyph_BBox_Mode_
  {
    FT_GLYPH_BBOX_UNSCALED = 0,
    FT_GLYPH_BBOX_SUBPIXELS = 0,
    FT_GLYPH_BBOX_GRIDFIT = 1,
    FT_GLYPH_BBOX_TRUNCATE = 2,
    FT_GLYPH_BBOX_PIXELS = 3

  } FT_Glyph_BBox_Mode;
# 406 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Glyph_Get_CBox( FT_Glyph glyph,
                     FT_UInt bbox_mode,
                     FT_BBox *acbox );
# 518 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_To_Bitmap( FT_Glyph* the_glyph,
                      FT_Render_Mode render_mode,
                      FT_Vector* origin,
                      FT_Bool destroy );
# 536 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Done_Glyph( FT_Glyph glyph );
# 569 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Matrix_Multiply( const FT_Matrix* a,
                      FT_Matrix* b );
# 589 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Matrix_Invert( FT_Matrix* matrix );





# 26 "../../../libs/freetype/include/freetype/ftrender.h" 2



# 40 "../../../libs/freetype/include/freetype/ftrender.h"
  typedef FT_Error
  (*FT_Glyph_InitFunc)( FT_Glyph glyph,
                        FT_GlyphSlot slot );


  typedef void
  (*FT_Glyph_DoneFunc)( FT_Glyph glyph );

  typedef void
  (*FT_Glyph_TransformFunc)( FT_Glyph glyph,
                             const FT_Matrix* matrix,
                             const FT_Vector* delta );

  typedef void
  (*FT_Glyph_GetBBoxFunc)( FT_Glyph glyph,
                           FT_BBox* abbox );

  typedef FT_Error
  (*FT_Glyph_CopyFunc)( FT_Glyph source,
                        FT_Glyph target );

  typedef FT_Error
  (*FT_Glyph_PrepareFunc)( FT_Glyph glyph,
                           FT_GlyphSlot slot );
# 74 "../../../libs/freetype/include/freetype/ftrender.h"
  struct FT_Glyph_Class_
  {
    FT_Long glyph_size;
    FT_Glyph_Format glyph_format;
    FT_Glyph_InitFunc glyph_init;
    FT_Glyph_DoneFunc glyph_done;
    FT_Glyph_CopyFunc glyph_copy;
    FT_Glyph_TransformFunc glyph_transform;
    FT_Glyph_GetBBoxFunc glyph_bbox;
    FT_Glyph_PrepareFunc glyph_prepare;
  };


  typedef FT_Error
  (*FT_Renderer_RenderFunc)( FT_Renderer renderer,
                             FT_GlyphSlot slot,
                             FT_UInt mode,
                             const FT_Vector* origin );

  typedef FT_Error
  (*FT_Renderer_TransformFunc)( FT_Renderer renderer,
                                FT_GlyphSlot slot,
                                const FT_Matrix* matrix,
                                const FT_Vector* delta );


  typedef void
  (*FT_Renderer_GetCBoxFunc)( FT_Renderer renderer,
                              FT_GlyphSlot slot,
                              FT_BBox* cbox );


  typedef FT_Error
  (*FT_Renderer_SetModeFunc)( FT_Renderer renderer,
                              FT_ULong mode_tag,
                              FT_Pointer mode_ptr );
# 144 "../../../libs/freetype/include/freetype/ftrender.h"
  typedef struct FT_Renderer_Class_
  {
    FT_Module_Class root;

    FT_Glyph_Format glyph_format;

    FT_Renderer_RenderFunc render_glyph;
    FT_Renderer_TransformFunc transform_glyph;
    FT_Renderer_GetCBoxFunc get_glyph_cbox;
    FT_Renderer_SetModeFunc set_mode;

    FT_Raster_Funcs* raster_class;

  } FT_Renderer_Class;
# 183 "../../../libs/freetype/include/freetype/ftrender.h"
  extern FT_Renderer
  FT_Get_Renderer( FT_Library library,
                   FT_Glyph_Format format );
# 218 "../../../libs/freetype/include/freetype/ftrender.h"
  extern FT_Error
  FT_Set_Renderer( FT_Library library,
                   FT_Renderer renderer,
                   FT_UInt num_params,
                   FT_Parameter* parameters );





# 31 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/ftsizes.h" 1
# 42 "../../../libs/freetype/include/freetype/ftsizes.h"

# 99 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_New_Size( FT_Face face,
               FT_Size* size );
# 120 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_Done_Size( FT_Size size );
# 148 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_Activate_Size( FT_Size size );





# 32 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/ftlcdfil.h" 1
# 33 "../../../libs/freetype/include/freetype/ftlcdfil.h"

# 173 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  typedef enum FT_LcdFilter_
  {
    FT_LCD_FILTER_NONE = 0,
    FT_LCD_FILTER_DEFAULT = 1,
    FT_LCD_FILTER_LIGHT = 2,
    FT_LCD_FILTER_LEGACY1 = 3,
    FT_LCD_FILTER_LEGACY = 16,

    FT_LCD_FILTER_MAX

  } FT_LcdFilter;
# 240 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  extern FT_Error
  FT_Library_SetLcdFilter( FT_Library library,
                           FT_LcdFilter filter );
# 281 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  extern FT_Error
  FT_Library_SetLcdFilterWeights( FT_Library library,
                                  unsigned char *weights );





# 33 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftmemory.h" 1
# 28 "../../../libs/freetype/include/freetype/internal/ftmemory.h"

# 113 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_alloc( FT_Memory memory,
                FT_Long size,
                FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qalloc( FT_Memory memory,
                 FT_Long size,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_realloc( FT_Memory memory,
                  FT_Long item_size,
                  FT_Long cur_count,
                  FT_Long new_count,
                  void* block,
                  FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qrealloc( FT_Memory memory,
                   FT_Long item_size,
                   FT_Long cur_count,
                   FT_Long new_count,
                   void* block,
                   FT_Error *p_error );

  extern void
  ft_mem_free( FT_Memory memory,
               const void* P );
# 342 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_strdup( FT_Memory memory,
                 const char* str,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_dup( FT_Memory memory,
              const void* address,
              FT_ULong size,
              FT_Error *p_error );
# 370 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Int
  ft_mem_strcpyn( char* dst,
                  const char* src,
                  FT_ULong size );








# 34 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftgloadr.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"

# 43 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_GlyphLoaderRec_* FT_GlyphLoader ;
# 57 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_SubGlyphRec_
  {
    FT_Int index;
    FT_UShort flags;
    FT_Int arg1;
    FT_Int arg2;
    FT_Matrix transform;

  } FT_SubGlyphRec;


  typedef struct FT_GlyphLoadRec_
  {
    FT_Outline outline;
    FT_Vector* extra_points;
    FT_Vector* extra_points2;
    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

  } FT_GlyphLoadRec, *FT_GlyphLoad;


  typedef struct FT_GlyphLoaderRec_
  {
    FT_Memory memory;
    FT_UInt max_points;
    FT_UInt max_contours;
    FT_UInt max_subglyphs;
    FT_Bool use_extra;

    FT_GlyphLoadRec base;
    FT_GlyphLoadRec current;

    void* other;

  } FT_GlyphLoaderRec;



  extern FT_Error
  FT_GlyphLoader_New( FT_Memory memory,
                      FT_GlyphLoader *aloader );


  extern FT_Error
  FT_GlyphLoader_CreateExtra( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Done( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Reset( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Rewind( FT_GlyphLoader loader );



  extern FT_Error
  FT_GlyphLoader_CheckPoints( FT_GlyphLoader loader,
                              FT_UInt n_points,
                              FT_UInt n_contours );
# 147 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  extern FT_Error
  FT_GlyphLoader_CheckSubGlyphs( FT_GlyphLoader loader,
                                 FT_UInt n_subs );


  extern void
  FT_GlyphLoader_Prepare( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Add( FT_GlyphLoader loader );


  extern FT_Error
  FT_GlyphLoader_CopyPoints( FT_GlyphLoader target,
                             FT_GlyphLoader source );





# 35 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftdriver.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftdriver.h"



  typedef FT_Error
  (*FT_Face_InitFunc)( FT_Stream stream,
                       FT_Face face,
                       FT_Int typeface_index,
                       FT_Int num_params,
                       FT_Parameter* parameters );

  typedef void
  (*FT_Face_DoneFunc)( FT_Face face );


  typedef FT_Error
  (*FT_Size_InitFunc)( FT_Size size );

  typedef void
  (*FT_Size_DoneFunc)( FT_Size size );


  typedef FT_Error
  (*FT_Slot_InitFunc)( FT_GlyphSlot slot );

  typedef void
  (*FT_Slot_DoneFunc)( FT_GlyphSlot slot );


  typedef FT_Error
  (*FT_Size_RequestFunc)( FT_Size size,
                          FT_Size_Request req );

  typedef FT_Error
  (*FT_Size_SelectFunc)( FT_Size size,
                         FT_ULong size_index );

  typedef FT_Error
  (*FT_Slot_LoadFunc)( FT_GlyphSlot slot,
                       FT_Size size,
                       FT_UInt glyph_index,
                       FT_Int32 load_flags );


  typedef FT_UInt
  (*FT_CharMap_CharIndexFunc)( FT_CharMap charmap,
                               FT_Long charcode );

  typedef FT_Long
  (*FT_CharMap_CharNextFunc)( FT_CharMap charmap,
                              FT_Long charcode );


  typedef FT_Error
  (*FT_Face_GetKerningFunc)( FT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph,
                             FT_Vector* kerning );


  typedef FT_Error
  (*FT_Face_AttachFunc)( FT_Face face,
                         FT_Stream stream );


  typedef FT_Error
  (*FT_Face_GetAdvancesFunc)( FT_Face face,
                              FT_UInt first,
                              FT_UInt count,
                              FT_Int32 flags,
                              FT_Fixed* advances );
# 166 "../../../libs/freetype/include/freetype/internal/ftdriver.h"
  typedef struct FT_Driver_ClassRec_
  {
    FT_Module_Class root;

    FT_Long face_object_size;
    FT_Long size_object_size;
    FT_Long slot_object_size;

    FT_Face_InitFunc init_face;
    FT_Face_DoneFunc done_face;

    FT_Size_InitFunc init_size;
    FT_Size_DoneFunc done_size;

    FT_Slot_InitFunc init_slot;
    FT_Slot_DoneFunc done_slot;

    FT_Slot_LoadFunc load_glyph;

    FT_Face_GetKerningFunc get_kerning;
    FT_Face_AttachFunc attach_file;
    FT_Face_GetAdvancesFunc get_advances;


    FT_Size_RequestFunc request_size;
    FT_Size_SelectFunc select_size;

  } FT_Driver_ClassRec, *FT_Driver_Class;
# 404 "../../../libs/freetype/include/freetype/internal/ftdriver.h"

# 36 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/autohint.h" 1
# 77 "../../../libs/freetype/include/freetype/internal/autohint.h"



  typedef struct FT_AutoHinterRec_ *FT_AutoHinter;
# 104 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalGetFunc)( FT_AutoHinter hinter,
                                  FT_Face face,
                                  void** global_hints,
                                  long* global_len );
# 126 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalDoneFunc)( FT_AutoHinter hinter,
                                   void* global );
# 146 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalResetFunc)( FT_AutoHinter hinter,
                                    FT_Face face );
# 174 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef FT_Error
  (*FT_AutoHinter_GlyphLoadFunc)( FT_AutoHinter hinter,
                                  FT_GlyphSlot slot,
                                  FT_Size size,
                                  FT_UInt glyph_index,
                                  FT_Int32 load_flags );
# 190 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef struct FT_AutoHinter_InterfaceRec_
  {
    FT_AutoHinter_GlobalResetFunc reset_face;
    FT_AutoHinter_GlobalGetFunc get_global_hints;
    FT_AutoHinter_GlobalDoneFunc done_global_hints;
    FT_AutoHinter_GlyphLoadFunc load_glyph;

  } FT_AutoHinter_InterfaceRec, *FT_AutoHinter_Interface;
# 239 "../../../libs/freetype/include/freetype/internal/autohint.h"

# 37 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftserv.h" 1
# 35 "../../../libs/freetype/include/freetype/internal/ftserv.h"

# 150 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceDescRec_
  {
    const char* serv_id;
    const void* serv_data;

  } FT_ServiceDescRec;

  typedef const FT_ServiceDescRec* FT_ServiceDesc;
# 608 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  extern FT_Pointer
  ft_service_list_lookup( FT_ServiceDesc service_descriptors,
                          const char* service_id );
# 634 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceCacheRec_
  {
    FT_Pointer service_POSTSCRIPT_FONT_NAME;
    FT_Pointer service_MULTI_MASTERS;
    FT_Pointer service_GLYPH_DICT;
    FT_Pointer service_PFR_METRICS;
    FT_Pointer service_WINFNT;

  } FT_ServiceCacheRec, *FT_ServiceCache;
# 758 "../../../libs/freetype/include/freetype/internal/ftserv.h"

# 38 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftpic.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/ftpic.h"

# 66 "../../../libs/freetype/include/freetype/internal/ftpic.h"

# 39 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2


# 1 "../../../libs/freetype/include/freetype/ftincrem.h" 1
# 32 "../../../libs/freetype/include/freetype/ftincrem.h"

# 84 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_IncrementalRec_* FT_Incremental;
# 115 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_MetricsRec_
  {
    FT_Long bearing_x;
    FT_Long bearing_y;
    FT_Long advance;
    FT_Long advance_v;

  } FT_Incremental_MetricsRec;
# 134 "../../../libs/freetype/include/freetype/ftincrem.h"
   typedef struct FT_Incremental_MetricsRec_* FT_Incremental_Metrics;
# 178 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Error
  (*FT_Incremental_GetGlyphDataFunc)( FT_Incremental incremental,
                                      FT_UInt glyph_index,
                                      FT_Data* adata );
# 203 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef void
  (*FT_Incremental_FreeGlyphDataFunc)( FT_Incremental incremental,
                                       FT_Data* data );
# 240 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Error
  (*FT_Incremental_GetGlyphMetricsFunc)
                      ( FT_Incremental incremental,
                        FT_UInt glyph_index,
                        FT_Bool vertical,
                        FT_Incremental_MetricsRec *ametrics );
# 269 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_FuncsRec_
  {
    FT_Incremental_GetGlyphDataFunc get_glyph_data;
    FT_Incremental_FreeGlyphDataFunc free_glyph_data;
    FT_Incremental_GetGlyphMetricsFunc get_glyph_metrics;

  } FT_Incremental_FuncsRec;
# 314 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_InterfaceRec_
  {
    const FT_Incremental_FuncsRec* funcs;
    FT_Incremental object;

  } FT_Incremental_InterfaceRec;
# 331 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Incremental_InterfaceRec* FT_Incremental_Interface;
# 349 "../../../libs/freetype/include/freetype/ftincrem.h"

# 42 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2




# 128 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_CMapRec_* FT_CMap;


  typedef const struct FT_CMap_ClassRec_* FT_CMap_Class;


  typedef struct FT_CMapRec_
  {
    FT_CharMapRec charmap;
    FT_CMap_Class clazz;

  } FT_CMapRec;
# 152 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef FT_Error
  (*FT_CMap_InitFunc)( FT_CMap cmap,
                       FT_Pointer init_data );

  typedef void
  (*FT_CMap_DoneFunc)( FT_CMap cmap );

  typedef FT_UInt
  (*FT_CMap_CharIndexFunc)( FT_CMap cmap,
                            FT_UInt32 char_code );

  typedef FT_UInt
  (*FT_CMap_CharNextFunc)( FT_CMap cmap,
                           FT_UInt32 *achar_code );

  typedef FT_UInt
  (*FT_CMap_CharVarIndexFunc)( FT_CMap cmap,
                               FT_CMap unicode_cmap,
                               FT_UInt32 char_code,
                               FT_UInt32 variant_selector );

  typedef FT_Bool
  (*FT_CMap_CharVarIsDefaultFunc)( FT_CMap cmap,
                                   FT_UInt32 char_code,
                                   FT_UInt32 variant_selector );

  typedef FT_UInt32 *
  (*FT_CMap_VariantListFunc)( FT_CMap cmap,
                              FT_Memory mem );

  typedef FT_UInt32 *
  (*FT_CMap_CharVariantListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 char_code );

  typedef FT_UInt32 *
  (*FT_CMap_VariantCharListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 variant_selector );


  typedef struct FT_CMap_ClassRec_
  {
    FT_ULong size;
    FT_CMap_InitFunc init;
    FT_CMap_DoneFunc done;
    FT_CMap_CharIndexFunc char_index;
    FT_CMap_CharNextFunc char_next;




    FT_CMap_CharVarIndexFunc char_var_index;
    FT_CMap_CharVarIsDefaultFunc char_var_default;
    FT_CMap_VariantListFunc variant_list;
    FT_CMap_CharVariantListFunc charvariant_list;
    FT_CMap_VariantCharListFunc variantchar_list;

  } FT_CMap_ClassRec;
# 286 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_CMap_New( FT_CMap_Class clazz,
               FT_Pointer init_data,
               FT_CharMap charmap,
               FT_CMap *acmap );


  extern void
  FT_CMap_Done( FT_CMap cmap );
# 356 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Face_InternalRec_
  {
    FT_Matrix transform_matrix;
    FT_Vector transform_delta;
    FT_Int transform_flags;

    FT_ServiceCacheRec services;


    FT_Incremental_InterfaceRec* incremental_interface;


    FT_Bool ignore_unpatented_hinter;
    FT_Int refcount;

  } FT_Face_InternalRec;
# 410 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Slot_InternalRec_
  {
    FT_GlyphLoader loader;
    FT_UInt flags;
    FT_Bool glyph_transformed;
    FT_Matrix glyph_matrix;
    FT_Vector glyph_delta;
    void* glyph_hints;

  } FT_GlyphSlot_InternalRec;
# 472 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_ModuleRec_
  {
    FT_Module_Class* clazz;
    FT_Library library;
    FT_Memory memory;

  } FT_ModuleRec;
# 534 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern const void*
  FT_Get_Module_Interface( FT_Library library,
                           const char* mod_name );

  extern FT_Pointer
  ft_module_get_service( FT_Module module,
                         const char* service_id );
# 595 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_New_GlyphSlot( FT_Face face,
                    FT_GlyphSlot *aslot );
# 613 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_GlyphSlot( FT_GlyphSlot slot );
# 630 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Select_Metrics( FT_Face face,
                     FT_ULong strike_index );



  extern void
  FT_Request_Metrics( FT_Face face,
                      FT_Size_Request req );



  extern FT_Error
  FT_Match_Size( FT_Face face,
                 FT_Size_Request req,
                 FT_Bool ignore_width,
                 FT_ULong* size_index );




  extern void
  ft_synthesize_vertical_metrics( FT_Glyph_Metrics* metrics,
                                  FT_Pos advance );




  extern void
  ft_glyphslot_free_bitmap( FT_GlyphSlot slot );



  extern FT_Error
  ft_glyphslot_alloc_bitmap( FT_GlyphSlot slot,
                             FT_ULong size );




  extern void
  ft_glyphslot_set_bitmap( FT_GlyphSlot slot,
                           FT_Byte* buffer );
# 694 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_RendererRec_
  {
    FT_ModuleRec root;
    FT_Renderer_Class* clazz;
    FT_Glyph_Format glyph_format;
    FT_Glyph_Class glyph_class;

    FT_Raster raster;
    FT_Raster_RenderFunc raster_render;
    FT_Renderer_RenderFunc render;

  } FT_RendererRec;
# 750 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_DriverRec_
  {
    FT_ModuleRec root;
    FT_Driver_Class clazz;
    FT_ListRec faces_list;
    FT_GlyphLoader glyph_loader;

  } FT_DriverRec;
# 785 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef void (*FT_Bitmap_LcdFilterFunc)( FT_Bitmap* bitmap,
                                            FT_Render_Mode render_mode,
                                            FT_Library library );
# 859 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_LibraryRec_
  {
    FT_Memory memory;

    FT_Int version_major;
    FT_Int version_minor;
    FT_Int version_patch;

    FT_UInt num_modules;
    FT_Module modules[32];

    FT_ListRec renderers;
    FT_Renderer cur_renderer;
    FT_Module auto_hinter;

    FT_Byte* raster_pool;

    FT_ULong raster_pool_size;

    FT_DebugHook_Func debug_hooks[4];


    FT_LcdFilter lcd_filter;
    FT_Int lcd_extra;
    FT_Byte lcd_weights[7];
    FT_Bitmap_LcdFilterFunc lcd_filter_func;






    FT_Int refcount;

  } FT_LibraryRec;


  extern FT_Renderer
  FT_Lookup_Renderer( FT_Library library,
                      FT_Glyph_Format format,
                      FT_ListNode* node );

  extern FT_Error
  FT_Render_Glyph_Internal( FT_Library library,
                            FT_GlyphSlot slot,
                            FT_Render_Mode render_mode );

  typedef const char*
  (*FT_Face_GetPostscriptNameFunc)( FT_Face face );

  typedef FT_Error
  (*FT_Face_GetGlyphNameFunc)( FT_Face face,
                               FT_UInt glyph_index,
                               FT_Pointer buffer,
                               FT_UInt buffer_max );

  typedef FT_UInt
  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face face,
                                    FT_String* glyph_name );
# 933 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Memory
  FT_New_Memory( void );
# 948 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_Memory( FT_Memory memory );
# 961 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Raster_Funcs ft_default_raster;
# 1569 "../../../libs/freetype/include/freetype/internal/ftobjs.h"

# 22 "../../../libs/freetype/src/cff/cffpic.c" 2
# 1 "../../../libs/freetype/src/cff/cffcmap.h" 1
# 22 "../../../libs/freetype/src/cff/cffcmap.h"
# 1 "../../../libs/freetype/src/cff/cffobjs.h" 1
# 25 "../../../libs/freetype/src/cff/cffobjs.h"
# 1 "../../../libs/freetype/src/cff/cfftypes.h" 1
# 26 "../../../libs/freetype/src/cff/cfftypes.h"
# 1 "../../../libs/freetype/include/freetype/t1tables.h" 1
# 34 "../../../libs/freetype/include/freetype/t1tables.h"

# 89 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_FontInfoRec_
  {
    FT_String* version;
    FT_String* notice;
    FT_String* full_name;
    FT_String* family_name;
    FT_String* weight;
    FT_Long italic_angle;
    FT_Bool is_fixed_pitch;
    FT_Short underline_position;
    FT_UShort underline_thickness;

  } PS_FontInfoRec;
# 112 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_FontInfoRec_* PS_FontInfo;
# 125 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef PS_FontInfoRec T1_FontInfo;
# 138 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_PrivateRec_
  {
    FT_Int unique_id;
    FT_Int lenIV;

    FT_Byte num_blue_values;
    FT_Byte num_other_blues;
    FT_Byte num_family_blues;
    FT_Byte num_family_other_blues;

    FT_Short blue_values[14];
    FT_Short other_blues[10];

    FT_Short family_blues [14];
    FT_Short family_other_blues[10];

    FT_Fixed blue_scale;
    FT_Int blue_shift;
    FT_Int blue_fuzz;

    FT_UShort standard_width[1];
    FT_UShort standard_height[1];

    FT_Byte num_snap_widths;
    FT_Byte num_snap_heights;
    FT_Bool force_bold;
    FT_Bool round_stem_up;

    FT_Short snap_widths [13];
    FT_Short snap_heights[13];

    FT_Fixed expansion_factor;

    FT_Long language_group;
    FT_Long password;

    FT_Short min_feature[2];

  } PS_PrivateRec;
# 187 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_PrivateRec_* PS_Private;
# 200 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef PS_PrivateRec T1_Private;
# 229 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef enum T1_Blend_Flags_
  {

    T1_BLEND_UNDERLINE_POSITION = 0,
    T1_BLEND_UNDERLINE_THICKNESS,
    T1_BLEND_ITALIC_ANGLE,


    T1_BLEND_BLUE_VALUES,
    T1_BLEND_OTHER_BLUES,
    T1_BLEND_STANDARD_WIDTH,
    T1_BLEND_STANDARD_HEIGHT,
    T1_BLEND_STEM_SNAP_WIDTHS,
    T1_BLEND_STEM_SNAP_HEIGHTS,
    T1_BLEND_BLUE_SCALE,
    T1_BLEND_BLUE_SHIFT,
    T1_BLEND_FAMILY_BLUES,
    T1_BLEND_FAMILY_OTHER_BLUES,
    T1_BLEND_FORCE_BOLD,

    T1_BLEND_MAX

  } T1_Blend_Flags;
# 286 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct PS_DesignMap_
  {
    FT_Byte num_points;
    FT_Long* design_points;
    FT_Fixed* blend_points;

  } PS_DesignMapRec, *PS_DesignMap;


  typedef PS_DesignMapRec T1_DesignMap;


  typedef struct PS_BlendRec_
  {
    FT_UInt num_designs;
    FT_UInt num_axis;

    FT_String* axis_names[4];
    FT_Fixed* design_pos[16];
    PS_DesignMapRec design_map[4];

    FT_Fixed* weight_vector;
    FT_Fixed* default_weight_vector;

    PS_FontInfo font_infos[16 + 1];
    PS_Private privates [16 + 1];

    FT_ULong blend_bitflags;

    FT_BBox* bboxes [16 + 1];







    FT_UInt default_design_vector[16];
    FT_UInt num_default_design_vector;

  } PS_BlendRec, *PS_Blend;



  typedef PS_BlendRec T1_Blend;
# 341 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceDictRec_
  {
    PS_PrivateRec private_dict;

    FT_UInt len_buildchar;
    FT_Fixed forcebold_threshold;
    FT_Pos stroke_width;
    FT_Fixed expansion_factor;

    FT_Byte paint_type;
    FT_Byte font_type;
    FT_Matrix font_matrix;
    FT_Vector font_offset;

    FT_UInt num_subrs;
    FT_ULong subrmap_offset;
    FT_Int sd_bytes;

  } CID_FaceDictRec;
# 370 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceDictRec_* CID_FaceDict;
# 383 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef CID_FaceDictRec CID_FontDict;
# 394 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceInfoRec_
  {
    FT_String* cid_font_name;
    FT_Fixed cid_version;
    FT_Int cid_font_type;

    FT_String* registry;
    FT_String* ordering;
    FT_Int supplement;

    PS_FontInfoRec font_info;
    FT_BBox font_bbox;
    FT_ULong uid_base;

    FT_Int num_xuid;
    FT_ULong xuid[16];

    FT_ULong cidmap_offset;
    FT_Int fd_bytes;
    FT_Int gd_bytes;
    FT_ULong cid_count;

    FT_Int num_dicts;
    CID_FaceDict font_dicts;

    FT_ULong data_offset;

  } CID_FaceInfoRec;
# 432 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef struct CID_FaceInfoRec_* CID_FaceInfo;
# 445 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef CID_FaceInfoRec CID_Info;
# 470 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Int
  FT_Has_PS_Glyph_Names( FT_Face face );
# 503 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Error
  FT_Get_PS_Font_Info( FT_Face face,
                       PS_FontInfo afont_info );
# 536 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Error
  FT_Get_PS_Font_Private( FT_Face face,
                          PS_Private afont_private );
# 557 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef enum T1_EncodingType_
  {
    T1_ENCODING_TYPE_NONE = 0,
    T1_ENCODING_TYPE_ARRAY,
    T1_ENCODING_TYPE_STANDARD,
    T1_ENCODING_TYPE_ISOLATIN1,
    T1_ENCODING_TYPE_EXPERT

  } T1_EncodingType;
# 625 "../../../libs/freetype/include/freetype/t1tables.h"
  typedef enum PS_Dict_Keys_
  {

    PS_DICT_FONT_TYPE,
    PS_DICT_FONT_MATRIX,
    PS_DICT_FONT_BBOX,
    PS_DICT_PAINT_TYPE,
    PS_DICT_FONT_NAME,
    PS_DICT_UNIQUE_ID,
    PS_DICT_NUM_CHAR_STRINGS,
    PS_DICT_CHAR_STRING_KEY,
    PS_DICT_CHAR_STRING,
    PS_DICT_ENCODING_TYPE,
    PS_DICT_ENCODING_ENTRY,


    PS_DICT_NUM_SUBRS,
    PS_DICT_SUBR,
    PS_DICT_STD_HW,
    PS_DICT_STD_VW,
    PS_DICT_NUM_BLUE_VALUES,
    PS_DICT_BLUE_VALUE,
    PS_DICT_BLUE_FUZZ,
    PS_DICT_NUM_OTHER_BLUES,
    PS_DICT_OTHER_BLUE,
    PS_DICT_NUM_FAMILY_BLUES,
    PS_DICT_FAMILY_BLUE,
    PS_DICT_NUM_FAMILY_OTHER_BLUES,
    PS_DICT_FAMILY_OTHER_BLUE,
    PS_DICT_BLUE_SCALE,
    PS_DICT_BLUE_SHIFT,
    PS_DICT_NUM_STEM_SNAP_H,
    PS_DICT_STEM_SNAP_H,
    PS_DICT_NUM_STEM_SNAP_V,
    PS_DICT_STEM_SNAP_V,
    PS_DICT_FORCE_BOLD,
    PS_DICT_RND_STEM_UP,
    PS_DICT_MIN_FEATURE,
    PS_DICT_LEN_IV,
    PS_DICT_PASSWORD,
    PS_DICT_LANGUAGE_GROUP,


    PS_DICT_VERSION,
    PS_DICT_NOTICE,
    PS_DICT_FULL_NAME,
    PS_DICT_FAMILY_NAME,
    PS_DICT_WEIGHT,
    PS_DICT_IS_FIXED_PITCH,
    PS_DICT_UNDERLINE_POSITION,
    PS_DICT_UNDERLINE_THICKNESS,
    PS_DICT_FS_TYPE,
    PS_DICT_ITALIC_ANGLE,

    PS_DICT_MAX = PS_DICT_ITALIC_ANGLE

  } PS_Dict_Keys;
# 747 "../../../libs/freetype/include/freetype/t1tables.h"
  extern FT_Long
  FT_Get_PS_Font_Value( FT_Face face,
                        PS_Dict_Keys key,
                        FT_UInt idx,
                        void *value,
                        FT_Long value_len );




# 27 "../../../libs/freetype/src/cff/cfftypes.h" 2

# 1 "../../../libs/freetype/include/freetype/internal/services/svpscmap.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svpscmap.h"

# 34 "../../../libs/freetype/include/freetype/internal/services/svpscmap.h"
  typedef FT_UInt32
  (*PS_Unicode_ValueFunc)( const char* glyph_name );




  typedef const char*
  (*PS_Macintosh_NameFunc)( FT_UInt name_index );




  typedef const char*
  (*PS_Adobe_Std_StringsFunc)( FT_UInt string_index );






  typedef struct PS_UniMap_
  {
    FT_UInt32 unicode;
    FT_UInt glyph_index;

  } PS_UniMap;


  typedef struct PS_UnicodesRec_* PS_Unicodes;

  typedef struct PS_UnicodesRec_
  {
    FT_CMapRec cmap;
    FT_UInt num_maps;
    PS_UniMap* maps;

  } PS_UnicodesRec;






  typedef const char*
  (*PS_GetGlyphNameFunc)( FT_Pointer data,
                          FT_UInt string_index );





  typedef void
  (*PS_FreeGlyphNameFunc)( FT_Pointer data,
                           const char* name );

  typedef FT_Error
  (*PS_Unicodes_InitFunc)( FT_Memory memory,
                           PS_Unicodes unicodes,
                           FT_UInt num_glyphs,
                           PS_GetGlyphNameFunc get_glyph_name,
                           PS_FreeGlyphNameFunc free_glyph_name,
                           FT_Pointer glyph_data );

  typedef FT_UInt
  (*PS_Unicodes_CharIndexFunc)( PS_Unicodes unicodes,
                                FT_UInt32 unicode );

  typedef FT_UInt32
  (*PS_Unicodes_CharNextFunc)( PS_Unicodes unicodes,
                               FT_UInt32 *unicode );


  typedef struct FT_Service_PsCMapsRec_ FT_Service_PsCMapsRec ; typedef struct FT_Service_PsCMapsRec_ const * FT_Service_PsCMaps ; struct FT_Service_PsCMapsRec_
  {
    PS_Unicode_ValueFunc unicode_value;

    PS_Unicodes_InitFunc unicodes_init;
    PS_Unicodes_CharIndexFunc unicodes_char_index;
    PS_Unicodes_CharNextFunc unicodes_char_next;

    PS_Macintosh_NameFunc macintosh_name;
    PS_Adobe_Std_StringsFunc adobe_std_strings;
    const unsigned short* adobe_std_encoding;
    const unsigned short* adobe_expert_encoding;
  };
# 171 "../../../libs/freetype/include/freetype/internal/services/svpscmap.h"

# 29 "../../../libs/freetype/src/cff/cfftypes.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/pshints.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/pshints.h"

# 41 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef struct PSH_GlobalsRec_* PSH_Globals;

  typedef FT_Error
  (*PSH_Globals_NewFunc)( FT_Memory memory,
                          T1_Private* private_dict,
                          PSH_Globals* aglobals );

  typedef void
  (*PSH_Globals_SetScaleFunc)( PSH_Globals globals,
                               FT_Fixed x_scale,
                               FT_Fixed y_scale,
                               FT_Fixed x_delta,
                               FT_Fixed y_delta );

  typedef void
  (*PSH_Globals_DestroyFunc)( PSH_Globals globals );


  typedef struct PSH_Globals_FuncsRec_
  {
    PSH_Globals_NewFunc create;
    PSH_Globals_SetScaleFunc set_scale;
    PSH_Globals_DestroyFunc destroy;

  } PSH_Globals_FuncsRec, *PSH_Globals_Funcs;
# 104 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef struct T1_HintsRec_* T1_Hints;
# 117 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef const struct T1_Hints_FuncsRec_* T1_Hints_Funcs;
# 138 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T1_Hints_OpenFunc)( T1_Hints hints );
# 178 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T1_Hints_SetStemFunc)( T1_Hints hints,
                           FT_UInt dimension,
                           FT_Fixed* coords );
# 212 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T1_Hints_SetStem3Func)( T1_Hints hints,
                            FT_UInt dimension,
                            FT_Fixed* coords );
# 236 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T1_Hints_ResetFunc)( T1_Hints hints,
                         FT_UInt end_point );
# 265 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef FT_Error
  (*T1_Hints_CloseFunc)( T1_Hints hints,
                         FT_UInt end_point );
# 304 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef FT_Error
  (*T1_Hints_ApplyFunc)( T1_Hints hints,
                         FT_Outline* outline,
                         PSH_Globals globals,
                         FT_Render_Mode hint_mode );
# 342 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef struct T1_Hints_FuncsRec_
  {
    T1_Hints hints;
    T1_Hints_OpenFunc open;
    T1_Hints_CloseFunc close;
    T1_Hints_SetStemFunc stem;
    T1_Hints_SetStem3Func stem3;
    T1_Hints_ResetFunc reset;
    T1_Hints_ApplyFunc apply;

  } T1_Hints_FuncsRec;
# 391 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef struct T2_HintsRec_* T2_Hints;
# 404 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef const struct T2_Hints_FuncsRec_* T2_Hints_Funcs;
# 425 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T2_Hints_OpenFunc)( T2_Hints hints );
# 465 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T2_Hints_StemsFunc)( T2_Hints hints,
                         FT_UInt dimension,
                         FT_Int count,
                         FT_Fixed* coordinates );
# 507 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T2_Hints_MaskFunc)( T2_Hints hints,
                        FT_UInt end_point,
                        FT_UInt bit_count,
                        const FT_Byte* bytes );
# 549 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef void
  (*T2_Hints_CounterFunc)( T2_Hints hints,
                           FT_UInt bit_count,
                           const FT_Byte* bytes );
# 579 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef FT_Error
  (*T2_Hints_CloseFunc)( T2_Hints hints,
                         FT_UInt end_point );
# 618 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef FT_Error
  (*T2_Hints_ApplyFunc)( T2_Hints hints,
                         FT_Outline* outline,
                         PSH_Globals globals,
                         FT_Render_Mode hint_mode );
# 656 "../../../libs/freetype/include/freetype/internal/pshints.h"
  typedef struct T2_Hints_FuncsRec_
  {
    T2_Hints hints;
    T2_Hints_OpenFunc open;
    T2_Hints_CloseFunc close;
    T2_Hints_StemsFunc stems;
    T2_Hints_MaskFunc hintmask;
    T2_Hints_CounterFunc counter;
    T2_Hints_ApplyFunc apply;

  } T2_Hints_FuncsRec;





  typedef struct PSHinter_Interface_
  {
    PSH_Globals_Funcs (*get_globals_funcs)( FT_Module module );
    T1_Hints_Funcs (*get_t1_funcs) ( FT_Module module );
    T2_Hints_Funcs (*get_t2_funcs) ( FT_Module module );

  } PSHinter_Interface;

  typedef PSHinter_Interface* PSHinter_Service;
# 717 "../../../libs/freetype/include/freetype/internal/pshints.h"

# 30 "../../../libs/freetype/src/cff/cfftypes.h" 2



# 63 "../../../libs/freetype/src/cff/cfftypes.h"
  typedef struct CFF_IndexRec_
  {
    FT_Stream stream;
    FT_ULong start;
    FT_UInt count;
    FT_Byte off_size;
    FT_ULong data_offset;
    FT_ULong data_size;

    FT_ULong* offsets;
    FT_Byte* bytes;

  } CFF_IndexRec, *CFF_Index;


  typedef struct CFF_EncodingRec_
  {
    FT_UInt format;
    FT_ULong offset;

    FT_UInt count;
    FT_UShort sids [256];
    FT_UShort codes[256];

  } CFF_EncodingRec, *CFF_Encoding;


  typedef struct CFF_CharsetRec_
  {

    FT_UInt format;
    FT_ULong offset;

    FT_UShort* sids;
    FT_UShort* cids;

    FT_UInt max_cid;
    FT_UInt num_glyphs;

  } CFF_CharsetRec, *CFF_Charset;


  typedef struct CFF_FontRecDictRec_
  {
    FT_UInt version;
    FT_UInt notice;
    FT_UInt copyright;
    FT_UInt full_name;
    FT_UInt family_name;
    FT_UInt weight;
    FT_Bool is_fixed_pitch;
    FT_Fixed italic_angle;
    FT_Fixed underline_position;
    FT_Fixed underline_thickness;
    FT_Int paint_type;
    FT_Int charstring_type;
    FT_Matrix font_matrix;
    FT_Bool has_font_matrix;
    FT_ULong units_per_em;
    FT_Vector font_offset;
    FT_ULong unique_id;
    FT_BBox font_bbox;
    FT_Pos stroke_width;
    FT_ULong charset_offset;
    FT_ULong encoding_offset;
    FT_ULong charstrings_offset;
    FT_ULong private_offset;
    FT_ULong private_size;
    FT_Long synthetic_base;
    FT_UInt embedded_postscript;


    FT_UInt cid_registry;
    FT_UInt cid_ordering;
    FT_Long cid_supplement;

    FT_Long cid_font_version;
    FT_Long cid_font_revision;
    FT_Long cid_font_type;
    FT_ULong cid_count;
    FT_ULong cid_uid_base;
    FT_ULong cid_fd_array_offset;
    FT_ULong cid_fd_select_offset;
    FT_UInt cid_font_name;

  } CFF_FontRecDictRec, *CFF_FontRecDict;


  typedef struct CFF_PrivateRec_
  {
    FT_Byte num_blue_values;
    FT_Byte num_other_blues;
    FT_Byte num_family_blues;
    FT_Byte num_family_other_blues;

    FT_Pos blue_values[14];
    FT_Pos other_blues[10];
    FT_Pos family_blues[14];
    FT_Pos family_other_blues[10];

    FT_Fixed blue_scale;
    FT_Pos blue_shift;
    FT_Pos blue_fuzz;
    FT_Pos standard_width;
    FT_Pos standard_height;

    FT_Byte num_snap_widths;
    FT_Byte num_snap_heights;
    FT_Pos snap_widths[13];
    FT_Pos snap_heights[13];
    FT_Bool force_bold;
    FT_Fixed force_bold_threshold;
    FT_Int lenIV;
    FT_Int language_group;
    FT_Fixed expansion_factor;
    FT_Long initial_random_seed;
    FT_ULong local_subrs_offset;
    FT_Pos default_width;
    FT_Pos nominal_width;

  } CFF_PrivateRec, *CFF_Private;


  typedef struct CFF_FDSelectRec_
  {
    FT_Byte format;
    FT_UInt range_count;


    FT_Byte* data;
    FT_UInt data_size;


    FT_UInt cache_first;
    FT_UInt cache_count;
    FT_Byte cache_fd;

  } CFF_FDSelectRec, *CFF_FDSelect;




  typedef struct CFF_SubFontRec_
  {
    CFF_FontRecDictRec font_dict;
    CFF_PrivateRec private_dict;

    CFF_IndexRec local_subrs_index;
    FT_Byte** local_subrs;

  } CFF_SubFontRec, *CFF_SubFont;





  typedef struct CFF_FontRec_
  {
    FT_Stream stream;
    FT_Memory memory;
    FT_UInt num_faces;
    FT_UInt num_glyphs;

    FT_Byte version_major;
    FT_Byte version_minor;
    FT_Byte header_size;
    FT_Byte absolute_offsize;


    CFF_IndexRec name_index;
    CFF_IndexRec top_dict_index;
    CFF_IndexRec global_subrs_index;

    CFF_EncodingRec encoding;
    CFF_CharsetRec charset;

    CFF_IndexRec charstrings_index;
    CFF_IndexRec font_dict_index;
    CFF_IndexRec private_index;
    CFF_IndexRec local_subrs_index;

    FT_String* font_name;


    FT_Byte** global_subrs;


    FT_UInt num_strings;
    FT_Byte** strings;
    FT_Byte* string_pool;

    CFF_SubFontRec top_font;
    FT_UInt num_subfonts;
    CFF_SubFont subfonts[256];

    CFF_FDSelectRec fd_select;


    PSHinter_Service pshinter;


    FT_Service_PsCMaps psnames;


    PS_FontInfoRec* font_info;


    FT_String* registry;
    FT_String* ordering;


    FT_Generic cf2_instance;

  } CFF_FontRec, *CFF_Font;



# 26 "../../../libs/freetype/src/cff/cffobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/tttypes.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/tttypes.h"
# 1 "../../../libs/freetype/include/freetype/tttables.h" 1
# 34 "../../../libs/freetype/include/freetype/tttables.h"

# 82 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_Header_
  {
    FT_Fixed Table_Version;
    FT_Fixed Font_Revision;

    FT_Long CheckSum_Adjust;
    FT_Long Magic_Number;

    FT_UShort Flags;
    FT_UShort Units_Per_EM;

    FT_Long Created [2];
    FT_Long Modified[2];

    FT_Short xMin;
    FT_Short yMin;
    FT_Short xMax;
    FT_Short yMax;

    FT_UShort Mac_Style;
    FT_UShort Lowest_Rec_PPEM;

    FT_Short Font_Direction;
    FT_Short Index_To_Loc_Format;
    FT_Short Glyph_Data_Format;

  } TT_Header;
# 199 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_HoriHeader_
  {
    FT_Fixed Version;
    FT_Short Ascender;
    FT_Short Descender;
    FT_Short Line_Gap;

    FT_UShort advance_Width_Max;

    FT_Short min_Left_Side_Bearing;
    FT_Short min_Right_Side_Bearing;
    FT_Short xMax_Extent;
    FT_Short caret_Slope_Rise;
    FT_Short caret_Slope_Run;
    FT_Short caret_Offset;

    FT_Short Reserved[4];

    FT_Short metric_Data_Format;
    FT_UShort number_Of_HMetrics;





    void* long_metrics;
    void* short_metrics;

  } TT_HoriHeader;
# 325 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_VertHeader_
  {
    FT_Fixed Version;
    FT_Short Ascender;
    FT_Short Descender;
    FT_Short Line_Gap;

    FT_UShort advance_Height_Max;

    FT_Short min_Top_Side_Bearing;
    FT_Short min_Bottom_Side_Bearing;
    FT_Short yMax_Extent;
    FT_Short caret_Slope_Rise;
    FT_Short caret_Slope_Run;
    FT_Short caret_Offset;

    FT_Short Reserved[4];

    FT_Short metric_Data_Format;
    FT_UShort number_Of_VMetrics;





    void* long_metrics;
    void* short_metrics;

  } TT_VertHeader;
# 368 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_OS2_
  {
    FT_UShort version;
    FT_Short xAvgCharWidth;
    FT_UShort usWeightClass;
    FT_UShort usWidthClass;
    FT_UShort fsType;
    FT_Short ySubscriptXSize;
    FT_Short ySubscriptYSize;
    FT_Short ySubscriptXOffset;
    FT_Short ySubscriptYOffset;
    FT_Short ySuperscriptXSize;
    FT_Short ySuperscriptYSize;
    FT_Short ySuperscriptXOffset;
    FT_Short ySuperscriptYOffset;
    FT_Short yStrikeoutSize;
    FT_Short yStrikeoutPosition;
    FT_Short sFamilyClass;

    FT_Byte panose[10];

    FT_ULong ulUnicodeRange1;
    FT_ULong ulUnicodeRange2;
    FT_ULong ulUnicodeRange3;
    FT_ULong ulUnicodeRange4;

    FT_Char achVendID[4];

    FT_UShort fsSelection;
    FT_UShort usFirstCharIndex;
    FT_UShort usLastCharIndex;
    FT_Short sTypoAscender;
    FT_Short sTypoDescender;
    FT_Short sTypoLineGap;
    FT_UShort usWinAscent;
    FT_UShort usWinDescent;



    FT_ULong ulCodePageRange1;
    FT_ULong ulCodePageRange2;



    FT_Short sxHeight;
    FT_Short sCapHeight;
    FT_UShort usDefaultChar;
    FT_UShort usBreakChar;
    FT_UShort usMaxContext;



    FT_UShort usLowerOpticalPointSize;
    FT_UShort usUpperOpticalPointSize;

  } TT_OS2;
# 437 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_Postscript_
  {
    FT_Fixed FormatType;
    FT_Fixed italicAngle;
    FT_Short underlinePosition;
    FT_Short underlineThickness;
    FT_ULong isFixedPitch;
    FT_ULong minMemType42;
    FT_ULong maxMemType42;
    FT_ULong minMemType1;
    FT_ULong maxMemType1;




  } TT_Postscript;
# 464 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_PCLT_
  {
    FT_Fixed Version;
    FT_ULong FontNumber;
    FT_UShort Pitch;
    FT_UShort xHeight;
    FT_UShort Style;
    FT_UShort TypeFamily;
    FT_UShort CapHeight;
    FT_UShort SymbolSet;
    FT_Char TypeFace[16];
    FT_Char CharacterComplement[8];
    FT_Char FileName[6];
    FT_Char StrokeWeight;
    FT_Char WidthType;
    FT_Byte SerifStyle;
    FT_Byte Reserved;

  } TT_PCLT;
# 551 "../../../libs/freetype/include/freetype/tttables.h"
  typedef struct TT_MaxProfile_
  {
    FT_Fixed version;
    FT_UShort numGlyphs;
    FT_UShort maxPoints;
    FT_UShort maxContours;
    FT_UShort maxCompositePoints;
    FT_UShort maxCompositeContours;
    FT_UShort maxZones;
    FT_UShort maxTwilightPoints;
    FT_UShort maxStorage;
    FT_UShort maxFunctionDefs;
    FT_UShort maxInstructionDefs;
    FT_UShort maxStackElements;
    FT_UShort maxSizeOfInstructions;
    FT_UShort maxComponentElements;
    FT_UShort maxComponentDepth;

  } TT_MaxProfile;
# 596 "../../../libs/freetype/include/freetype/tttables.h"
  typedef enum FT_Sfnt_Tag_
  {
    FT_SFNT_HEAD,
    FT_SFNT_MAXP,
    FT_SFNT_OS2,
    FT_SFNT_HHEA,
    FT_SFNT_VHEA,
    FT_SFNT_POST,
    FT_SFNT_PCLT,

    FT_SFNT_MAX

  } FT_Sfnt_Tag;
# 659 "../../../libs/freetype/include/freetype/tttables.h"
  extern void*
  FT_Get_Sfnt_Table( FT_Face face,
                     FT_Sfnt_Tag tag );
# 728 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_Error
  FT_Load_Sfnt_Table( FT_Face face,
                      FT_ULong tag,
                      FT_Long offset,
                      FT_Byte* buffer,
                      FT_ULong* length );
# 771 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_Error
  FT_Sfnt_Table_Info( FT_Face face,
                      FT_UInt table_index,
                      FT_ULong *tag,
                      FT_ULong *length );
# 798 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_ULong
  FT_Get_CMap_Language_ID( FT_CharMap charmap );
# 818 "../../../libs/freetype/include/freetype/tttables.h"
  extern FT_Long
  FT_Get_CMap_Format( FT_CharMap charmap );





# 26 "../../../libs/freetype/include/freetype/internal/tttypes.h" 2



# 1 "../../../libs/freetype/include/freetype/ftmm.h" 1
# 27 "../../../libs/freetype/include/freetype/ftmm.h"

# 73 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_MM_Axis_
  {
    FT_String* name;
    FT_Long minimum;
    FT_Long maximum;

  } FT_MM_Axis;
# 103 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_Multi_Master_
  {
    FT_UInt num_axis;
    FT_UInt num_designs;
    FT_MM_Axis axis[4];

  } FT_Multi_Master;
# 140 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_Var_Axis_
  {
    FT_String* name;

    FT_Fixed minimum;
    FT_Fixed def;
    FT_Fixed maximum;

    FT_ULong tag;
    FT_UInt strid;

  } FT_Var_Axis;
# 170 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_Var_Named_Style_
  {
    FT_Fixed* coords;
    FT_UInt strid;

  } FT_Var_Named_Style;
# 214 "../../../libs/freetype/include/freetype/ftmm.h"
  typedef struct FT_MM_Var_
  {
    FT_UInt num_axis;
    FT_UInt num_designs;
    FT_UInt num_namedstyles;
    FT_Var_Axis* axis;
    FT_Var_Named_Style* namedstyle;

  } FT_MM_Var;
# 244 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Get_Multi_Master( FT_Face face,
                       FT_Multi_Master *amaster );
# 268 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Get_MM_Var( FT_Face face,
                 FT_MM_Var* *amaster );
# 298 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_MM_Design_Coordinates( FT_Face face,
                                FT_UInt num_coords,
                                FT_Long* coords );
# 327 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_Var_Design_Coordinates( FT_Face face,
                                 FT_UInt num_coords,
                                 FT_Fixed* coords );
# 357 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_MM_Blend_Coordinates( FT_Face face,
                               FT_UInt num_coords,
                               FT_Fixed* coords );
# 371 "../../../libs/freetype/include/freetype/ftmm.h"
  extern FT_Error
  FT_Set_Var_Blend_Coordinates( FT_Face face,
                                FT_UInt num_coords,
                                FT_Fixed* coords );





# 30 "../../../libs/freetype/include/freetype/internal/tttypes.h" 2




# 70 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TTC_HeaderRec_
  {
    FT_ULong tag;
    FT_Fixed version;
    FT_Long count;
    FT_ULong* offsets;

  } TTC_HeaderRec;
# 99 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct SFNT_HeaderRec_
  {
    FT_ULong format_tag;
    FT_UShort num_tables;
    FT_UShort search_range;
    FT_UShort entry_selector;
    FT_UShort range_shift;

    FT_ULong offset;

  } SFNT_HeaderRec, *SFNT_Header;
# 130 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_TableRec_
  {
    FT_ULong Tag;
    FT_ULong CheckSum;
    FT_ULong Offset;
    FT_ULong Length;

  } TT_TableRec, *TT_Table;
# 153 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct WOFF_HeaderRec_
  {
    FT_ULong signature;
    FT_ULong flavor;
    FT_ULong length;
    FT_UShort num_tables;
    FT_UShort reserved;
    FT_ULong totalSfntSize;
    FT_UShort majorVersion;
    FT_UShort minorVersion;
    FT_ULong metaOffset;
    FT_ULong metaLength;
    FT_ULong metaOrigLength;
    FT_ULong privOffset;
    FT_ULong privLength;

  } WOFF_HeaderRec, *WOFF_Header;
# 196 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct WOFF_TableRec_
  {
    FT_ULong Tag;
    FT_ULong Offset;
    FT_ULong CompLength;
    FT_ULong OrigLength;
    FT_ULong CheckSum;

    FT_ULong OrigOffset;

  } WOFF_TableRec, *WOFF_Table;
# 223 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_LongMetricsRec_
  {
    FT_UShort advance;
    FT_Short bearing;

  } TT_LongMetricsRec, *TT_LongMetrics;
# 240 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Short TT_ShortMetrics;
# 270 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_NameEntryRec_
  {
    FT_UShort platformID;
    FT_UShort encodingID;
    FT_UShort languageID;
    FT_UShort nameID;
    FT_UShort stringLength;
    FT_ULong stringOffset;




    FT_Byte* string;

  } TT_NameEntryRec, *TT_NameEntry;
# 307 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_NameTableRec_
  {
    FT_UShort format;
    FT_UInt numNameRecords;
    FT_UInt storageOffset;
    TT_NameEntryRec* names;
    FT_Stream stream;

  } TT_NameTableRec, *TT_NameTable;
# 346 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_GaspRangeRec_
  {
    FT_UShort maxPPEM;
    FT_UShort gaspFlag;

  } TT_GaspRangeRec, *TT_GaspRange;
# 374 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Gasp_
  {
    FT_UShort version;
    FT_UShort numRanges;
    TT_GaspRange gaspRanges;

  } TT_GaspRec;
# 423 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_MetricsRec_
  {
    FT_UShort height;
    FT_UShort width;

    FT_Short horiBearingX;
    FT_Short horiBearingY;
    FT_UShort horiAdvance;

    FT_Short vertBearingX;
    FT_Short vertBearingY;
    FT_UShort vertAdvance;

  } TT_SBit_MetricsRec, *TT_SBit_Metrics;
# 460 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_Small_Metrics_
  {
    FT_Byte height;
    FT_Byte width;

    FT_Char bearingX;
    FT_Char bearingY;
    FT_Byte advance;

  } TT_SBit_SmallMetricsRec, *TT_SBit_SmallMetrics;
# 523 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_LineMetricsRec_
  {
    FT_Char ascender;
    FT_Char descender;
    FT_Byte max_width;
    FT_Char caret_slope_numerator;
    FT_Char caret_slope_denominator;
    FT_Char caret_offset;
    FT_Char min_origin_SB;
    FT_Char min_advance_SB;
    FT_Char max_before_BL;
    FT_Char min_after_BL;
    FT_Char pads[2];

  } TT_SBit_LineMetricsRec, *TT_SBit_LineMetrics;
# 577 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_RangeRec_
  {
    FT_UShort first_glyph;
    FT_UShort last_glyph;

    FT_UShort index_format;
    FT_UShort image_format;
    FT_ULong image_offset;

    FT_ULong image_size;
    TT_SBit_MetricsRec metrics;
    FT_ULong num_glyphs;

    FT_ULong* glyph_offsets;
    FT_UShort* glyph_codes;

    FT_ULong table_offset;

  } TT_SBit_RangeRec, *TT_SBit_Range;
# 639 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_StrikeRec_
  {
    FT_Int num_ranges;
    TT_SBit_Range sbit_ranges;
    FT_ULong ranges_offset;

    FT_ULong color_ref;

    TT_SBit_LineMetricsRec hori;
    TT_SBit_LineMetricsRec vert;

    FT_UShort start_glyph;
    FT_UShort end_glyph;

    FT_Byte x_ppem;
    FT_Byte y_ppem;

    FT_Byte bit_depth;
    FT_Char flags;

  } TT_SBit_StrikeRec, *TT_SBit_Strike;
# 677 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_ComponentRec_
  {
    FT_UShort glyph_code;
    FT_Char x_offset;
    FT_Char y_offset;

  } TT_SBit_ComponentRec, *TT_SBit_Component;
# 708 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SBit_ScaleRec_
  {
    TT_SBit_LineMetricsRec hori;
    TT_SBit_LineMetricsRec vert;

    FT_Byte x_ppem;
    FT_Byte y_ppem;

    FT_Byte x_ppem_substitute;
    FT_Byte y_ppem_substitute;

  } TT_SBit_ScaleRec, *TT_SBit_Scale;
# 753 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_20Rec_
  {
    FT_UShort num_glyphs;
    FT_UShort num_names;
    FT_UShort* glyph_indices;
    FT_Char** glyph_names;

  } TT_Post_20Rec, *TT_Post_20;
# 778 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_25_
  {
    FT_UShort num_glyphs;
    FT_Char* offsets;

  } TT_Post_25Rec, *TT_Post_25;
# 801 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_Post_NamesRec_
  {
    FT_Bool loaded;

    union
    {
      TT_Post_20Rec format_20;
      TT_Post_25Rec format_25;

    } names;

  } TT_Post_NamesRec, *TT_Post_Names;
# 829 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct GX_BlendRec_ *GX_Blend;
# 886 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_BDFRec_
  {
    FT_Byte* table;
    FT_Byte* table_end;
    FT_Byte* strings;
    FT_ULong strings_size;
    FT_UInt num_strikes;
    FT_Bool loaded;

  } TT_BDFRec, *TT_BDF;
# 937 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_FaceRec_* TT_Face;



  typedef FT_Error
  (*TT_Interpreter)( void* exec_context );


  typedef struct TT_LoaderRec_* TT_Loader;
# 973 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_GotoTableFunc)( TT_Face face,
                              FT_ULong tag,
                              FT_Stream stream,
                              FT_ULong* length );
# 1008 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_StartGlyphFunc)( TT_Loader loader,
                               FT_UInt glyph_index,
                               FT_ULong offset,
                               FT_UInt byte_count );
# 1030 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef FT_Error
  (*TT_Loader_ReadGlyphFunc)( TT_Loader loader );
# 1045 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef void
  (*TT_Loader_EndGlyphFunc)( TT_Loader loader );


  typedef enum TT_SbitTableType_
  {
    TT_SBIT_TABLE_TYPE_NONE = 0,
    TT_SBIT_TABLE_TYPE_EBLC,

    TT_SBIT_TABLE_TYPE_CBLC,
    TT_SBIT_TABLE_TYPE_SBIX,


    TT_SBIT_TABLE_TYPE_MAX

  } TT_SbitTableType;
# 1251 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_FaceRec_
  {
    FT_FaceRec root;

    TTC_HeaderRec ttc_header;

    FT_ULong format_tag;
    FT_UShort num_tables;
    TT_Table dir_tables;

    TT_Header header;
    TT_HoriHeader horizontal;

    TT_MaxProfile max_profile;

    FT_Bool vertical_info;
    TT_VertHeader vertical;

    FT_UShort num_names;
    TT_NameTableRec name_table;

    TT_OS2 os2;
    TT_Postscript postscript;

    FT_Byte* cmap_table;
    FT_ULong cmap_size;

    TT_Loader_GotoTableFunc goto_table;

    TT_Loader_StartGlyphFunc access_glyph_frame;
    TT_Loader_EndGlyphFunc forget_glyph_frame;
    TT_Loader_ReadGlyphFunc read_glyph_header;
    TT_Loader_ReadGlyphFunc read_simple_glyph;
    TT_Loader_ReadGlyphFunc read_composite_glyph;



    void* sfnt;



    void* psnames;
# 1302 "../../../libs/freetype/include/freetype/internal/tttypes.h"
    TT_GaspRec gasp;


    TT_PCLT pclt;


    FT_ULong num_sbit_scales;
    TT_SBit_Scale sbit_scales;


    TT_Post_NamesRec postscript_names;
# 1322 "../../../libs/freetype/include/freetype/internal/tttypes.h"
    FT_ULong font_program_size;
    FT_Byte* font_program;


    FT_ULong cvt_program_size;
    FT_Byte* cvt_program;


    FT_ULong cvt_size;
    FT_Short* cvt;



    TT_Interpreter interpreter;
# 1349 "../../../libs/freetype/include/freetype/internal/tttypes.h"
    FT_Generic extra;

    const char* postscript_name;

    FT_ULong glyf_len;


    FT_Bool doblend;
    GX_Blend blend;




    FT_Byte* horz_metrics;
    FT_ULong horz_metrics_size;

    FT_Byte* vert_metrics;
    FT_ULong vert_metrics_size;

    FT_ULong num_locations;
    FT_Byte* glyph_locations;

    FT_Byte* hdmx_table;
    FT_ULong hdmx_table_size;
    FT_UInt hdmx_record_count;
    FT_ULong hdmx_record_size;
    FT_Byte* hdmx_record_sizes;

    FT_Byte* sbit_table;
    FT_ULong sbit_table_size;
    TT_SbitTableType sbit_table_type;
    FT_UInt sbit_num_strikes;

    FT_Byte* kern_table;
    FT_ULong kern_table_size;
    FT_UInt num_kern_tables;
    FT_UInt32 kern_avail_bits;
    FT_UInt32 kern_order_bits;


    TT_BDFRec bdf;



    FT_ULong horz_metrics_offset;
    FT_ULong vert_metrics_offset;



    FT_ULong sph_found_func_flags;

    FT_Bool sph_compatibility_mode;


  } TT_FaceRec;
# 1437 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_GlyphZoneRec_
  {
    FT_Memory memory;
    FT_UShort max_points;
    FT_Short max_contours;
    FT_UShort n_points;
    FT_Short n_contours;

    FT_Vector* org;
    FT_Vector* cur;
    FT_Vector* orus;

    FT_Byte* tags;
    FT_UShort* contours;

    FT_UShort first_point;

  } TT_GlyphZoneRec, *TT_GlyphZone;



  typedef struct TT_ExecContextRec_* TT_ExecContext;
# 1469 "../../../libs/freetype/include/freetype/internal/tttypes.h"
  typedef struct TT_SizeRec_* TT_Size;



  typedef struct TT_LoaderRec_
  {
    TT_Face face;
    TT_Size size;
    FT_GlyphSlot glyph;
    FT_GlyphLoader gloader;

    FT_ULong load_flags;
    FT_UInt glyph_index;

    FT_Stream stream;
    FT_Int byte_len;

    FT_Short n_contours;
    FT_BBox bbox;
    FT_Int left_bearing;
    FT_Int advance;
    FT_Int linear;
    FT_Bool linear_def;
    FT_Vector pp1;
    FT_Vector pp2;

    FT_ULong glyf_offset;


    TT_GlyphZoneRec base;
    TT_GlyphZoneRec zone;

    TT_ExecContext exec;
    FT_Byte* instructions;
    FT_ULong ins_pos;


    void* other;


    FT_Int top_bearing;
    FT_Int vadvance;
    FT_Vector pp3;
    FT_Vector pp4;


    FT_Byte* cursor;
    FT_Byte* limit;


    FT_ListRec composites;

  } TT_LoaderRec;



# 27 "../../../libs/freetype/src/cff/cffobjs.h" 2





# 42 "../../../libs/freetype/src/cff/cffobjs.h"
  typedef struct CFF_DriverRec_* CFF_Driver;

  typedef TT_Face CFF_Face;
# 55 "../../../libs/freetype/src/cff/cffobjs.h"
  typedef struct CFF_SizeRec_
  {
    FT_SizeRec root;
    FT_ULong strike_index;

  } CFF_SizeRec, *CFF_Size;
# 71 "../../../libs/freetype/src/cff/cffobjs.h"
  typedef struct CFF_GlyphSlotRec_
  {
    FT_GlyphSlotRec root;

    FT_Bool hint;
    FT_Bool scaled;

    FT_Fixed x_scale;
    FT_Fixed y_scale;

  } CFF_GlyphSlotRec, *CFF_GlyphSlot;
# 92 "../../../libs/freetype/src/cff/cffobjs.h"
  typedef struct CFF_InternalRec_
  {
    PSH_Globals topfont;
    PSH_Globals subfonts[256];

  } CFF_InternalRec, *CFF_Internal;






  typedef struct CFF_Transform_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;
    FT_F26Dot6 ox, oy;

  } CFF_Transform;






  typedef struct CFF_DriverRec_
  {
    FT_DriverRec root;

    FT_UInt hinting_engine;
    FT_Bool no_stem_darkening;

    FT_Int darken_params[8];

  } CFF_DriverRec;


  static FT_Error
  cff_size_init( FT_Size size );

  static void
  cff_size_done( FT_Size size );

  static FT_Error
  cff_size_request( FT_Size size,
                    FT_Size_Request req );



  static FT_Error
  cff_size_select( FT_Size size,
                   FT_ULong strike_index );



  static void
  cff_slot_done( FT_GlyphSlot slot );

  static FT_Error
  cff_slot_init( FT_GlyphSlot slot );






  static FT_Error
  cff_face_init( FT_Stream stream,
                 FT_Face face,
                 FT_Int face_index,
                 FT_Int num_params,
                 FT_Parameter* params );

  static void
  cff_face_done( FT_Face face );






  static FT_Error
  cff_driver_init( FT_Module module );

  static void
  cff_driver_done( FT_Module module );



# 23 "../../../libs/freetype/src/cff/cffcmap.h" 2


# 36 "../../../libs/freetype/src/cff/cffcmap.h"
  typedef struct CFF_CMapStdRec_* CFF_CMapStd;

  typedef struct CFF_CMapStdRec_
  {
    FT_CMapRec cmap;
    FT_UShort* gids;

  } CFF_CMapStdRec;


  extern const FT_CMap_ClassRec cff_cmap_encoding_class_rec;
# 59 "../../../libs/freetype/src/cff/cffcmap.h"
  extern const FT_CMap_ClassRec cff_cmap_unicode_class_rec;



# 23 "../../../libs/freetype/src/cff/cffpic.c" 2
# 1 "../../../libs/freetype/src/cff/cffpic.h" 1
# 24 "../../../libs/freetype/src/cff/cffpic.c" 2
# 1 "../../../libs/freetype/src/cff/cfferrs.h" 1
# 37 "../../../libs/freetype/src/cff/cfferrs.h"
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  CFF_Err_Ok = 0x00,


  CFF_Err_Cannot_Open_Resource = 0x01 + 0,

  CFF_Err_Unknown_File_Format = 0x02 + 0,

  CFF_Err_Invalid_File_Format = 0x03 + 0,

  CFF_Err_Invalid_Version = 0x04 + 0,

  CFF_Err_Lower_Module_Version = 0x05 + 0,

  CFF_Err_Invalid_Argument = 0x06 + 0,

  CFF_Err_Unimplemented_Feature = 0x07 + 0,

  CFF_Err_Invalid_Table = 0x08 + 0,

  CFF_Err_Invalid_Offset = 0x09 + 0,

  CFF_Err_Array_Too_Large = 0x0A + 0,

  CFF_Err_Missing_Module = 0x0B + 0,

  CFF_Err_Missing_Property = 0x0C + 0,




  CFF_Err_Invalid_Glyph_Index = 0x10 + 0,

  CFF_Err_Invalid_Character_Code = 0x11 + 0,

  CFF_Err_Invalid_Glyph_Format = 0x12 + 0,

  CFF_Err_Cannot_Render_Glyph = 0x13 + 0,

  CFF_Err_Invalid_Outline = 0x14 + 0,

  CFF_Err_Invalid_Composite = 0x15 + 0,

  CFF_Err_Too_Many_Hints = 0x16 + 0,

  CFF_Err_Invalid_Pixel_Size = 0x17 + 0,




  CFF_Err_Invalid_Handle = 0x20 + 0,

  CFF_Err_Invalid_Library_Handle = 0x21 + 0,

  CFF_Err_Invalid_Driver_Handle = 0x22 + 0,

  CFF_Err_Invalid_Face_Handle = 0x23 + 0,

  CFF_Err_Invalid_Size_Handle = 0x24 + 0,

  CFF_Err_Invalid_Slot_Handle = 0x25 + 0,

  CFF_Err_Invalid_CharMap_Handle = 0x26 + 0,

  CFF_Err_Invalid_Cache_Handle = 0x27 + 0,

  CFF_Err_Invalid_Stream_Handle = 0x28 + 0,




  CFF_Err_Too_Many_Drivers = 0x30 + 0,

  CFF_Err_Too_Many_Extensions = 0x31 + 0,




  CFF_Err_Out_Of_Memory = 0x40 + 0,

  CFF_Err_Unlisted_Object = 0x41 + 0,




  CFF_Err_Cannot_Open_Stream = 0x51 + 0,

  CFF_Err_Invalid_Stream_Seek = 0x52 + 0,

  CFF_Err_Invalid_Stream_Skip = 0x53 + 0,

  CFF_Err_Invalid_Stream_Read = 0x54 + 0,

  CFF_Err_Invalid_Stream_Operation = 0x55 + 0,

  CFF_Err_Invalid_Frame_Operation = 0x56 + 0,

  CFF_Err_Nested_Frame_Access = 0x57 + 0,

  CFF_Err_Invalid_Frame_Read = 0x58 + 0,




  CFF_Err_Raster_Uninitialized = 0x60 + 0,

  CFF_Err_Raster_Corrupted = 0x61 + 0,

  CFF_Err_Raster_Overflow = 0x62 + 0,

  CFF_Err_Raster_Negative_Height = 0x63 + 0,




  CFF_Err_Too_Many_Caches = 0x70 + 0,




  CFF_Err_Invalid_Opcode = 0x80 + 0,

  CFF_Err_Too_Few_Arguments = 0x81 + 0,

  CFF_Err_Stack_Overflow = 0x82 + 0,

  CFF_Err_Code_Overflow = 0x83 + 0,

  CFF_Err_Bad_Argument = 0x84 + 0,

  CFF_Err_Divide_By_Zero = 0x85 + 0,

  CFF_Err_Invalid_Reference = 0x86 + 0,

  CFF_Err_Debug_OpCode = 0x87 + 0,

  CFF_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  CFF_Err_Nested_DEFS = 0x89 + 0,

  CFF_Err_Invalid_CodeRange = 0x8A + 0,

  CFF_Err_Execution_Too_Long = 0x8B + 0,

  CFF_Err_Too_Many_Function_Defs = 0x8C + 0,

  CFF_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  CFF_Err_Table_Missing = 0x8E + 0,

  CFF_Err_Horiz_Header_Missing = 0x8F + 0,

  CFF_Err_Locations_Missing = 0x90 + 0,

  CFF_Err_Name_Table_Missing = 0x91 + 0,

  CFF_Err_CMap_Table_Missing = 0x92 + 0,

  CFF_Err_Hmtx_Table_Missing = 0x93 + 0,

  CFF_Err_Post_Table_Missing = 0x94 + 0,

  CFF_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  CFF_Err_Invalid_CharMap_Format = 0x96 + 0,

  CFF_Err_Invalid_PPem = 0x97 + 0,

  CFF_Err_Invalid_Vert_Metrics = 0x98 + 0,

  CFF_Err_Could_Not_Find_Context = 0x99 + 0,

  CFF_Err_Invalid_Post_Table_Format = 0x9A + 0,

  CFF_Err_Invalid_Post_Table = 0x9B + 0,




  CFF_Err_Syntax_Error = 0xA0 + 0,

  CFF_Err_Stack_Underflow = 0xA1 + 0,

  CFF_Err_Ignore = 0xA2 + 0,

  CFF_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  CFF_Err_Glyph_Too_Big = 0xA4 + 0,




  CFF_Err_Missing_Startfont_Field = 0xB0 + 0,

  CFF_Err_Missing_Font_Field = 0xB1 + 0,

  CFF_Err_Missing_Size_Field = 0xB2 + 0,

  CFF_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  CFF_Err_Missing_Chars_Field = 0xB4 + 0,

  CFF_Err_Missing_Startchar_Field = 0xB5 + 0,

  CFF_Err_Missing_Encoding_Field = 0xB6 + 0,

  CFF_Err_Missing_Bbx_Field = 0xB7 + 0,

  CFF_Err_Bbx_Too_Big = 0xB8 + 0,

  CFF_Err_Corrupted_Font_Header = 0xB9 + 0,

  CFF_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  CFF_Err_Max };
# 38 "../../../libs/freetype/src/cff/cfferrs.h" 2
# 25 "../../../libs/freetype/src/cff/cffpic.c" 2
# 24 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cffdrivr.c" 1
# 21 "../../../libs/freetype/src/cff/cffdrivr.c"
# 1 "../../../libs/freetype/include/freetype/internal/ftdebug.h" 1
# 33 "../../../libs/freetype/include/freetype/internal/ftdebug.h"

# 116 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern FT_Int
  FT_Trace_Get_Count( void );
# 143 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern const char*
  FT_Trace_Get_Name( FT_Int idx );
# 247 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern void
  ft_debug_init( void );


# 22 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftstream.h" 1
# 28 "../../../libs/freetype/include/freetype/internal/ftstream.h"

# 57 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  typedef enum FT_Frame_Op_
  {
    ft_frame_end = 0,
    ft_frame_start = ( ( 1 << 2 ) | ( 0 << 1 ) | 0 ),

    ft_frame_byte = ( ( 2 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_schar = ( ( 2 << 2 ) | ( 0 << 1 ) | 1 ),

    ft_frame_ushort_be = ( ( 3 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_short_be = ( ( 3 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_ushort_le = ( ( 3 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_short_le = ( ( 3 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_ulong_be = ( ( 4 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_long_be = ( ( 4 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_ulong_le = ( ( 4 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_long_le = ( ( 4 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_uoff3_be = ( ( 5 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_off3_be = ( ( 5 << 2 ) | ( 0 << 1 ) | 1 ),
    ft_frame_uoff3_le = ( ( 5 << 2 ) | ( 1 << 1 ) | 0 ),
    ft_frame_off3_le = ( ( 5 << 2 ) | ( 1 << 1 ) | 1 ),

    ft_frame_bytes = ( ( 6 << 2 ) | ( 0 << 1 ) | 0 ),
    ft_frame_skip = ( ( 6 << 2 ) | ( 0 << 1 ) | 1 )

  } FT_Frame_Op;


  typedef struct FT_Frame_Field_
  {
    FT_Byte value;
    FT_Byte size;
    FT_UShort offset;

  } FT_Frame_Field;
# 324 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_Open( FT_Stream stream,
                  const char* filepathname );





  extern FT_Error
  FT_Stream_New( FT_Library library,
                 const FT_Open_Args* args,
                 FT_Stream *astream );


  extern void
  FT_Stream_Free( FT_Stream stream,
                  FT_Int external );


  extern void
  FT_Stream_OpenMemory( FT_Stream stream,
                        const FT_Byte* base,
                        FT_ULong size );


  extern void
  FT_Stream_Close( FT_Stream stream );



  extern FT_Error
  FT_Stream_Seek( FT_Stream stream,
                  FT_ULong pos );


  extern FT_Error
  FT_Stream_Skip( FT_Stream stream,
                  FT_Long distance );


  extern FT_ULong
  FT_Stream_Pos( FT_Stream stream );



  extern FT_Error
  FT_Stream_Read( FT_Stream stream,
                  FT_Byte* buffer,
                  FT_ULong count );


  extern FT_Error
  FT_Stream_ReadAt( FT_Stream stream,
                    FT_ULong pos,
                    FT_Byte* buffer,
                    FT_ULong count );



  extern FT_ULong
  FT_Stream_TryRead( FT_Stream stream,
                     FT_Byte* buffer,
                     FT_ULong count );
# 396 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_EnterFrame( FT_Stream stream,
                        FT_ULong count );


  extern void
  FT_Stream_ExitFrame( FT_Stream stream );
# 413 "../../../libs/freetype/include/freetype/internal/ftstream.h"
  extern FT_Error
  FT_Stream_ExtractFrame( FT_Stream stream,
                          FT_ULong count,
                          FT_Byte** pbytes );


  extern void
  FT_Stream_ReleaseFrame( FT_Stream stream,
                          FT_Byte** pbytes );


  extern FT_Char
  FT_Stream_GetChar( FT_Stream stream );


  extern FT_UShort
  FT_Stream_GetUShort( FT_Stream stream );


  extern FT_ULong
  FT_Stream_GetUOffset( FT_Stream stream );


  extern FT_ULong
  FT_Stream_GetULong( FT_Stream stream );


  extern FT_UShort
  FT_Stream_GetUShortLE( FT_Stream stream );


  extern FT_ULong
  FT_Stream_GetULongLE( FT_Stream stream );



  extern FT_Char
  FT_Stream_ReadChar( FT_Stream stream,
                      FT_Error* error );


  extern FT_UShort
  FT_Stream_ReadUShort( FT_Stream stream,
                        FT_Error* error );


  extern FT_ULong
  FT_Stream_ReadUOffset( FT_Stream stream,
                         FT_Error* error );


  extern FT_ULong
  FT_Stream_ReadULong( FT_Stream stream,
                       FT_Error* error );


  extern FT_UShort
  FT_Stream_ReadUShortLE( FT_Stream stream,
                          FT_Error* error );


  extern FT_ULong
  FT_Stream_ReadULongLE( FT_Stream stream,
                         FT_Error* error );



  extern FT_Error
  FT_Stream_ReadFields( FT_Stream stream,
                        const FT_Frame_Field* fields,
                        void* structure );
# 531 "../../../libs/freetype/include/freetype/internal/ftstream.h"

# 23 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/sfnt.h" 1
# 28 "../../../libs/freetype/include/freetype/internal/sfnt.h"

# 68 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Init_Face_Func)( FT_Stream stream,
                        TT_Face face,
                        FT_Int face_index,
                        FT_Int num_params,
                        FT_Parameter* params );
# 106 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Face_Func)( FT_Stream stream,
                        TT_Face face,
                        FT_Int face_index,
                        FT_Int num_params,
                        FT_Parameter* params );
# 128 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef void
  (*TT_Done_Face_Func)( TT_Face face );
# 172 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Any_Func)( TT_Face face,
                       FT_ULong tag,
                       FT_Long offset,
                       FT_Byte *buffer,
                       FT_ULong* length );
# 208 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Find_SBit_Image_Func)( TT_Face face,
                              FT_UInt glyph_index,
                              FT_ULong strike_index,
                              TT_SBit_Range *arange,
                              TT_SBit_Strike *astrike,
                              FT_ULong *aglyph_offset );
# 244 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SBit_Metrics_Func)( FT_Stream stream,
                                TT_SBit_Range range,
                                TT_SBit_Metrics metrics );
# 289 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_SBit_Image_Func)( TT_Face face,
                              FT_ULong strike_index,
                              FT_UInt glyph_index,
                              FT_UInt load_flags,
                              FT_Stream stream,
                              FT_Bitmap *amap,
                              TT_SBit_MetricsRec *ametrics );
# 319 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Set_SBit_Strike_Func)( TT_Face face,
                              FT_Size_Request req,
                              FT_ULong* astrike_index );
# 345 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Strike_Metrics_Func)( TT_Face face,
                                  FT_ULong strike_index,
                                  FT_Size_Metrics* metrics );
# 370 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Get_PS_Name_Func)( TT_Face face,
                          FT_UInt idx,
                          FT_String** PSname );
# 395 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Metrics_Func)( TT_Face face,
                           FT_Stream stream,
                           FT_Bool vertical );
# 423 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef void
  (*TT_Get_Metrics_Func)( TT_Face face,
                          FT_Bool vertical,
                          FT_UInt gindex,
                          FT_Short* abearing,
                          FT_UShort* aadvance );
# 452 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Get_Name_Func)( TT_Face face,
                       FT_UShort nameid,
                       FT_String** name );
# 478 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Error
  (*TT_Load_Table_Func)( TT_Face face,
                         FT_Stream stream );
# 494 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef void
  (*TT_Free_Table_Func)( TT_Face face );
# 513 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef FT_Int
  (*TT_Face_GetKerningFunc)( TT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph );
# 531 "../../../libs/freetype/include/freetype/internal/sfnt.h"
  typedef struct SFNT_Interface_
  {
    TT_Loader_GotoTableFunc goto_table;

    TT_Init_Face_Func init_face;
    TT_Load_Face_Func load_face;
    TT_Done_Face_Func done_face;
    FT_Module_Requester get_interface;

    TT_Load_Any_Func load_any;



    TT_Load_Table_Func load_head;
    TT_Load_Metrics_Func load_hhea;
    TT_Load_Table_Func load_cmap;
    TT_Load_Table_Func load_maxp;
    TT_Load_Table_Func load_os2;
    TT_Load_Table_Func load_post;

    TT_Load_Table_Func load_name;
    TT_Free_Table_Func free_name;


    TT_Load_Table_Func load_kern;

    TT_Load_Table_Func load_gasp;
    TT_Load_Table_Func load_pclt;



    TT_Load_Table_Func load_bhed;

    TT_Load_SBit_Image_Func load_sbit_image;


    TT_Get_PS_Name_Func get_psname;
    TT_Free_Table_Func free_psnames;




    TT_Face_GetKerningFunc get_kerning;





    TT_Load_Table_Func load_font_dir;
    TT_Load_Metrics_Func load_hmtx;

    TT_Load_Table_Func load_eblc;
    TT_Free_Table_Func free_eblc;

    TT_Set_SBit_Strike_Func set_sbit_strike;
    TT_Load_Strike_Metrics_Func load_strike_metrics;

    TT_Get_Metrics_Func get_metrics;

    TT_Get_Name_Func get_name;

  } SFNT_Interface;



  typedef SFNT_Interface* SFNT_Service;
# 743 "../../../libs/freetype/include/freetype/internal/sfnt.h"

# 24 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svcid.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svcid.h"





  typedef FT_Error
  (*FT_CID_GetRegistryOrderingSupplementFunc)( FT_Face face,
                                               const char* *registry,
                                               const char* *ordering,
                                               FT_Int *supplement );
  typedef FT_Error
  (*FT_CID_GetIsInternallyCIDKeyedFunc)( FT_Face face,
                                         FT_Bool *is_cid );
  typedef FT_Error
  (*FT_CID_GetCIDFromGlyphIndexFunc)( FT_Face face,
                                      FT_UInt glyph_index,
                                      FT_UInt *cid );

  typedef struct FT_Service_CIDRec_ FT_Service_CIDRec ; typedef struct FT_Service_CIDRec_ const * FT_Service_CID ; struct FT_Service_CIDRec_
  {
    FT_CID_GetRegistryOrderingSupplementFunc get_ros;
    FT_CID_GetIsInternallyCIDKeyedFunc get_is_cid;
    FT_CID_GetCIDFromGlyphIndexFunc get_cid_from_glyph_index;
  };
# 84 "../../../libs/freetype/include/freetype/internal/services/svcid.h"

# 25 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svpsinfo.h" 1
# 23 "../../../libs/freetype/include/freetype/internal/services/svpsinfo.h"
# 1 "../../../libs/freetype/include/freetype/internal/t1types.h" 1
# 31 "../../../libs/freetype/include/freetype/internal/t1types.h"

# 69 "../../../libs/freetype/include/freetype/internal/t1types.h"
  typedef struct T1_EncodingRecRec_
  {
    FT_Int num_chars;
    FT_Int code_first;
    FT_Int code_last;

    FT_UShort* char_index;
    FT_String** char_name;

  } T1_EncodingRec, *T1_Encoding;







  typedef struct PS_FontExtraRec_
  {
    FT_UShort fs_type;

  } PS_FontExtraRec;


  typedef struct T1_FontRec_
  {
    PS_FontInfoRec font_info;
    PS_FontExtraRec font_extra;
    PS_PrivateRec private_dict;
    FT_String* font_name;

    T1_EncodingType encoding_type;
    T1_EncodingRec encoding;

    FT_Byte* subrs_block;
    FT_Byte* charstrings_block;
    FT_Byte* glyph_names_block;

    FT_Int num_subrs;
    FT_Byte** subrs;
    FT_UInt* subrs_len;

    FT_Int num_glyphs;
    FT_String** glyph_names;
    FT_Byte** charstrings;
    FT_UInt* charstrings_len;

    FT_Byte paint_type;
    FT_Byte font_type;
    FT_Matrix font_matrix;
    FT_Vector font_offset;
    FT_BBox font_bbox;
    FT_Long font_id;

    FT_Fixed stroke_width;

  } T1_FontRec, *T1_Font;


  typedef struct CID_SubrsRec_
  {
    FT_Int num_subrs;
    FT_Byte** code;

  } CID_SubrsRec, *CID_Subrs;
# 148 "../../../libs/freetype/include/freetype/internal/t1types.h"
  typedef struct AFM_TrackKernRec_
  {
    FT_Int degree;
    FT_Fixed min_ptsize;
    FT_Fixed min_kern;
    FT_Fixed max_ptsize;
    FT_Fixed max_kern;

  } AFM_TrackKernRec, *AFM_TrackKern;

  typedef struct AFM_KernPairRec_
  {
    FT_UInt index1;
    FT_UInt index2;
    FT_Int x;
    FT_Int y;

  } AFM_KernPairRec, *AFM_KernPair;

  typedef struct AFM_FontInfoRec_
  {
    FT_Bool IsCIDFont;
    FT_BBox FontBBox;
    FT_Fixed Ascender;
    FT_Fixed Descender;
    AFM_TrackKern TrackKerns;
    FT_UInt NumTrackKern;
    AFM_KernPair KernPairs;
    FT_UInt NumKernPair;

  } AFM_FontInfoRec, *AFM_FontInfo;
# 194 "../../../libs/freetype/include/freetype/internal/t1types.h"
  typedef struct T1_FaceRec_* T1_Face;
  typedef struct CID_FaceRec_* CID_Face;


  typedef struct T1_FaceRec_
  {
    FT_FaceRec root;
    T1_FontRec type1;
    const void* psnames;
    const void* psaux;
    const void* afm_data;
    FT_CharMapRec charmaprecs[2];
    FT_CharMap charmaps[2];


    PS_Blend blend;




    FT_Int ndv_idx;
    FT_Int cdv_idx;



    FT_UInt len_buildchar;
    FT_Long* buildchar;


    const void* pshinter;

  } T1_FaceRec;


  typedef struct CID_FaceRec_
  {
    FT_FaceRec root;
    void* psnames;
    void* psaux;
    CID_FaceInfoRec cid;
    PS_FontExtraRec font_extra;



    CID_Subrs subrs;


    void* pshinter;


    FT_Byte* binary_data;
    FT_Stream cid_stream;

  } CID_FaceRec;



# 24 "../../../libs/freetype/include/freetype/internal/services/svpsinfo.h" 2








  typedef FT_Error
  (*PS_GetFontInfoFunc)( FT_Face face,
                         PS_FontInfoRec* afont_info );

  typedef FT_Error
  (*PS_GetFontExtraFunc)( FT_Face face,
                          PS_FontExtraRec* afont_extra );

  typedef FT_Int
  (*PS_HasGlyphNamesFunc)( FT_Face face );

  typedef FT_Error
  (*PS_GetFontPrivateFunc)( FT_Face face,
                            PS_PrivateRec* afont_private );

  typedef FT_Long
  (*PS_GetFontValueFunc)( FT_Face face,
                          PS_Dict_Keys key,
                          FT_UInt idx,
                          void *value,
                          FT_Long value_len );


  typedef struct FT_Service_PsInfoRec_ FT_Service_PsInfoRec ; typedef struct FT_Service_PsInfoRec_ const * FT_Service_PsInfo ; struct FT_Service_PsInfoRec_
  {
    PS_GetFontInfoFunc ps_get_font_info;
    PS_GetFontExtraFunc ps_get_font_extra;
    PS_HasGlyphNamesFunc ps_has_glyph_names;
    PS_GetFontPrivateFunc ps_get_font_private;
    PS_GetFontValueFunc ps_get_font_value;
  };
# 105 "../../../libs/freetype/include/freetype/internal/services/svpsinfo.h"

# 26 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svpostnm.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svpostnm.h"

# 40 "../../../libs/freetype/include/freetype/internal/services/svpostnm.h"
  typedef const char*
  (*FT_PsName_GetFunc)( FT_Face face );


  typedef struct FT_Service_PsFontNameRec_ FT_Service_PsFontNameRec ; typedef struct FT_Service_PsFontNameRec_ const * FT_Service_PsFontName ; struct FT_Service_PsFontNameRec_
  {
    FT_PsName_GetFunc get_ps_font_name;
  };
# 75 "../../../libs/freetype/include/freetype/internal/services/svpostnm.h"

# 27 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svttcmap.h" 1
# 29 "../../../libs/freetype/include/freetype/internal/services/svttcmap.h"

# 58 "../../../libs/freetype/include/freetype/internal/services/svttcmap.h"
  typedef struct TT_CMapInfo_
  {
    FT_ULong language;
    FT_Long format;

  } TT_CMapInfo;


  typedef FT_Error
  (*TT_CMap_Info_GetFunc)( FT_CharMap charmap,
                           TT_CMapInfo *cmap_info );


  typedef struct FT_Service_TTCMapsRec_ FT_Service_TTCMapsRec ; typedef struct FT_Service_TTCMapsRec_ const * FT_Service_TTCMaps ; struct FT_Service_TTCMapsRec_
  {
    TT_CMap_Info_GetFunc get_cmap_info;
  };
# 101 "../../../libs/freetype/include/freetype/internal/services/svttcmap.h"

# 28 "../../../libs/freetype/src/cff/cffdrivr.c" 2

# 1 "../../../libs/freetype/src/cff/cffdrivr.h" 1
# 27 "../../../libs/freetype/src/cff/cffdrivr.h"



  extern const FT_Driver_ClassRec cff_driver_class;



# 30 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/src/cff/cffgload.h" 1
# 28 "../../../libs/freetype/src/cff/cffgload.h"

# 86 "../../../libs/freetype/src/cff/cffgload.h"
  typedef struct CFF_Builder_
  {
    FT_Memory memory;
    TT_Face face;
    CFF_GlyphSlot glyph;
    FT_GlyphLoader loader;
    FT_Outline* base;
    FT_Outline* current;

    FT_Pos pos_x;
    FT_Pos pos_y;

    FT_Vector left_bearing;
    FT_Vector advance;

    FT_BBox bbox;
    FT_Bool path_begun;
    FT_Bool load_points;
    FT_Bool no_recurse;

    FT_Bool metrics_only;

    void* hints_funcs;
    void* hints_globals;

  } CFF_Builder;


  static FT_Error
  cff_check_points( CFF_Builder* builder,
                    FT_Int count );

  static void
  cff_builder_add_point( CFF_Builder* builder,
                         FT_Pos x,
                         FT_Pos y,
                         FT_Byte flag );
  static FT_Error
  cff_builder_add_point1( CFF_Builder* builder,
                          FT_Pos x,
                          FT_Pos y );
  static FT_Error
  cff_builder_start_point( CFF_Builder* builder,
                           FT_Pos x,
                           FT_Pos y );
  static void
  cff_builder_close_contour( CFF_Builder* builder );


  static FT_Int
  cff_lookup_glyph_by_stdcharcode( CFF_Font cff,
                                   FT_Int charcode );
  static FT_Error
  cff_get_glyph_data( TT_Face face,
                      FT_UInt glyph_index,
                      FT_Byte** pointer,
                      FT_ULong* length );
  static void
  cff_free_glyph_data( TT_Face face,
                       FT_Byte** pointer,
                       FT_ULong length );




  typedef struct CFF_Decoder_Zone_
  {
    FT_Byte* base;
    FT_Byte* limit;
    FT_Byte* cursor;

  } CFF_Decoder_Zone;


  typedef struct CFF_Decoder_
  {
    CFF_Builder builder;
    CFF_Font cff;

    FT_Fixed stack[48 + 1];
    FT_Fixed* top;

    CFF_Decoder_Zone zones[16 + 1];
    CFF_Decoder_Zone* zone;

    FT_Int flex_state;
    FT_Int num_flex_vectors;
    FT_Vector flex_vectors[7];

    FT_Pos glyph_width;
    FT_Pos nominal_width;

    FT_Bool read_width;
    FT_Bool width_only;
    FT_Int num_hints;
    FT_Fixed buildchar[32];

    FT_UInt num_locals;
    FT_UInt num_globals;

    FT_Int locals_bias;
    FT_Int globals_bias;

    FT_Byte** locals;
    FT_Byte** globals;

    FT_Byte** glyph_names;
    FT_UInt num_glyphs;

    FT_Render_Mode hint_mode;

    FT_Bool seac;

    CFF_SubFont current_subfont;

  } CFF_Decoder;


  static void
  cff_decoder_init( CFF_Decoder* decoder,
                    TT_Face face,
                    CFF_Size size,
                    CFF_GlyphSlot slot,
                    FT_Bool hinting,
                    FT_Render_Mode hint_mode );

  static FT_Error
  cff_decoder_prepare( CFF_Decoder* decoder,
                       CFF_Size size,
                       FT_UInt glyph_index );
# 233 "../../../libs/freetype/src/cff/cffgload.h"
  static FT_Error
  cff_slot_load( CFF_GlyphSlot glyph,
                 CFF_Size size,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );



# 31 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/src/cff/cffload.h" 1
# 27 "../../../libs/freetype/src/cff/cffload.h"


  static FT_UShort
  cff_get_standard_encoding( FT_UInt charcode );


  static FT_String*
  cff_index_get_string( CFF_Font font,
                        FT_UInt element );

  static FT_String*
  cff_index_get_sid_string( CFF_Font font,
                            FT_UInt sid );


  static FT_Error
  cff_index_access_element( CFF_Index idx,
                            FT_UInt element,
                            FT_Byte** pbytes,
                            FT_ULong* pbyte_len );

  static void
  cff_index_forget_element( CFF_Index idx,
                            FT_Byte** pbytes );

  static FT_String*
  cff_index_get_name( CFF_Font font,
                      FT_UInt element );


  static FT_UInt
  cff_charset_cid_to_gindex( CFF_Charset charset,
                             FT_UInt cid );


  static FT_Error
  cff_font_load( FT_Library library,
                 FT_Stream stream,
                 FT_Int face_index,
                 CFF_Font font,
                 FT_Bool pure_cff );

  static void
  cff_font_done( CFF_Font font );


  static FT_Byte
  cff_fd_select_get( CFF_FDSelect fdselect,
                     FT_UInt glyph_index );



# 32 "../../../libs/freetype/src/cff/cffdrivr.c" 2

# 1 "../../../libs/freetype/src/cff/cffparse.h" 1
# 28 "../../../libs/freetype/src/cff/cffparse.h"

# 37 "../../../libs/freetype/src/cff/cffparse.h"
  typedef struct CFF_ParserRec_
  {
    FT_Library library;
    FT_Byte* start;
    FT_Byte* limit;
    FT_Byte* cursor;

    FT_Byte* stack[96 + 1];
    FT_Byte** top;

    FT_UInt object_code;
    void* object;

  } CFF_ParserRec, *CFF_Parser;


  static void
  cff_parser_init( CFF_Parser parser,
                   FT_UInt code,
                   void* object,
                   FT_Library library);

  static FT_Error
  cff_parser_run( CFF_Parser parser,
                  FT_Byte* start,
                  FT_Byte* limit );


  enum
  {
    cff_kind_none = 0,
    cff_kind_num,
    cff_kind_fixed,
    cff_kind_fixed_thousand,
    cff_kind_string,
    cff_kind_bool,
    cff_kind_delta,
    cff_kind_callback,

    cff_kind_max
  };



  typedef FT_Error (*CFF_Field_Reader)( CFF_Parser parser );

  typedef struct CFF_Field_Handler_
  {
    int kind;
    int code;
    FT_UInt offset;
    FT_Byte size;
    CFF_Field_Reader reader;
    FT_UInt array_max;
    FT_UInt count_offset;





  } CFF_Field_Handler;



# 34 "../../../libs/freetype/src/cff/cffdrivr.c" 2




# 1 "../../../libs/freetype/include/freetype/internal/services/svfntfmt.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svfntfmt.h"

# 49 "../../../libs/freetype/include/freetype/internal/services/svfntfmt.h"

# 39 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svgldict.h" 1
# 25 "../../../libs/freetype/include/freetype/internal/services/svgldict.h"

# 37 "../../../libs/freetype/include/freetype/internal/services/svgldict.h"
  typedef FT_Error
  (*FT_GlyphDict_GetNameFunc)( FT_Face face,
                               FT_UInt glyph_index,
                               FT_Pointer buffer,
                               FT_UInt buffer_max );

  typedef FT_UInt
  (*FT_GlyphDict_NameIndexFunc)( FT_Face face,
                                 FT_String* glyph_name );


  typedef struct FT_Service_GlyphDictRec_ FT_Service_GlyphDictRec ; typedef struct FT_Service_GlyphDictRec_ const * FT_Service_GlyphDict ; struct FT_Service_GlyphDictRec_
  {
    FT_GlyphDict_GetNameFunc get_name;
    FT_GlyphDict_NameIndexFunc name_index;
  };
# 85 "../../../libs/freetype/include/freetype/internal/services/svgldict.h"

# 40 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svprop.h" 1
# 23 "../../../libs/freetype/include/freetype/internal/services/svprop.h"






  typedef FT_Error
  (*FT_Properties_SetFunc)( FT_Module module,
                            const char* property_name,
                            const void* value );

  typedef FT_Error
  (*FT_Properties_GetFunc)( FT_Module module,
                            const char* property_name,
                            void* value );


  typedef struct FT_Service_PropertiesRec_ FT_Service_PropertiesRec ; typedef struct FT_Service_PropertiesRec_ const * FT_Service_Properties ; struct FT_Service_PropertiesRec_
  {
    FT_Properties_SetFunc set_property;
    FT_Properties_GetFunc get_property;
  };
# 75 "../../../libs/freetype/include/freetype/internal/services/svprop.h"

# 41 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 1 "../../../libs/freetype/include/freetype/ftcffdrv.h" 1
# 32 "../../../libs/freetype/include/freetype/ftcffdrv.h"

# 256 "../../../libs/freetype/include/freetype/ftcffdrv.h"

# 42 "../../../libs/freetype/src/cff/cffdrivr.c" 2
# 99 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Error
  cff_get_kerning( FT_Face ttface,
                   FT_UInt left_glyph,
                   FT_UInt right_glyph,
                   FT_Vector* kerning )
  {
    TT_Face face = (TT_Face)ttface;
    SFNT_Service sfnt = (SFNT_Service)face->sfnt;


    kerning->x = 0;
    kerning->y = 0;

    if ( sfnt )
      kerning->x = sfnt->get_kerning( face, left_glyph, right_glyph );

    return FT_Err_Ok;
  }
# 145 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Error
  cff_glyph_load( FT_GlyphSlot cffslot,
                  FT_Size cffsize,
                  FT_UInt glyph_index,
                  FT_Int32 load_flags )
  {
    FT_Error error;
    CFF_GlyphSlot slot = (CFF_GlyphSlot)cffslot;
    CFF_Size size = (CFF_Size)cffsize;


    if ( !slot )
      return CFF_Err_Invalid_Slot_Handle;

    do { } while ( 0 );


    if ( !size )
      load_flags |= ( 1L << 0 ) | ( 1L << 1 );


    if ( load_flags & ( 1L << 0 ) )
      size = ((void *)0);

    if ( size )
    {

      if ( cffsize->face != cffslot->face )
        return CFF_Err_Invalid_Face_Handle;
    }


    error = cff_slot_load( slot, size, glyph_index, load_flags );




    return error;
  }


  static FT_Error
  cff_get_advances( FT_Face face,
                    FT_UInt start,
                    FT_UInt count,
                    FT_Int32 flags,
                    FT_Fixed* advances )
  {
    FT_UInt nn;
    FT_Error error = FT_Err_Ok;
    FT_GlyphSlot slot = face->glyph;


    if ( ( face->face_flags & ( 1L << 3 ) ) )
    {




      TT_Face ttface = (TT_Face)face;
      FT_Short dummy;


      if ( flags & ( 1L << 4 ) )
      {




        if ( !ttface->vertical_info )
          goto Missing_Table;

        for ( nn = 0; nn < count; nn++ )
        {
          FT_UShort ah;


          ( (SFNT_Service)ttface->sfnt )->get_metrics( ttface,
                                                       1,
                                                       start + nn,
                                                       &dummy,
                                                       &ah );

          do { } while ( 0 )
                                       ;
          advances[nn] = ah;
        }
      }
      else
      {

        if ( !ttface->horizontal.number_Of_HMetrics )
          goto Missing_Table;

        for ( nn = 0; nn < count; nn++ )
        {
          FT_UShort aw;


          ( (SFNT_Service)ttface->sfnt )->get_metrics( ttface,
                                                       0,
                                                       start + nn,
                                                       &dummy,
                                                       &aw );

          do { } while ( 0 )
                                       ;
          advances[nn] = aw;
        }
      }

      return error;
    }

  Missing_Table:
    flags |= (FT_UInt32)( 1L << 8 );

    for ( nn = 0; nn < count; nn++ )
    {
      error = cff_glyph_load( slot, face->size, start + nn, flags );
      if ( error )
        break;

      advances[nn] = ( flags & ( 1L << 4 ) )
                     ? slot->linearVertAdvance
                     : slot->linearHoriAdvance;
    }

    return error;
  }







  static FT_Error
  cff_get_glyph_name( CFF_Face face,
                      FT_UInt glyph_index,
                      FT_Pointer buffer,
                      FT_UInt buffer_max )
  {
    CFF_Font font = (CFF_Font)face->extra.data;
    FT_String* gname;
    FT_UShort sid;
    FT_Error error;


    if ( !font->psnames )
    {
      do { } while ( 0 )


                                                     ;
      error = CFF_Err_Missing_Module;
      goto Exit;
    }


    sid = font->charset.sids[glyph_index];


    gname = cff_index_get_sid_string( font, sid );

    if ( gname )
      ft_mem_strcpyn( (char*)buffer, (const char*)(gname), (FT_ULong)(buffer_max) );

    error = FT_Err_Ok;

  Exit:
    return error;
  }


  static FT_UInt
  cff_get_name_index( CFF_Face face,
                      FT_String* glyph_name )
  {
    CFF_Font cff;
    CFF_Charset charset;
    FT_Service_PsCMaps psnames;
    FT_String* name;
    FT_UShort sid;
    FT_UInt i;


    cff = (CFF_FontRec *)face->extra.data;
    charset = &cff->charset;

    do { FT_Module module = ((FT_Module)( ((FT_Face)(face))->driver )); FT_Pointer _tmp_; _tmp_ = ft_module_get_service( module, "postscript-cmaps" ); psnames = _tmp_; } while ( 0 );
    if ( !psnames )
      return 0;

    for ( i = 0; i < cff->num_glyphs; i++ )
    {
      sid = charset->sids[i];

      if ( sid > 390 )
        name = cff_index_get_string( cff, sid - 391 );
      else
        name = (FT_String *)psnames->adobe_std_strings( sid );

      if ( !name )
        continue;

      if ( !strcmp( glyph_name, name ) )
        return i;
    }

    return 0;
  }


  static const FT_Service_GlyphDictRec cff_service_glyph_dict = { (FT_GlyphDict_GetNameFunc) cff_get_glyph_name, (FT_GlyphDict_NameIndexFunc)cff_get_name_index };
# 371 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Int
  cff_ps_has_glyph_names( FT_Face face )
  {
    return ( face->face_flags & ( 1L << 9 ) ) > 0;
  }


  static FT_Error
  cff_ps_get_font_info( CFF_Face face,
                        PS_FontInfoRec* afont_info )
  {
    CFF_Font cff = (CFF_Font)face->extra.data;
    FT_Error error = FT_Err_Ok;


    if ( cff && cff->font_info == ((void *)0) )
    {
      CFF_FontRecDict dict = &cff->top_font.font_dict;
      PS_FontInfoRec *font_info = ((void *)0);
      FT_Memory memory = face->root.memory;


      if ( ( ((font_info) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *font_info )), &error ))), error != 0 ) )
        goto Fail;

      font_info->version = cff_index_get_sid_string( cff,
                                                         dict->version );
      font_info->notice = cff_index_get_sid_string( cff,
                                                         dict->notice );
      font_info->full_name = cff_index_get_sid_string( cff,
                                                         dict->full_name );
      font_info->family_name = cff_index_get_sid_string( cff,
                                                         dict->family_name );
      font_info->weight = cff_index_get_sid_string( cff,
                                                         dict->weight );
      font_info->italic_angle = dict->italic_angle;
      font_info->is_fixed_pitch = dict->is_fixed_pitch;
      font_info->underline_position = (FT_Short)dict->underline_position;
      font_info->underline_thickness = (FT_UShort)dict->underline_thickness;

      cff->font_info = font_info;
    }

    if ( cff )
      *afont_info = *cff->font_info;

  Fail:
    return error;
  }


  static const FT_Service_PsInfoRec cff_service_ps_info = { (PS_GetFontInfoFunc) cff_ps_get_font_info, (PS_GetFontExtraFunc) ((void *)0), (PS_HasGlyphNamesFunc) cff_ps_has_glyph_names, (PS_GetFontPrivateFunc)((void *)0), (PS_GetFontValueFunc) ((void *)0) };
# 439 "../../../libs/freetype/src/cff/cffdrivr.c"
  static const char*
  cff_get_ps_name( CFF_Face face )
  {
    CFF_Font cff = (CFF_Font)face->extra.data;
    SFNT_Service sfnt = (SFNT_Service)face->sfnt;





    if ( ( ((FT_Face)(face))->face_flags & ( 1L << 3 ) ) && sfnt )
    {
      FT_Library library = ((FT_Face)(face))->driver->root.library;
      FT_Module sfnt_module = FT_Get_Module( library, "sfnt" );
      FT_Service_PsFontName service =
        (FT_Service_PsFontName)ft_module_get_service(
                                 sfnt_module,
                                 "postscript-font-name" );


      if ( service && service->get_ps_font_name )
        return service->get_ps_font_name( ((FT_Face)(face)) );
    }

    return (const char*)cff->font_name;
  }


  static const FT_Service_PsFontNameRec cff_service_ps_name = { (FT_PsName_GetFunc)cff_get_ps_name };
# 483 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Error
  cff_get_cmap_info( FT_CharMap charmap,
                     TT_CMapInfo *cmap_info )
  {
    FT_CMap cmap = ((FT_CMap)( charmap ));
    FT_Error error = FT_Err_Ok;

    FT_Face face = ((FT_CMap)( cmap ))->charmap.face;
    FT_Library library = ((FT_Face)(face))->driver->root.library;


    cmap_info->language = 0;
    cmap_info->format = 0;

    if ( cmap->clazz != &cff_cmap_encoding_class_rec &&
         cmap->clazz != &cff_cmap_unicode_class_rec )
    {
      FT_Module sfnt = FT_Get_Module( library, "sfnt" );
      FT_Service_TTCMaps service =
        (FT_Service_TTCMaps)ft_module_get_service( sfnt,
                                                   "tt-cmaps" );


      if ( service && service->get_cmap_info )
        error = service->get_cmap_info( charmap, cmap_info );
    }

    return error;
  }


  static const FT_Service_TTCMapsRec cff_service_get_cmap_info = { (TT_CMap_Info_GetFunc)cff_get_cmap_info };
# 524 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Error
  cff_get_ros( CFF_Face face,
               const char* *registry,
               const char* *ordering,
               FT_Int *supplement )
  {
    FT_Error error = FT_Err_Ok;
    CFF_Font cff = (CFF_Font)face->extra.data;


    if ( cff )
    {
      CFF_FontRecDict dict = &cff->top_font.font_dict;


      if ( dict->cid_registry == 0xFFFFU )
      {
        error = CFF_Err_Invalid_Argument;
        goto Fail;
      }

      if ( registry )
      {
        if ( cff->registry == ((void *)0) )
          cff->registry = cff_index_get_sid_string( cff,
                                                    dict->cid_registry );
        *registry = cff->registry;
      }

      if ( ordering )
      {
        if ( cff->ordering == ((void *)0) )
          cff->ordering = cff_index_get_sid_string( cff,
                                                    dict->cid_ordering );
        *ordering = cff->ordering;
      }






      if ( supplement )
      {
        if ( dict->cid_supplement < (-2147483647 - 1) ||
             dict->cid_supplement > 2147483647 )
          do { } while ( 0 )
                                             ;
        *supplement = (FT_Int)dict->cid_supplement;
      }
    }

  Fail:
    return error;
  }


  static FT_Error
  cff_get_is_cid( CFF_Face face,
                  FT_Bool *is_cid )
  {
    FT_Error error = FT_Err_Ok;
    CFF_Font cff = (CFF_Font)face->extra.data;


    *is_cid = 0;

    if ( cff )
    {
      CFF_FontRecDict dict = &cff->top_font.font_dict;


      if ( dict->cid_registry != 0xFFFFU )
        *is_cid = 1;
    }

    return error;
  }


  static FT_Error
  cff_get_cid_from_glyph_index( CFF_Face face,
                                FT_UInt glyph_index,
                                FT_UInt *cid )
  {
    FT_Error error = FT_Err_Ok;
    CFF_Font cff;


    cff = (CFF_Font)face->extra.data;

    if ( cff )
    {
      FT_UInt c;
      CFF_FontRecDict dict = &cff->top_font.font_dict;


      if ( dict->cid_registry == 0xFFFFU )
      {
        error = CFF_Err_Invalid_Argument;
        goto Fail;
      }

      if ( glyph_index > cff->num_glyphs )
      {
        error = CFF_Err_Invalid_Argument;
        goto Fail;
      }

      c = cff->charset.sids[glyph_index];

      if ( cid )
        *cid = c;
    }

  Fail:
    return error;
  }


  static const FT_Service_CIDRec cff_service_cid_info = { (FT_CID_GetRegistryOrderingSupplementFunc) cff_get_ros, (FT_CID_GetIsInternallyCIDKeyedFunc) cff_get_is_cid, (FT_CID_GetCIDFromGlyphIndexFunc) cff_get_cid_from_glyph_index };
# 659 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Error
  cff_property_set( FT_Module module,
                    const char* property_name,
                    const void* value )
  {
    FT_Error error = FT_Err_Ok;
    CFF_Driver driver = (CFF_Driver)module;


    if ( !strcmp( property_name, "darkening-parameters" ) )
    {
      FT_Int* darken_params = (FT_Int*)value;

      FT_Int x1 = darken_params[0];
      FT_Int y1 = darken_params[1];
      FT_Int x2 = darken_params[2];
      FT_Int y2 = darken_params[3];
      FT_Int x3 = darken_params[4];
      FT_Int y3 = darken_params[5];
      FT_Int x4 = darken_params[6];
      FT_Int y4 = darken_params[7];


      if ( x1 < 0 || x2 < 0 || x3 < 0 || x4 < 0 ||
           y1 < 0 || y2 < 0 || y3 < 0 || y4 < 0 ||
           x1 > x2 || x2 > x3 || x3 > x4 ||
           y1 > 500 || y2 > 500 || y3 > 500 || y4 > 500 )
        return CFF_Err_Invalid_Argument;

      driver->darken_params[0] = x1;
      driver->darken_params[1] = y1;
      driver->darken_params[2] = x2;
      driver->darken_params[3] = y2;
      driver->darken_params[4] = x3;
      driver->darken_params[5] = y3;
      driver->darken_params[6] = x4;
      driver->darken_params[7] = y4;

      return error;
    }
    else if ( !strcmp( property_name, "hinting-engine" ) )
    {
      FT_UInt* hinting_engine = (FT_UInt*)value;



      if ( *hinting_engine != 1 )
        error = CFF_Err_Unimplemented_Feature;
      else

        driver->hinting_engine = *hinting_engine;

      return error;
    }
    else if ( !strcmp( property_name, "no-stem-darkening" ) )
    {
      FT_Bool* no_stem_darkening = (FT_Bool*)value;


      driver->no_stem_darkening = *no_stem_darkening;

      return error;
    }

    do { } while ( 0 )
                                ;
    return CFF_Err_Missing_Property;
  }


  static FT_Error
  cff_property_get( FT_Module module,
                    const char* property_name,
                    const void* value )
  {
    FT_Error error = FT_Err_Ok;
    CFF_Driver driver = (CFF_Driver)module;


    if ( !strcmp( property_name, "darkening-parameters" ) )
    {
      FT_Int* darken_params = driver->darken_params;
      FT_Int* val = (FT_Int*)value;


      val[0] = darken_params[0];
      val[1] = darken_params[1];
      val[2] = darken_params[2];
      val[3] = darken_params[3];
      val[4] = darken_params[4];
      val[5] = darken_params[5];
      val[6] = darken_params[6];
      val[7] = darken_params[7];

      return error;
    }
    else if ( !strcmp( property_name, "hinting-engine" ) )
    {
      FT_UInt hinting_engine = driver->hinting_engine;
      FT_UInt* val = (FT_UInt*)value;


      *val = hinting_engine;

      return error;
    }
    else if ( !strcmp( property_name, "no-stem-darkening" ) )
    {
      FT_Bool no_stem_darkening = driver->no_stem_darkening;
      FT_Bool* val = (FT_Bool*)value;


      *val = no_stem_darkening;

      return error;
    }

    do { } while ( 0 )
                                ;
    return CFF_Err_Missing_Property;
  }


  static const FT_Service_PropertiesRec cff_service_properties = { (FT_Properties_SetFunc)cff_property_set, (FT_Properties_GetFunc)cff_property_get };
# 801 "../../../libs/freetype/src/cff/cffdrivr.c"
  static const FT_ServiceDescRec cff_services[] = { { "font-format", "CFF" }, { "postscript-info", &cff_service_ps_info }, { "postscript-font-name", &cff_service_ps_name }, { "glyph-dict", &cff_service_glyph_dict }, { "tt-cmaps", &cff_service_get_cmap_info }, { "CID", &cff_service_cid_info }, { "properties", &cff_service_properties }, { ((void *)0), ((void *)0) } };
# 824 "../../../libs/freetype/src/cff/cffdrivr.c"
  static FT_Module_Interface
  cff_get_interface( FT_Module driver,
                     const char* module_interface )
  {
    FT_Library library;
    FT_Module sfnt;
    FT_Module_Interface result;
# 842 "../../../libs/freetype/src/cff/cffdrivr.c"
    result = ft_service_list_lookup( cff_services, module_interface );
    if ( result != ((void *)0) )
      return result;



    if ( !driver )
      return ((void *)0);
    library = driver->library;
    if ( !library )
      return ((void *)0);



    sfnt = FT_Get_Module( library, "sfnt" );

    return sfnt ? sfnt->clazz->get_interface( sfnt, module_interface ) : 0;
  }
# 870 "../../../libs/freetype/src/cff/cffdrivr.c"
  const FT_Driver_ClassRec cff_driver_class = { { 1 | 0x100 | 0x400 | 0x800, sizeof ( CFF_DriverRec ), "cff", 0x10000L, 0x20000L, 0, cff_driver_init, cff_driver_done, cff_get_interface, }, sizeof ( TT_FaceRec ), sizeof ( CFF_SizeRec ), sizeof ( CFF_GlyphSlotRec ), cff_face_init, cff_face_done, cff_size_init, cff_size_done, cff_slot_init, cff_slot_done, cff_glyph_load, cff_get_kerning, 0, cff_get_advances, cff_size_request, cff_size_select };
# 25 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cffparse.c" 1
# 38 "../../../libs/freetype/src/cff/cffparse.c"
  static void
  cff_parser_init( CFF_Parser parser,
                   FT_UInt code,
                   void* object,
                   FT_Library library)
  {
    memset( parser, 0, (FT_Offset)(sizeof ( *parser )) );

    parser->top = parser->stack;
    parser->object_code = code;
    parser->object = object;
    parser->library = library;
  }



  static FT_Long
  cff_parse_integer( FT_Byte* start,
                     FT_Byte* limit )
  {
    FT_Byte* p = start;
    FT_Int v = *p++;
    FT_Long val = 0;


    if ( v == 28 )
    {
      if ( p + 2 > limit )
        goto Bad;

      val = (FT_Short)( ( (FT_UShort)p[0] << 8 ) | p[1] );
    }
    else if ( v == 29 )
    {
      if ( p + 4 > limit )
        goto Bad;

      val = (FT_Long)( ( (FT_ULong)p[0] << 24 ) |
                       ( (FT_ULong)p[1] << 16 ) |
                       ( (FT_ULong)p[2] << 8 ) |
                         (FT_ULong)p[3] );
    }
    else if ( v < 247 )
    {
      val = v - 139;
    }
    else if ( v < 251 )
    {
      if ( p + 1 > limit )
        goto Bad;

      val = ( v - 247 ) * 256 + p[0] + 108;
    }
    else
    {
      if ( p + 1 > limit )
        goto Bad;

      val = -( v - 251 ) * 256 - p[0] - 108;
    }

  Exit:
    return val;

  Bad:
    val = 0;
    do { } while ( 0 );
    goto Exit;
  }


  static const FT_Long power_tens[] =
  {
    1L,
    10L,
    100L,
    1000L,
    10000L,
    100000L,
    1000000L,
    10000000L,
    100000000L,
    1000000000L
  };



  static FT_Fixed
  cff_parse_real( FT_Byte* start,
                  FT_Byte* limit,
                  FT_Long power_ten,
                  FT_Long* scaling )
  {
    FT_Byte* p = start;
    FT_Int nib;
    FT_UInt phase;

    FT_Long result, number, exponent;
    FT_Int sign = 0, exponent_sign = 0, have_overflow = 0;
    FT_Long exponent_add, integer_length, fraction_length;


    if ( scaling )
      *scaling = 0;

    result = 0;

    number = 0;
    exponent = 0;

    exponent_add = 0;
    integer_length = 0;
    fraction_length = 0;


    phase = 4;

    for (;;)
    {


      if ( phase )
      {
        p++;


        if ( p >= limit )
          goto Bad;
      }


      nib = (FT_Int)( p[0] >> phase ) & 0xF;
      phase = 4 - phase;

      if ( nib == 0xE )
        sign = 1;
      else if ( nib > 9 )
        break;
      else
      {

        if ( number >= 0xCCCCCCCL )
          exponent_add++;

        else if ( nib || number )
        {
          integer_length++;
          number = number * 10 + nib;
        }
      }
    }


    if ( nib == 0xA )
      for (;;)
      {


        if ( phase )
        {
          p++;


          if ( p >= limit )
            goto Bad;
        }


        nib = ( p[0] >> phase ) & 0xF;
        phase = 4 - phase;
        if ( nib >= 10 )
          break;


        if ( !nib && !number )
          exponent_add--;

        else if ( number < 0xCCCCCCCL && fraction_length < 9 )
        {
          fraction_length++;
          number = number * 10 + nib;
        }
      }


    if ( nib == 12 )
    {
      exponent_sign = 1;
      nib = 11;
    }

    if ( nib == 11 )
    {
      for (;;)
      {


        if ( phase )
        {
          p++;


          if ( p >= limit )
            goto Bad;
        }


        nib = ( p[0] >> phase ) & 0xF;
        phase = 4 - phase;
        if ( nib >= 10 )
          break;


        if ( exponent > 1000 )
          have_overflow = 1;
        else
          exponent = exponent * 10 + nib;
      }

      if ( exponent_sign )
        exponent = -exponent;
    }

    if ( !number )
      goto Exit;

    if ( have_overflow )
    {
      if ( exponent_sign )
        goto Underflow;
      else
        goto Overflow;
    }


    exponent += power_ten + exponent_add;

    if ( scaling )
    {

      fraction_length += integer_length;
      exponent += integer_length;

      if ( fraction_length <= 5 )
      {
        if ( number > 0x7FFFL )
        {
          result = FT_DivFix( number, 10 );
          *scaling = exponent - fraction_length + 1;
        }
        else
        {
          if ( exponent > 0 )
          {
            FT_Long new_fraction_length, shift;



            new_fraction_length = ( (exponent) < (5) ? (exponent) : (5) );
            shift = new_fraction_length - fraction_length;

            if ( shift > 0 )
            {
              exponent -= new_fraction_length;
              number *= power_tens[shift];
              if ( number > 0x7FFFL )
              {
                number /= 10;
                exponent += 1;
              }
            }
            else
              exponent -= fraction_length;
          }
          else
            exponent -= fraction_length;

          result = (FT_Long)( (FT_ULong)number << 16 );
          *scaling = exponent;
        }
      }
      else
      {
        if ( ( number / power_tens[fraction_length - 5] ) > 0x7FFFL )
        {
          result = FT_DivFix( number, power_tens[fraction_length - 4] );
          *scaling = exponent - 4;
        }
        else
        {
          result = FT_DivFix( number, power_tens[fraction_length - 5] );
          *scaling = exponent - 5;
        }
      }
    }
    else
    {
      integer_length += exponent;
      fraction_length -= exponent;

      if ( integer_length > 5 )
        goto Overflow;
      if ( integer_length < -5 )
        goto Underflow;


      if ( integer_length < 0 )
      {
        number /= power_tens[-integer_length];
        fraction_length += integer_length;
      }


      if ( fraction_length == 10 )
      {
        number /= 10;
        fraction_length -= 1;
      }


      if ( fraction_length > 0 )
      {
        if ( ( number / power_tens[fraction_length] ) > 0x7FFFL )
          goto Exit;

        result = FT_DivFix( number, power_tens[fraction_length] );
      }
      else
      {
        number *= power_tens[-fraction_length];

        if ( number > 0x7FFFL )
          goto Overflow;

        result = (FT_Long)( (FT_ULong)number << 16 );
      }
    }

  Exit:
    if ( sign )
      result = -result;

    return result;

  Overflow:
    result = 0x7FFFFFFFL;
    do { } while ( 0 );
    goto Exit;

  Underflow:
    result = 0;
    do { } while ( 0 );
    goto Exit;

  Bad:
    result = 0;
    do { } while ( 0 );
    goto Exit;
  }



  static FT_Long
  cff_parse_num( FT_Byte** d )
  {
    return **d == 30 ? ( cff_parse_real( d[0], d[1], 0, ((void *)0) ) >> 16 )
                     : cff_parse_integer( d[0], d[1] );
  }



  static FT_Fixed
  do_fixed( FT_Byte** d,
            FT_Long scaling )
  {
    if ( **d == 30 )
      return cff_parse_real( d[0], d[1], scaling, ((void *)0) );
    else
    {
      FT_Long val = cff_parse_integer( d[0], d[1] );


      if ( scaling )
        val *= power_tens[scaling];

      if ( val > 0x7FFF )
      {
        val = 0x7FFFFFFFL;
        goto Overflow;
      }
      else if ( val < -0x7FFF )
      {
        val = -0x7FFFFFFFL;
        goto Overflow;
      }

      return (FT_Long)( (FT_ULong)val << 16 );

    Overflow:
      do { } while ( 0 );
      return val;
    }
  }



  static FT_Fixed
  cff_parse_fixed( FT_Byte** d )
  {
    return do_fixed( d, 0 );
  }




  static FT_Fixed
  cff_parse_fixed_scaled( FT_Byte** d,
                          FT_Long scaling )
  {
    return do_fixed( d, scaling );
  }





  static FT_Fixed
  cff_parse_fixed_dynamic( FT_Byte** d,
                           FT_Long* scaling )
  {
    do { } while ( 0 );

    if ( **d == 30 )
      return cff_parse_real( d[0], d[1], 0, scaling );
    else
    {
      FT_Long number;
      FT_Int integer_length;


      number = cff_parse_integer( d[0], d[1] );

      if ( number > 0x7FFFL )
      {
        for ( integer_length = 5; integer_length < 10; integer_length++ )
          if ( number < power_tens[integer_length] )
            break;

        if ( ( number / power_tens[integer_length - 5] ) > 0x7FFFL )
        {
          *scaling = integer_length - 4;
          return FT_DivFix( number, power_tens[integer_length - 4] );
        }
        else
        {
          *scaling = integer_length - 5;
          return FT_DivFix( number, power_tens[integer_length - 5] );
        }
      }
      else
      {
        *scaling = 0;
        return (FT_Long)( (FT_ULong)number << 16 );
      }
    }
  }


  static FT_Error
  cff_parse_font_matrix( CFF_Parser parser )
  {
    CFF_FontRecDict dict = (CFF_FontRecDict)parser->object;
    FT_Matrix* matrix = &dict->font_matrix;
    FT_Vector* offset = &dict->font_offset;
    FT_ULong* upm = &dict->units_per_em;
    FT_Byte** data = parser->stack;
    FT_Error error = CFF_Err_Stack_Underflow;


    if ( parser->top >= parser->stack + 6 )
    {
      FT_Long scaling;


      error = FT_Err_Ok;

      dict->has_font_matrix = 1;







      matrix->xx = cff_parse_fixed_dynamic( data++, &scaling );

      scaling = -scaling;

      if ( scaling < 0 || scaling > 9 )
      {


        do { } while ( 0 )


                                                         ;

        matrix->xx = 0x10000L;
        matrix->yx = 0;
        matrix->xy = 0;
        matrix->yy = 0x10000L;
        offset->x = 0;
        offset->y = 0;
        *upm = 1;

        goto Exit;
      }

      matrix->yx = cff_parse_fixed_scaled( data++, scaling );
      matrix->xy = cff_parse_fixed_scaled( data++, scaling );
      matrix->yy = cff_parse_fixed_scaled( data++, scaling );
      offset->x = cff_parse_fixed_scaled( data++, scaling );
      offset->y = cff_parse_fixed_scaled( data, scaling );

      *upm = (FT_ULong)power_tens[scaling];

      do { } while ( 0 )





                                                      ;
    }

  Exit:
    return error;
  }


  static FT_Error
  cff_parse_font_bbox( CFF_Parser parser )
  {
    CFF_FontRecDict dict = (CFF_FontRecDict)parser->object;
    FT_BBox* bbox = &dict->font_bbox;
    FT_Byte** data = parser->stack;
    FT_Error error;


    error = CFF_Err_Stack_Underflow;

    if ( parser->top >= parser->stack + 4 )
    {
      bbox->xMin = FT_RoundFix( cff_parse_fixed( data++ ) );
      bbox->yMin = FT_RoundFix( cff_parse_fixed( data++ ) );
      bbox->xMax = FT_RoundFix( cff_parse_fixed( data++ ) );
      bbox->yMax = FT_RoundFix( cff_parse_fixed( data ) );
      error = FT_Err_Ok;

      do { } while ( 0 )



                                       ;
    }

    return error;
  }


  static FT_Error
  cff_parse_private_dict( CFF_Parser parser )
  {
    CFF_FontRecDict dict = (CFF_FontRecDict)parser->object;
    FT_Byte** data = parser->stack;
    FT_Error error;


    error = CFF_Err_Stack_Underflow;

    if ( parser->top >= parser->stack + 2 )
    {
      FT_Long tmp;


      tmp = cff_parse_num( data++ );
      if ( tmp < 0 )
      {
        do { } while ( 0 );
        error = CFF_Err_Invalid_File_Format;
        goto Fail;
      }
      dict->private_size = (FT_ULong)tmp;

      tmp = cff_parse_num( data );
      if ( tmp < 0 )
      {
        do { } while ( 0 );
        error = CFF_Err_Invalid_File_Format;
        goto Fail;
      }
      dict->private_offset = (FT_ULong)tmp;

      do { } while ( 0 )
                                                             ;

      error = FT_Err_Ok;
    }

  Fail:
    return error;
  }


  static FT_Error
  cff_parse_cid_ros( CFF_Parser parser )
  {
    CFF_FontRecDict dict = (CFF_FontRecDict)parser->object;
    FT_Byte** data = parser->stack;
    FT_Error error;


    error = CFF_Err_Stack_Underflow;

    if ( parser->top >= parser->stack + 3 )
    {
      dict->cid_registry = (FT_UInt)cff_parse_num( data++ );
      dict->cid_ordering = (FT_UInt)cff_parse_num( data++ );
      if ( **data == 30 )
        do { } while ( 0 );
      dict->cid_supplement = cff_parse_num( data );
      if ( dict->cid_supplement < 0 )
        do { } while ( 0 )
                                          ;
      error = FT_Err_Ok;

      do { } while ( 0 )


                                         ;
    }

    return error;
  }
# 738 "../../../libs/freetype/src/cff/cffparse.c"
  static const CFF_Field_Handler cff_field_handlers[] =
  {

# 1 "../../../libs/freetype/src/cff/cfftoken.h" 1
# 25 "../../../libs/freetype/src/cff/cfftoken.h"
  { cff_kind_string, 0 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, version) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->version ), 0, 0, 0 },
  { cff_kind_string, 1 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, notice) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->notice ), 0, 0, 0 },
  { cff_kind_string, 0x100 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, copyright) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->copyright ), 0, 0, 0 },
  { cff_kind_string, 2 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, full_name) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->full_name ), 0, 0, 0 },
  { cff_kind_string, 3 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, family_name) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->family_name ), 0, 0, 0 },
  { cff_kind_string, 4 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, weight) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->weight ), 0, 0, 0 },
  { cff_kind_bool, 0x101 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, is_fixed_pitch) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->is_fixed_pitch ), 0, 0, 0 },
  { cff_kind_fixed, 0x102 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, italic_angle) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->italic_angle ), 0, 0, 0 },
  { cff_kind_fixed, 0x103 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, underline_position) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->underline_position ), 0, 0, 0 },
  { cff_kind_fixed, 0x104 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, underline_thickness) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->underline_thickness ), 0, 0, 0 },
  { cff_kind_num, 0x105 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, paint_type) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->paint_type ), 0, 0, 0 },
  { cff_kind_num, 0x106 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, charstring_type) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->charstring_type ), 0, 0, 0 },
  { cff_kind_callback, 0x107 | 0x1000, 0, 0, cff_parse_font_matrix, 0, 0 },
  { cff_kind_num, 13 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, unique_id) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->unique_id ), 0, 0, 0 },
  { cff_kind_callback, 5 | 0x1000, 0, 0, cff_parse_font_bbox, 0, 0 },
  { cff_kind_num, 0x108 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, stroke_width) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->stroke_width ), 0, 0, 0 },
  { cff_kind_num, 15 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, charset_offset) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->charset_offset ), 0, 0, 0 },
  { cff_kind_num, 16 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, encoding_offset) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->encoding_offset ), 0, 0, 0 },
  { cff_kind_num, 17 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, charstrings_offset) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->charstrings_offset ), 0, 0, 0 },
  { cff_kind_callback, 18 | 0x1000, 0, 0, cff_parse_private_dict, 0, 0 },
  { cff_kind_num, 0x114 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, synthetic_base) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->synthetic_base ), 0, 0, 0 },
  { cff_kind_string, 0x115 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, embedded_postscript) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->embedded_postscript ), 0, 0, 0 },
# 55 "../../../libs/freetype/src/cff/cfftoken.h"
  { cff_kind_callback, 0x11E | 0x1000, 0, 0, cff_parse_cid_ros, 0, 0 },
  { cff_kind_num, 0x11F | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_font_version) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_font_version ), 0, 0, 0 },
  { cff_kind_num, 0x120 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_font_revision) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_font_revision ), 0, 0, 0 },
  { cff_kind_num, 0x121 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_font_type) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_font_type ), 0, 0, 0 },
  { cff_kind_num, 0x122 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_count) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_count ), 0, 0, 0 },
  { cff_kind_num, 0x123 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_uid_base) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_uid_base ), 0, 0, 0 },
  { cff_kind_num, 0x124 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_fd_array_offset) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_fd_array_offset ), 0, 0, 0 },
  { cff_kind_num, 0x125 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_fd_select_offset) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_fd_select_offset ), 0, 0, 0 },
  { cff_kind_string, 0x126 | 0x1000, (FT_UShort)( __builtin_offsetof (CFF_FontRecDictRec, cid_font_name) ), (FT_Byte)sizeof ( ((CFF_FontRecDictRec*)0)->cid_font_name ), 0, 0, 0 },
# 75 "../../../libs/freetype/src/cff/cfftoken.h"
  { cff_kind_delta, 6 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, blue_values) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->blue_values[0] ), 0, 14, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, num_blue_values) ) },
  { cff_kind_delta, 7 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, other_blues) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->other_blues[0] ), 0, 10, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, num_other_blues) ) },
  { cff_kind_delta, 8 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, family_blues) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->family_blues[0] ), 0, 14, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, num_family_blues) ) },
  { cff_kind_delta, 9 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, family_other_blues) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->family_other_blues[0] ), 0, 10, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, num_family_other_blues) ) },
  { cff_kind_fixed_thousand, 0x109 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, blue_scale) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->blue_scale ), 0, 0, 0 },
  { cff_kind_num, 0x10A | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, blue_shift) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->blue_shift ), 0, 0, 0 },
  { cff_kind_num, 0x10B | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, blue_fuzz) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->blue_fuzz ), 0, 0, 0 },
  { cff_kind_num, 10 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, standard_width) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->standard_width ), 0, 0, 0 },
  { cff_kind_num, 11 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, standard_height) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->standard_height ), 0, 0, 0 },
  { cff_kind_delta, 0x10C | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, snap_widths) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->snap_widths[0] ), 0, 13, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, num_snap_widths) ) },
  { cff_kind_delta, 0x10D | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, snap_heights) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->snap_heights[0] ), 0, 13, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, num_snap_heights) ) },
  { cff_kind_bool, 0x10E | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, force_bold) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->force_bold ), 0, 0, 0 },
  { cff_kind_fixed, 0x10F | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, force_bold_threshold) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->force_bold_threshold ), 0, 0, 0 },
  { cff_kind_num, 0x110 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, lenIV) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->lenIV ), 0, 0, 0 },
  { cff_kind_num, 0x111 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, language_group) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->language_group ), 0, 0, 0 },
  { cff_kind_fixed, 0x112 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, expansion_factor) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->expansion_factor ), 0, 0, 0 },
  { cff_kind_num, 0x113 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, initial_random_seed) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->initial_random_seed ), 0, 0, 0 },
  { cff_kind_num, 19 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, local_subrs_offset) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->local_subrs_offset ), 0, 0, 0 },
  { cff_kind_num, 20 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, default_width) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->default_width ), 0, 0, 0 },
  { cff_kind_num, 21 | 0x2000, (FT_UShort)( __builtin_offsetof (CFF_PrivateRec, nominal_width) ), (FT_Byte)sizeof ( ((CFF_PrivateRec*)0)->nominal_width ), 0, 0, 0 },
# 742 "../../../libs/freetype/src/cff/cffparse.c" 2

    { 0, 0, 0, 0, 0, 0, 0 }
  };
# 948 "../../../libs/freetype/src/cff/cffparse.c"
  static FT_Error
  cff_parser_run( CFF_Parser parser,
                  FT_Byte* start,
                  FT_Byte* limit )
  {
    FT_Byte* p = start;
    FT_Error error = FT_Err_Ok;
    FT_Library library = parser->library;
    ( (library) = (library) );


    parser->top = parser->stack;
    parser->start = start;
    parser->limit = limit;
    parser->cursor = start;

    while ( p < limit )
    {
      FT_UInt v = *p;


      if ( v >= 27 && v != 31 )
      {

        if ( parser->top - parser->stack >= 96 )
          goto Stack_Overflow;

        *parser->top ++ = p;


        if ( v == 30 )
        {

          p++;
          for (;;)
          {


            if ( p >= limit )
              goto Exit;
            v = p[0] >> 4;
            if ( v == 15 )
              break;
            v = p[0] & 0xF;
            if ( v == 15 )
              break;
            p++;
          }
        }
        else if ( v == 28 )
          p += 2;
        else if ( v == 29 )
          p += 4;
        else if ( v > 246 )
          p += 1;
      }
      else
      {



        FT_UInt code;
        FT_UInt num_args = (FT_UInt)
                                             ( parser->top - parser->stack );
        const CFF_Field_Handler* field;


        *parser->top = p;
        code = v;
        if ( v == 12 )
        {

          p++;
          if ( p >= limit )
            goto Syntax_Error;

          code = 0x100 | p[0];
        }
        code = code | parser->object_code;

        for ( field = cff_field_handlers; field->kind; field++ )
        {
          if ( field->code == (FT_Int)code )
          {

            FT_Long val;
            FT_Byte* q = (FT_Byte*)parser->object + field->offset;
# 1043 "../../../libs/freetype/src/cff/cffparse.c"
            if ( field->kind != cff_kind_delta && num_args < 1 )
              goto Stack_Underflow;

            switch ( field->kind )
            {
            case cff_kind_bool:
            case cff_kind_string:
            case cff_kind_num:
              val = cff_parse_num( parser->stack );
              goto Store_Number;

            case cff_kind_fixed:
              val = cff_parse_fixed( parser->stack );
              goto Store_Number;

            case cff_kind_fixed_thousand:
              val = cff_parse_fixed_scaled( parser->stack, 3 );

            Store_Number:
              switch ( field->size )
              {
              case (8 / 8):
                *(FT_Byte*)q = (FT_Byte)val;
                break;

              case (16 / 8):
                *(FT_Short*)q = (FT_Short)val;
                break;

              case (32 / 8):
                *(FT_Int32*)q = (FT_Int)val;
                break;

              default:
                *(FT_Long*)q = val;
              }
# 1107 "../../../libs/freetype/src/cff/cffparse.c"
              break;

            case cff_kind_delta:
              {
                FT_Byte* qcount = (FT_Byte*)parser->object +
                                      field->count_offset;

                FT_Byte** data = parser->stack;


                if ( num_args > field->array_max )
                  num_args = field->array_max;

                do { } while ( 0 );


                *qcount = (FT_Byte)num_args;

                val = 0;
                while ( num_args > 0 )
                {
                  val += cff_parse_num( data++ );
                  switch ( field->size )
                  {
                  case (8 / 8):
                    *(FT_Byte*)q = (FT_Byte)val;
                    break;

                  case (16 / 8):
                    *(FT_Short*)q = (FT_Short)val;
                    break;

                  case (32 / 8):
                    *(FT_Int32*)q = (FT_Int)val;
                    break;

                  default:
                    *(FT_Long*)q = val;
                  }

                  do { } while ( 0 );

                  q += field->size;
                  num_args--;
                }

                do { } while ( 0 );
              }
              break;

            default:
              error = field->reader( parser );
              if ( error )
                goto Exit;
            }
            goto Found;
          }
        }




      Found:

        parser->top = parser->stack;
      }
      p++;
    }

  Exit:
    return error;

  Stack_Overflow:
    error = CFF_Err_Invalid_Argument;
    goto Exit;

  Stack_Underflow:
    error = CFF_Err_Invalid_Argument;
    goto Exit;

  Syntax_Error:
    error = CFF_Err_Invalid_Argument;
    goto Exit;
  }
# 26 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cffload.c" 1
# 23 "../../../libs/freetype/src/cff/cffload.c"
# 1 "../../../libs/freetype/include/freetype/tttags.h" 1
# 33 "../../../libs/freetype/include/freetype/tttags.h"

# 106 "../../../libs/freetype/include/freetype/tttags.h"

# 24 "../../../libs/freetype/src/cff/cffload.c" 2
# 34 "../../../libs/freetype/src/cff/cffload.c"
  static const FT_UShort cff_isoadobe_charset[229] =
  {
      0, 1, 2, 3, 4, 5, 6, 7,
      8, 9, 10, 11, 12, 13, 14, 15,
     16, 17, 18, 19, 20, 21, 22, 23,
     24, 25, 26, 27, 28, 29, 30, 31,
     32, 33, 34, 35, 36, 37, 38, 39,
     40, 41, 42, 43, 44, 45, 46, 47,
     48, 49, 50, 51, 52, 53, 54, 55,
     56, 57, 58, 59, 60, 61, 62, 63,
     64, 65, 66, 67, 68, 69, 70, 71,
     72, 73, 74, 75, 76, 77, 78, 79,
     80, 81, 82, 83, 84, 85, 86, 87,
     88, 89, 90, 91, 92, 93, 94, 95,
     96, 97, 98, 99, 100, 101, 102, 103,
    104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 119,
    120, 121, 122, 123, 124, 125, 126, 127,
    128, 129, 130, 131, 132, 133, 134, 135,
    136, 137, 138, 139, 140, 141, 142, 143,
    144, 145, 146, 147, 148, 149, 150, 151,
    152, 153, 154, 155, 156, 157, 158, 159,
    160, 161, 162, 163, 164, 165, 166, 167,
    168, 169, 170, 171, 172, 173, 174, 175,
    176, 177, 178, 179, 180, 181, 182, 183,
    184, 185, 186, 187, 188, 189, 190, 191,
    192, 193, 194, 195, 196, 197, 198, 199,
    200, 201, 202, 203, 204, 205, 206, 207,
    208, 209, 210, 211, 212, 213, 214, 215,
    216, 217, 218, 219, 220, 221, 222, 223,
    224, 225, 226, 227, 228
  };

  static const FT_UShort cff_expert_charset[166] =
  {
      0, 1, 229, 230, 231, 232, 233, 234,
    235, 236, 237, 238, 13, 14, 15, 99,
    239, 240, 241, 242, 243, 244, 245, 246,
    247, 248, 27, 28, 249, 250, 251, 252,
    253, 254, 255, 256, 257, 258, 259, 260,
    261, 262, 263, 264, 265, 266, 109, 110,
    267, 268, 269, 270, 271, 272, 273, 274,
    275, 276, 277, 278, 279, 280, 281, 282,
    283, 284, 285, 286, 287, 288, 289, 290,
    291, 292, 293, 294, 295, 296, 297, 298,
    299, 300, 301, 302, 303, 304, 305, 306,
    307, 308, 309, 310, 311, 312, 313, 314,
    315, 316, 317, 318, 158, 155, 163, 319,
    320, 321, 322, 323, 324, 325, 326, 150,
    164, 169, 327, 328, 329, 330, 331, 332,
    333, 334, 335, 336, 337, 338, 339, 340,
    341, 342, 343, 344, 345, 346, 347, 348,
    349, 350, 351, 352, 353, 354, 355, 356,
    357, 358, 359, 360, 361, 362, 363, 364,
    365, 366, 367, 368, 369, 370, 371, 372,
    373, 374, 375, 376, 377, 378
  };

  static const FT_UShort cff_expertsubset_charset[87] =
  {
      0, 1, 231, 232, 235, 236, 237, 238,
     13, 14, 15, 99, 239, 240, 241, 242,
    243, 244, 245, 246, 247, 248, 27, 28,
    249, 250, 251, 253, 254, 255, 256, 257,
    258, 259, 260, 261, 262, 263, 264, 265,
    266, 109, 110, 267, 268, 269, 270, 272,
    300, 301, 302, 305, 314, 315, 158, 155,
    163, 320, 321, 322, 323, 324, 325, 326,
    150, 164, 169, 327, 328, 329, 330, 331,
    332, 333, 334, 335, 336, 337, 338, 339,
    340, 341, 342, 343, 344, 345, 346
  };

  static const FT_UShort cff_standard_encoding[256] =
  {
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      1, 2, 3, 4, 5, 6, 7, 8,
      9, 10, 11, 12, 13, 14, 15, 16,
     17, 18, 19, 20, 21, 22, 23, 24,
     25, 26, 27, 28, 29, 30, 31, 32,
     33, 34, 35, 36, 37, 38, 39, 40,
     41, 42, 43, 44, 45, 46, 47, 48,
     49, 50, 51, 52, 53, 54, 55, 56,
     57, 58, 59, 60, 61, 62, 63, 64,
     65, 66, 67, 68, 69, 70, 71, 72,
     73, 74, 75, 76, 77, 78, 79, 80,
     81, 82, 83, 84, 85, 86, 87, 88,
     89, 90, 91, 92, 93, 94, 95, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 96, 97, 98, 99, 100, 101, 102,
    103, 104, 105, 106, 107, 108, 109, 110,
      0, 111, 112, 113, 114, 0, 115, 116,
    117, 118, 119, 120, 121, 122, 0, 123,
      0, 124, 125, 126, 127, 128, 129, 130,
    131, 0, 132, 133, 0, 134, 135, 136,
    137, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 138, 0, 139, 0, 0, 0, 0,
    140, 141, 142, 143, 0, 0, 0, 0,
      0, 144, 0, 0, 0, 145, 0, 0,
    146, 147, 148, 149, 0, 0, 0, 0
  };

  static const FT_UShort cff_expert_encoding[256] =
  {
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      1, 229, 230, 0, 231, 232, 233, 234,
    235, 236, 237, 238, 13, 14, 15, 99,
    239, 240, 241, 242, 243, 244, 245, 246,
    247, 248, 27, 28, 249, 250, 251, 252,
      0, 253, 254, 255, 256, 257, 0, 0,
      0, 258, 0, 0, 259, 260, 261, 262,
      0, 0, 263, 264, 265, 0, 266, 109,
    110, 267, 268, 269, 0, 270, 271, 272,
    273, 274, 275, 276, 277, 278, 279, 280,
    281, 282, 283, 284, 285, 286, 287, 288,
    289, 290, 291, 292, 293, 294, 295, 296,
    297, 298, 299, 300, 301, 302, 303, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 304, 305, 306, 0, 0, 307, 308,
    309, 310, 311, 0, 312, 0, 0, 312,
      0, 0, 314, 315, 0, 0, 316, 317,
    318, 0, 0, 0, 158, 155, 163, 319,
    320, 321, 322, 323, 324, 325, 0, 0,
    326, 150, 164, 169, 327, 328, 329, 330,
    331, 332, 333, 334, 335, 336, 337, 338,
    339, 340, 341, 342, 343, 344, 345, 346,
    347, 348, 349, 350, 351, 352, 353, 354,
    355, 356, 357, 358, 359, 360, 361, 362,
    363, 364, 365, 366, 367, 368, 369, 370,
    371, 372, 373, 374, 375, 376, 377, 378
  };




  static FT_UShort
  cff_get_standard_encoding( FT_UInt charcode )
  {
    return (FT_UShort)( charcode < 256 ? cff_standard_encoding[charcode]
                                       : 0 );
  }
# 201 "../../../libs/freetype/src/cff/cffload.c"
  static FT_ULong
  cff_index_read_offset( CFF_Index idx,
                         FT_Error *errorp )
  {
    FT_Error error;
    FT_Stream stream = idx->stream;
    FT_Byte tmp[4];
    FT_ULong result = 0;


    if ( !( ( error = (FT_Stream_Read( stream, (FT_Byte*)(tmp), (FT_ULong)(idx->off_size) )) ) != 0 ) )
    {
      FT_Int nn;


      for ( nn = 0; nn < idx->off_size; nn++ )
        result = ( result << 8 ) | tmp[nn];
    }

    *errorp = error;
    return result;
  }


  static FT_Error
  cff_index_init( CFF_Index idx,
                  FT_Stream stream,
                  FT_Bool load )
  {
    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_UShort count;


    memset( idx, 0, (FT_Offset)(sizeof ( *idx )) );

    idx->stream = stream;
    idx->start = FT_Stream_Pos( stream );
    if ( !( count = (FT_UShort)FT_Stream_ReadUShort( stream, &error ), error != FT_Err_Ok ) &&
         count > 0 )
    {
      FT_Byte offsize;
      FT_ULong size;




      if ( ( offsize = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
        goto Exit;

      if ( offsize < 1 || offsize > 4 )
      {
        error = CFF_Err_Invalid_Table;
        goto Exit;
      }

      idx->count = count;
      idx->off_size = offsize;
      size = (FT_ULong)( count + 1 ) * offsize;

      idx->data_offset = idx->start + 3 + size;

      if ( ( ( error = (FT_Stream_Skip( stream, (FT_Long)(size - offsize) )) ) != 0 ) )
        goto Exit;

      size = cff_index_read_offset( idx, &error );
      if ( error )
        goto Exit;

      if ( size == 0 )
      {
        error = CFF_Err_Invalid_Table;
        goto Exit;
      }

      idx->data_size = --size;

      if ( load )
      {

        if ( ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(size), (FT_Byte**)&(idx->bytes) ))) ) != 0 ) )
          goto Exit;
      }
      else
      {

        if ( ( ( error = (FT_Stream_Skip( stream, (FT_Long)(size) )) ) != 0 ) )
          goto Exit;
      }
    }

  Exit:
    if ( error )
      do { ft_mem_free( memory, (idx->offsets) ); (idx->offsets) = ((void *)0); } while ( 0 );

    return error;
  }


  static void
  cff_index_done( CFF_Index idx )
  {
    if ( idx->stream )
    {
      FT_Stream stream = idx->stream;
      FT_Memory memory = stream->memory;


      if ( idx->bytes )
        (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(idx->bytes) ));

      do { ft_mem_free( memory, (idx->offsets) ); (idx->offsets) = ((void *)0); } while ( 0 );
      memset( idx, 0, (FT_Offset)(sizeof ( *idx )) );
    }
  }


  static FT_Error
  cff_index_load_offsets( CFF_Index idx )
  {
    FT_Error error = FT_Err_Ok;
    FT_Stream stream = idx->stream;
    FT_Memory memory = stream->memory;


    if ( idx->count > 0 && idx->offsets == ((void *)0) )
    {
      FT_Byte offsize = idx->off_size;
      FT_ULong data_size;
      FT_Byte* p;
      FT_Byte* p_end;
      FT_ULong* poff;


      data_size = (FT_ULong)( idx->count + 1 ) * offsize;

      if ( ( ((idx->offsets) = (ft_mem_realloc( memory, sizeof ( *(idx->offsets) ), 0, (FT_Long)(idx->count + 1), ((void *)0), &error ))), error != 0 ) ||
           ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(idx->start + 3) )) ) != 0 ) ||
           ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(data_size) ))) ) != 0 ) )
        goto Exit;

      poff = idx->offsets;
      p = (FT_Byte*)stream->cursor;
      p_end = p + data_size;

      switch ( offsize )
      {
      case 1:
        for ( ; p < p_end; p++, poff++ )
          poff[0] = p[0];
        break;

      case 2:
        for ( ; p < p_end; p += 2, poff++ )
          poff[0] = ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p))[(1)] )) ) << (0) )) );
        break;

      case 3:
        for ( ; p < p_end; p += 3, poff++ )
          poff[0] = ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(0)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(1)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(2)] )) ) << (0) )) );
        break;

      default:
        for ( ; p < p_end; p += 4, poff++ )
          poff[0] = ( (FT_UInt32)(( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(0)] )) ) << (24) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(1)] )) ) << (16) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(2)] )) ) << (8) ) | ( ( (FT_UInt32)(( ((const FT_Byte*)(p))[(3)] )) ) << (0) )) );
      }

      (FT_Stream_ExitFrame( stream ));
    }

  Exit:
    if ( error )
      do { ft_mem_free( memory, (idx->offsets) ); (idx->offsets) = ((void *)0); } while ( 0 );

    return error;
  }





  static FT_Error
  cff_index_get_pointers( CFF_Index idx,
                          FT_Byte*** table,
                          FT_Byte** pool )
  {
    FT_Error error = FT_Err_Ok;
    FT_Memory memory = idx->stream->memory;

    FT_Byte** t = ((void *)0);
    FT_Byte* new_bytes = ((void *)0);


    *table = ((void *)0);

    if ( idx->offsets == ((void *)0) )
    {
      error = cff_index_load_offsets( idx );
      if ( error )
        goto Exit;
    }

    if ( idx->count > 0 &&
         !( ((t) = (ft_mem_realloc( memory, sizeof ( *(t) ), 0, (FT_Long)(idx->count + 1), ((void *)0), &error ))), error != 0 ) &&
         ( !pool || !( ((new_bytes) = (ft_mem_alloc( memory, (FT_Long)(idx->data_size + idx->count), &error ))), error != 0 )
                                                             ) )
    {
      FT_ULong n, cur_offset;
      FT_ULong extra = 0;
      FT_Byte* org_bytes = idx->bytes;



      cur_offset = idx->offsets[0] - 1;


      if ( cur_offset != 0 )
      {
        do { } while ( 0 )

                                 ;
        cur_offset = 0;
      }

      if ( !pool )
        t[0] = org_bytes + cur_offset;
      else
        t[0] = new_bytes + cur_offset;

      for ( n = 1; n <= idx->count; n++ )
      {
        FT_ULong next_offset = idx->offsets[n] - 1;



        if ( next_offset < cur_offset )
          next_offset = cur_offset;
        else if ( next_offset > idx->data_size )
          next_offset = idx->data_size;

        if ( !pool )
          t[n] = org_bytes + next_offset;
        else
        {
          t[n] = new_bytes + next_offset + extra;

          if ( next_offset != cur_offset )
          {
            memcpy( t[n - 1], org_bytes + cur_offset, (FT_Offset)(t[n] - t[n - 1]) );
            t[n][0] = '\0';
            t[n] += 1;
            extra++;
          }
        }

        cur_offset = next_offset;
      }
      *table = t;

      if ( pool )
        *pool = new_bytes;
    }

  Exit:
    return error;
  }


  static FT_Error
  cff_index_access_element( CFF_Index idx,
                            FT_UInt element,
                            FT_Byte** pbytes,
                            FT_ULong* pbyte_len )
  {
    FT_Error error = FT_Err_Ok;


    if ( idx && idx->count > element )
    {

      FT_Stream stream = idx->stream;
      FT_ULong off1, off2 = 0;



      if ( !idx->offsets )
      {
        FT_ULong pos = element * idx->off_size;


        if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(idx->start + 3 + pos) )) ) != 0 ) )
          goto Exit;

        off1 = cff_index_read_offset( idx, &error );
        if ( error )
          goto Exit;

        if ( off1 != 0 )
        {
          do
          {
            element++;
            off2 = cff_index_read_offset( idx, &error );
          }
          while ( off2 == 0 && element < idx->count );
        }
      }
      else
      {
        off1 = idx->offsets[element];
        if ( off1 )
        {
          do
          {
            element++;
            off2 = idx->offsets[element];

          } while ( off2 == 0 && element < idx->count );
        }
      }



      if ( off2 > stream->size + 1 ||
           idx->data_offset > stream->size - off2 + 1 )
      {
        do { } while ( 0 )


                                                               ;
        off2 = stream->size - idx->data_offset + 1;
      }


      if ( off1 && off2 > off1 )
      {
        *pbyte_len = off2 - off1;

        if ( idx->bytes )
        {

          *pbytes = idx->bytes + off1 - 1;
        }
        else
        {

          if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(idx->data_offset + off1 - 1) )) ) != 0 ) ||
               ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(off2 - off1), (FT_Byte**)&(*pbytes) ))) ) != 0 ) )
            goto Exit;
        }
      }
      else
      {

        *pbytes = 0;
        *pbyte_len = 0;
      }
    }
    else
      error = CFF_Err_Invalid_Argument;

  Exit:
    return error;
  }


  static void
  cff_index_forget_element( CFF_Index idx,
                            FT_Byte** pbytes )
  {
    if ( idx->bytes == 0 )
    {
      FT_Stream stream = idx->stream;


      (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(*pbytes) ));
    }
  }



  static FT_String*
  cff_index_get_name( CFF_Font font,
                      FT_UInt element )
  {
    CFF_Index idx = &font->name_index;
    FT_Memory memory = idx->stream->memory;
    FT_Byte* bytes;
    FT_ULong byte_len;
    FT_Error error;
    FT_String* name = 0;


    error = cff_index_access_element( idx, element, &bytes, &byte_len );
    if ( error )
      goto Exit;

    if ( !( ((name) = (ft_mem_alloc( memory, (FT_Long)(byte_len + 1), &error ))), error != 0 ) )
    {
      memcpy( name, bytes, (FT_Offset)(byte_len) );
      name[byte_len] = 0;
    }
    cff_index_forget_element( idx, &bytes );

  Exit:
    return name;
  }



  static FT_String*
  cff_index_get_string( CFF_Font font,
                        FT_UInt element )
  {
    return ( element < font->num_strings )
             ? (FT_String*)font->strings[element]
             : ((void *)0);
  }


  static FT_String*
  cff_index_get_sid_string( CFF_Font font,
                            FT_UInt sid )
  {

    if ( sid == 0xFFFFU )
      return ((void *)0);


    if ( sid > 390 )
      return cff_index_get_string( font, sid - 391 );


    if ( !font->psnames )
      return ((void *)0);


    return (FT_String *)font->psnames->adobe_std_strings( sid );
  }
# 651 "../../../libs/freetype/src/cff/cffload.c"
  static void
  CFF_Done_FD_Select( CFF_FDSelect fdselect,
                      FT_Stream stream )
  {
    if ( fdselect->data )
      (FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(fdselect->data) ));

    fdselect->data_size = 0;
    fdselect->format = 0;
    fdselect->range_count = 0;
  }


  static FT_Error
  CFF_Load_FD_Select( CFF_FDSelect fdselect,
                      FT_UInt num_glyphs,
                      FT_Stream stream,
                      FT_ULong offset )
  {
    FT_Error error;
    FT_Byte format;
    FT_UInt num_ranges;



    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(offset) )) ) != 0 ) || ( format = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
      goto Exit;

    fdselect->format = format;
    fdselect->cache_count = 0;

    switch ( format )
    {
    case 0:
      fdselect->data_size = num_glyphs;
      goto Load_Data;

    case 3:
      if ( ( num_ranges = (FT_UShort)FT_Stream_ReadUShort( stream, &error ), error != FT_Err_Ok ) )
        goto Exit;

      if ( !num_ranges )
      {
        do { } while ( 0 );
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }

      fdselect->data_size = num_ranges * 3 + 2;

    Load_Data:
      if ( ( ( error = ((FT_Stream_ExtractFrame( stream, (FT_ULong)(fdselect->data_size), (FT_Byte**)&(fdselect->data) ))) ) != 0 ) )
        goto Exit;
      break;

    default:
      error = CFF_Err_Invalid_File_Format;
    }

  Exit:
    return error;
  }


  static FT_Byte
  cff_fd_select_get( CFF_FDSelect fdselect,
                     FT_UInt glyph_index )
  {
    FT_Byte fd = 0;


    switch ( fdselect->format )
    {
    case 0:
      fd = fdselect->data[glyph_index];
      break;

    case 3:

      if ( (FT_UInt)( glyph_index - fdselect->cache_first ) <
                        fdselect->cache_count )
      {
        fd = fdselect->cache_fd;
        break;
      }


      {
        FT_Byte* p = fdselect->data;
        FT_Byte* p_limit = p + fdselect->data_size;
        FT_Byte fd2;
        FT_UInt first, limit;


        first = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );
        do
        {
          if ( glyph_index < first )
            break;

          fd2 = *p++;
          limit = ( (unsigned short)( p += 2, ( (FT_UInt16)(( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(0)] )) ) << (8) ) | ( ( (FT_UInt16)(( ((const FT_Byte*)(p - 2))[(1)] )) ) << (0) )) ) ) );

          if ( glyph_index < limit )
          {
            fd = fd2;


            fdselect->cache_first = first;
            fdselect->cache_count = limit - first;
            fdselect->cache_fd = fd2;
            break;
          }
          first = limit;

        } while ( p < p_limit );
      }
      break;

    default:
      ;
    }

    return fd;
  }
# 786 "../../../libs/freetype/src/cff/cffload.c"
  static FT_Error
  cff_charset_compute_cids( CFF_Charset charset,
                            FT_UInt num_glyphs,
                            FT_Memory memory )
  {
    FT_Error error = FT_Err_Ok;
    FT_UInt i;
    FT_Long j;
    FT_UShort max_cid = 0;


    if ( charset->max_cid > 0 )
      goto Exit;

    for ( i = 0; i < num_glyphs; i++ )
    {
      if ( charset->sids[i] > max_cid )
        max_cid = charset->sids[i];
    }

    if ( ( ((charset->cids) = (ft_mem_realloc( memory, sizeof ( *(charset->cids) ), 0, (FT_Long)((FT_ULong)max_cid + 1), ((void *)0), &error ))), error != 0 ) )
      goto Exit;




    for ( j = (FT_Long)num_glyphs - 1; j >= 0 ; j-- )
      charset->cids[charset->sids[j]] = (FT_UShort)j;

    charset->max_cid = max_cid;
    charset->num_glyphs = num_glyphs;

  Exit:
    return error;
  }


  static FT_UInt
  cff_charset_cid_to_gindex( CFF_Charset charset,
                             FT_UInt cid )
  {
    FT_UInt result = 0;


    if ( cid <= charset->max_cid )
      result = charset->cids[cid];

    return result;
  }


  static void
  cff_charset_free_cids( CFF_Charset charset,
                         FT_Memory memory )
  {
    do { ft_mem_free( memory, (charset->cids) ); (charset->cids) = ((void *)0); } while ( 0 );
    charset->max_cid = 0;
  }


  static void
  cff_charset_done( CFF_Charset charset,
                    FT_Stream stream )
  {
    FT_Memory memory = stream->memory;


    cff_charset_free_cids( charset, memory );

    do { ft_mem_free( memory, (charset->sids) ); (charset->sids) = ((void *)0); } while ( 0 );
    charset->format = 0;
    charset->offset = 0;
  }


  static FT_Error
  cff_charset_load( CFF_Charset charset,
                    FT_UInt num_glyphs,
                    FT_Stream stream,
                    FT_ULong base_offset,
                    FT_ULong offset,
                    FT_Bool invert )
  {
    FT_Memory memory = stream->memory;
    FT_Error error = FT_Err_Ok;
    FT_UShort glyph_sid;




    if ( offset > 2 )
    {
      FT_UInt j;


      charset->offset = base_offset + offset;


      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(charset->offset) )) ) != 0 ) ||
           ( charset->format = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
        goto Exit;


      if ( ( ((charset->sids) = (ft_mem_realloc( memory, sizeof ( *(charset->sids) ), 0, (FT_Long)(num_glyphs), ((void *)0), &error ))), error != 0 ) )
        goto Exit;


      charset->sids[0] = 0;

      switch ( charset->format )
      {
      case 0:
        if ( num_glyphs > 0 )
        {
          if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(( num_glyphs - 1 ) * 2) ))) ) != 0 ) )
            goto Exit;

          for ( j = 1; j < num_glyphs; j++ )
            charset->sids[j] = ( (FT_UShort)FT_Stream_GetUShort( stream ) );

          (FT_Stream_ExitFrame( stream ));
        }
        break;

      case 1:
      case 2:
        {
          FT_UInt nleft;
          FT_UInt i;


          j = 1;

          while ( j < num_glyphs )
          {

            if ( ( glyph_sid = (FT_UShort)FT_Stream_ReadUShort( stream, &error ), error != FT_Err_Ok ) )
              goto Exit;


            if ( charset->format == 2 )
            {
              if ( ( nleft = (FT_UShort)FT_Stream_ReadUShort( stream, &error ), error != FT_Err_Ok ) )
                goto Exit;
            }
            else
            {
              if ( ( nleft = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
                goto Exit;
            }


            if ( glyph_sid > 0xFFFFL - nleft )
            {
              do { } while ( 0 )
                                                                           ;
              nleft = ( FT_UInt )( 0xFFFFL - glyph_sid );
            }


            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )
              charset->sids[j] = glyph_sid;
          }
        }
        break;

      default:
        do { } while ( 0 );
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }
    else
    {
# 968 "../../../libs/freetype/src/cff/cffload.c"
      charset->offset = offset;

      switch ( (FT_UInt)offset )
      {
      case 0:
        if ( num_glyphs > 229 )
        {
          do { } while ( 0 )
                                                                ;
          error = CFF_Err_Invalid_File_Format;
          goto Exit;
        }


        if ( ( ((charset->sids) = (ft_mem_realloc( memory, sizeof ( *(charset->sids) ), 0, (FT_Long)(num_glyphs), ((void *)0), &error ))), error != 0 ) )
          goto Exit;


        memcpy( charset->sids, cff_isoadobe_charset, (FT_Offset)((FT_Offset)(num_glyphs) * sizeof ( *(charset->sids) )) );

        break;

      case 1:
        if ( num_glyphs > 166 )
        {
          do { } while ( 0 )
                                                             ;
          error = CFF_Err_Invalid_File_Format;
          goto Exit;
        }


        if ( ( ((charset->sids) = (ft_mem_realloc( memory, sizeof ( *(charset->sids) ), 0, (FT_Long)(num_glyphs), ((void *)0), &error ))), error != 0 ) )
          goto Exit;


        memcpy( charset->sids, cff_expert_charset, (FT_Offset)((FT_Offset)(num_glyphs) * sizeof ( *(charset->sids) )) );

        break;

      case 2:
        if ( num_glyphs > 87 )
        {
          do { } while ( 0 )
                                                                    ;
          error = CFF_Err_Invalid_File_Format;
          goto Exit;
        }


        if ( ( ((charset->sids) = (ft_mem_realloc( memory, sizeof ( *(charset->sids) ), 0, (FT_Long)(num_glyphs), ((void *)0), &error ))), error != 0 ) )
          goto Exit;


        memcpy( charset->sids, cff_expertsubset_charset, (FT_Offset)((FT_Offset)(num_glyphs) * sizeof ( *(charset->sids) )) );

        break;

      default:
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }


    if ( invert )
      error = cff_charset_compute_cids( charset, num_glyphs, memory );

  Exit:

    if ( error )
    {
      do { ft_mem_free( memory, (charset->sids) ); (charset->sids) = ((void *)0); } while ( 0 );
      do { ft_mem_free( memory, (charset->cids) ); (charset->cids) = ((void *)0); } while ( 0 );
      charset->format = 0;
      charset->offset = 0;
      charset->sids = 0;
    }

    return error;
  }


  static void
  cff_encoding_done( CFF_Encoding encoding )
  {
    encoding->format = 0;
    encoding->offset = 0;
    encoding->count = 0;
  }


  static FT_Error
  cff_encoding_load( CFF_Encoding encoding,
                     CFF_Charset charset,
                     FT_UInt num_glyphs,
                     FT_Stream stream,
                     FT_ULong base_offset,
                     FT_ULong offset )
  {
    FT_Error error = FT_Err_Ok;
    FT_UInt count;
    FT_UInt j;
    FT_UShort glyph_sid;
    FT_UInt glyph_code;



    if ( !charset->sids )
    {
      error = CFF_Err_Invalid_File_Format;
      goto Exit;
    }


    for ( j = 0; j < 256; j++ )
    {
      encoding->sids [j] = 0;
      encoding->codes[j] = 0;
    }
# 1101 "../../../libs/freetype/src/cff/cffload.c"
    if ( offset > 1 )
    {
      encoding->offset = base_offset + offset;


      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(encoding->offset) )) ) != 0 ) ||
           ( encoding->format = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) ||
           ( count = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
        goto Exit;

      switch ( encoding->format & 0x7F )
      {
      case 0:
        {
          FT_Byte* p;






          encoding->count = count + 1;

          if ( ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(count) ))) ) != 0 ) )
            goto Exit;

          p = (FT_Byte*)stream->cursor;

          for ( j = 1; j <= count; j++ )
          {
            glyph_code = *p++;


            if ( j < num_glyphs )
            {

              encoding->codes[glyph_code] = (FT_UShort)j;


              encoding->sids[glyph_code] = charset->sids[j];
            }
          }

          (FT_Stream_ExitFrame( stream ));
        }
        break;

      case 1:
        {
          FT_UInt nleft;
          FT_UInt i = 1;
          FT_UInt k;


          encoding->count = 0;


          for ( j = 0; j < count; j++, i += nleft )
          {

            if ( ( glyph_code = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
              goto Exit;


            if ( ( nleft = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
              goto Exit;


            nleft++;


            if ( (FT_UInt)nleft > encoding->count )
              encoding->count = nleft;


            for ( k = i; k < nleft + i; k++, glyph_code++ )
            {

              if ( k < num_glyphs && glyph_code < 256 )
              {

                encoding->codes[glyph_code] = (FT_UShort)k;


                encoding->sids[glyph_code] = charset->sids[k];
              }
            }
          }


          if ( encoding->count > 256 )
            encoding->count = 256;
        }
        break;

      default:
        do { } while ( 0 );
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }


      if ( encoding->format & 0x80 )
      {
        FT_UInt gindex;



        if ( ( count = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
          goto Exit;

        for ( j = 0; j < count; j++ )
        {

          if ( ( glyph_code = (FT_Byte)FT_Stream_ReadChar( stream, &error ), error != FT_Err_Ok ) )
            goto Exit;


          if ( ( glyph_sid = (FT_UShort)FT_Stream_ReadUShort( stream, &error ), error != FT_Err_Ok ) )
            goto Exit;


          encoding->sids[glyph_code] = glyph_sid;



          for ( gindex = 0; gindex < num_glyphs; gindex++ )
          {
            if ( charset->sids[gindex] == glyph_sid )
            {
              encoding->codes[glyph_code] = (FT_UShort)gindex;
              break;
            }
          }
        }
      }
    }
    else
    {





      switch ( (FT_UInt)offset )
      {
      case 0:

        memcpy( encoding->sids, cff_standard_encoding, (FT_Offset)((FT_Offset)(256) * sizeof ( *(encoding->sids) )) );
        goto Populate;

      case 1:

        memcpy( encoding->sids, cff_expert_encoding, (FT_Offset)((FT_Offset)(256) * sizeof ( *(encoding->sids) )) );

      Populate:



        encoding->count = 0;

        error = cff_charset_compute_cids( charset, num_glyphs,
                                          stream->memory );
        if ( error )
          goto Exit;

        for ( j = 0; j < 256; j++ )
        {
          FT_UInt sid = encoding->sids[j];
          FT_UInt gid = 0;


          if ( sid )
            gid = cff_charset_cid_to_gindex( charset, sid );

          if ( gid != 0 )
          {
            encoding->codes[j] = (FT_UShort)gid;
            encoding->count = j + 1;
          }
          else
          {
            encoding->codes[j] = 0;
            encoding->sids [j] = 0;
          }
        }
        break;

      default:
        do { } while ( 0 );
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }

  Exit:


    return error;
  }


  static FT_Error
  cff_subfont_load( CFF_SubFont font,
                    CFF_Index idx,
                    FT_UInt font_index,
                    FT_Stream stream,
                    FT_ULong base_offset,
                    FT_Library library )
  {
    FT_Error error;
    CFF_ParserRec parser;
    FT_Byte* dict = ((void *)0);
    FT_ULong dict_len;
    CFF_FontRecDict top = &font->font_dict;
    CFF_Private priv = &font->private_dict;


    cff_parser_init( &parser, 0x1000, &font->font_dict, library );


    memset( top, 0, (FT_Offset)(sizeof ( *top )) );

    top->underline_position = -( 100L << 16 );
    top->underline_thickness = 50L << 16;
    top->charstring_type = 2;
    top->font_matrix.xx = 0x10000L;
    top->font_matrix.yy = 0x10000L;
    top->cid_count = 8720;



    top->version = 0xFFFFU;
    top->notice = 0xFFFFU;
    top->copyright = 0xFFFFU;
    top->full_name = 0xFFFFU;
    top->family_name = 0xFFFFU;
    top->weight = 0xFFFFU;
    top->embedded_postscript = 0xFFFFU;

    top->cid_registry = 0xFFFFU;
    top->cid_ordering = 0xFFFFU;
    top->cid_font_name = 0xFFFFU;

    error = cff_index_access_element( idx, font_index, &dict, &dict_len );
    if ( !error )
    {
      do { } while ( 0 );
      error = cff_parser_run( &parser, dict, dict + dict_len );
    }

    cff_index_forget_element( idx, &dict );

    if ( error )
      goto Exit;


    if ( top->cid_registry != 0xFFFFU )
      goto Exit;


    if ( top->private_offset && top->private_size )
    {

      memset( priv, 0, (FT_Offset)(sizeof ( *priv )) );

      priv->blue_shift = 7;
      priv->blue_fuzz = 1;
      priv->lenIV = -1;
      priv->expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
      priv->blue_scale = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );

      cff_parser_init( &parser, 0x2000, priv, library );

      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(base_offset + font->font_dict.private_offset) )) ) != 0 ) ||
           ( ( error = ((FT_Stream_EnterFrame( stream, (FT_ULong)(font->font_dict.private_size) ))) ) != 0 ) )
        goto Exit;

      do { } while ( 0 );
      error = cff_parser_run( &parser,
                              (FT_Byte*)stream->cursor,
                              (FT_Byte*)stream->limit );
      (FT_Stream_ExitFrame( stream ));
      if ( error )
        goto Exit;


      priv->num_blue_values &= ~1;
    }


    if ( priv->local_subrs_offset )
    {
      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(base_offset + top->private_offset + priv->local_subrs_offset) )) ) != 0 )
                                                      )
        goto Exit;

      error = cff_index_init( &font->local_subrs_index, stream, 1 );
      if ( error )
        goto Exit;

      error = cff_index_get_pointers( &font->local_subrs_index,
                                      &font->local_subrs, ((void *)0) );
      if ( error )
        goto Exit;
    }

  Exit:
    return error;
  }


  static void
  cff_subfont_done( FT_Memory memory,
                    CFF_SubFont subfont )
  {
    if ( subfont )
    {
      cff_index_done( &subfont->local_subrs_index );
      do { ft_mem_free( memory, (subfont->local_subrs) ); (subfont->local_subrs) = ((void *)0); } while ( 0 );
    }
  }


  static FT_Error
  cff_font_load( FT_Library library,
                 FT_Stream stream,
                 FT_Int face_index,
                 CFF_Font font,
                 FT_Bool pure_cff )
  {
    static const FT_Frame_Field cff_header_fields[] =
    {



      { ft_frame_start, 0, 4 },
        { ft_frame_byte, (FT_Byte)sizeof ( ((CFF_FontRec*)0)->version_major ), (FT_UShort)( __builtin_offsetof (CFF_FontRec, version_major) ) },
        { ft_frame_byte, (FT_Byte)sizeof ( ((CFF_FontRec*)0)->version_minor ), (FT_UShort)( __builtin_offsetof (CFF_FontRec, version_minor) ) },
        { ft_frame_byte, (FT_Byte)sizeof ( ((CFF_FontRec*)0)->header_size ), (FT_UShort)( __builtin_offsetof (CFF_FontRec, header_size) ) },
        { ft_frame_byte, (FT_Byte)sizeof ( ((CFF_FontRec*)0)->absolute_offsize ), (FT_UShort)( __builtin_offsetof (CFF_FontRec, absolute_offsize) ) },
      { ft_frame_end, 0, 0 }
    };

    FT_Error error;
    FT_Memory memory = stream->memory;
    FT_ULong base_offset;
    CFF_FontRecDict dict;
    CFF_IndexRec string_index;
    FT_UInt subfont_index;


    memset( font, 0, (FT_Offset)(sizeof ( *(font) )) );
    memset( &string_index, 0, (FT_Offset)(sizeof ( *(&string_index) )) );

    font->stream = stream;
    font->memory = memory;
    dict = &font->top_font.font_dict;
    base_offset = FT_Stream_Pos( stream );


    if ( ( ( error = (FT_Stream_ReadFields( stream, cff_header_fields, font )) ) != 0 ) )
      goto Exit;


    if ( font->version_major != 1 ||
         font->header_size < 4 ||
         font->absolute_offsize > 4 )
    {
      do { } while ( 0 );
      error = CFF_Err_Unknown_File_Format;
      goto Exit;
    }


    if ( ( ( error = (FT_Stream_Skip( stream, (FT_Long)(font->header_size - 4) )) ) != 0 ) )
      goto Exit;


    if ( ( ( error = (cff_index_init( &font->name_index, stream, 0 )) ) != 0 )
                                                                      ||
         ( ( error = (cff_index_init( &font->font_dict_index, stream, 0 )) ) != 0 )
                                                                      ||
         ( ( error = (cff_index_init( &string_index, stream, 1 )) ) != 0 )
                                                                      ||
         ( ( error = (cff_index_init( &font->global_subrs_index, stream, 1 )) ) != 0 )
                                                                      ||
         ( ( error = (cff_index_get_pointers( &string_index, &font->strings, &font->string_pool )) ) != 0 )

                                                                      )
      goto Exit;

    font->num_strings = string_index.count;

    if ( pure_cff )
    {

      subfont_index = (FT_UInt)( face_index & 0xFFFF );

      if ( face_index > 0 && subfont_index >= font->name_index.count )
      {
        do { } while ( 0 )

                                   ;
        error = CFF_Err_Invalid_Argument;
        goto Exit;
      }

      font->num_faces = font->name_index.count;
    }
    else
    {
      subfont_index = 0;

      if ( font->name_index.count > 1 )
      {
        do { } while ( 0 )


                                          ;
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }


    if ( face_index < 0 )
      goto Exit;


    do { } while ( 0 );
    error = cff_subfont_load( &font->top_font,
                              &font->font_dict_index,
                              subfont_index,
                              stream,
                              base_offset,
                              library );
    if ( error )
      goto Exit;

    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(base_offset + dict->charstrings_offset) )) ) != 0 ) )
      goto Exit;

    error = cff_index_init( &font->charstrings_index, stream, 0 );
    if ( error )
      goto Exit;


    if ( dict->cid_registry != 0xFFFFU )
    {
      CFF_IndexRec fd_index;
      CFF_SubFont sub = ((void *)0);
      FT_UInt idx;




      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(base_offset + dict->cid_fd_array_offset) )) ) != 0 ) )
        goto Exit;

      error = cff_index_init( &fd_index, stream, 0 );
      if ( error )
        goto Exit;

      if ( fd_index.count > 256 )
      {
        do { } while ( 0 );
        goto Fail_CID;
      }


      font->num_subfonts = fd_index.count;
      if ( ( ((sub) = (ft_mem_realloc( memory, sizeof ( *(sub) ), 0, (FT_Long)(fd_index.count), ((void *)0), &error ))), error != 0 ) )
        goto Fail_CID;


      for ( idx = 0; idx < fd_index.count; idx++ )
        font->subfonts[idx] = sub + idx;


      for ( idx = 0; idx < fd_index.count; idx++ )
      {
        sub = font->subfonts[idx];
        do { } while ( 0 );
        error = cff_subfont_load( sub, &fd_index, idx,
                                  stream, base_offset, library );
        if ( error )
          goto Fail_CID;
      }


      error = CFF_Load_FD_Select( &font->fd_select,
                                  font->charstrings_index.count,
                                  stream,
                                  base_offset + dict->cid_fd_select_offset );

    Fail_CID:
      cff_index_done( &fd_index );

      if ( error )
        goto Exit;
    }
    else
      font->num_subfonts = 0;


    if ( dict->charstrings_offset == 0 )
    {
      do { } while ( 0 );
      error = CFF_Err_Invalid_File_Format;
      goto Exit;
    }

    font->num_glyphs = font->charstrings_index.count;

    error = cff_index_get_pointers( &font->global_subrs_index,
                                    &font->global_subrs, ((void *)0) );

    if ( error )
      goto Exit;


    if ( font->num_glyphs > 0 )
    {
      FT_Bool invert = ( (FT_Bool)( dict->cid_registry != 0xFFFFU && pure_cff ) );


      error = cff_charset_load( &font->charset, font->num_glyphs, stream,
                                base_offset, dict->charset_offset, invert );
      if ( error )
        goto Exit;


      if ( dict->cid_registry == 0xFFFFU )
      {
        error = cff_encoding_load( &font->encoding,
                                   &font->charset,
                                   font->num_glyphs,
                                   stream,
                                   base_offset,
                                   dict->encoding_offset );
        if ( error )
          goto Exit;
      }
    }



    font->font_name = cff_index_get_name( font, subfont_index );

  Exit:
    cff_index_done( &string_index );

    return error;
  }


  static void
  cff_font_done( CFF_Font font )
  {
    FT_Memory memory = font->memory;
    FT_UInt idx;


    cff_index_done( &font->global_subrs_index );
    cff_index_done( &font->font_dict_index );
    cff_index_done( &font->name_index );
    cff_index_done( &font->charstrings_index );



    if ( font->num_subfonts > 0 )
    {
      for ( idx = 0; idx < font->num_subfonts; idx++ )
        cff_subfont_done( memory, font->subfonts[idx] );


      do { ft_mem_free( memory, (font->subfonts[0]) ); (font->subfonts[0]) = ((void *)0); } while ( 0 );
    }

    cff_encoding_done( &font->encoding );
    cff_charset_done( &font->charset, font->stream );

    cff_subfont_done( memory, &font->top_font );

    CFF_Done_FD_Select( &font->fd_select, font->stream );

    do { ft_mem_free( memory, (font->font_info) ); (font->font_info) = ((void *)0); } while ( 0 );

    do { ft_mem_free( memory, (font->font_name) ); (font->font_name) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (font->global_subrs) ); (font->global_subrs) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (font->strings) ); (font->strings) = ((void *)0); } while ( 0 );
    do { ft_mem_free( memory, (font->string_pool) ); (font->string_pool) = ((void *)0); } while ( 0 );

    if ( font->cf2_instance.finalizer )
    {
      font->cf2_instance.finalizer( font->cf2_instance.data );
      do { ft_mem_free( memory, (font->cf2_instance.data) ); (font->cf2_instance.data) = ((void *)0); } while ( 0 );
    }
  }
# 27 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cffobjs.c" 1
# 22 "../../../libs/freetype/src/cff/cffobjs.c"
# 1 "../../../libs/freetype/include/freetype/internal/ftcalc.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftcalc.h"

# 79 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  static __inline__ FT_Int32
  FT_MulFix_arm( FT_Int32 a,
                 FT_Int32 b )
  {
    FT_Int32 t, t2;


    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"
      "mov    %0, %2, asr #31\n\t"



      "add    %0, %0, #0x8000\n\t"

      "adds   %1, %1, %0\n\t"
      "adc    %2, %2, #0\n\t"
      "mov    %0, %1, lsr #16\n\t"
      "orr    %0, %0, %2, lsl #16\n\t"
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );
    return a;
  }
# 272 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Long
  FT_MulDiv_No_Round( FT_Long a,
                      FT_Long b,
                      FT_Long c );
# 286 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern void
  FT_Matrix_Multiply_Scaled( const FT_Matrix* a,
                             FT_Matrix *b,
                             FT_Long scaling );






  extern void
  FT_Vector_Transform_Scaled( FT_Vector* vector,
                              const FT_Matrix* matrix,
                              FT_Long scaling );
# 310 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_UInt32
  FT_Vector_NormLen( FT_Vector* vector );
# 320 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Int
  ft_corner_orientation( FT_Pos in_x,
                         FT_Pos in_y,
                         FT_Pos out_x,
                         FT_Pos out_y );







  extern FT_Int
  ft_corner_is_flat( FT_Pos in_x,
                     FT_Pos in_y,
                     FT_Pos out_x,
                     FT_Pos out_y );
# 372 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Fixed
  FT_Hypot( FT_Fixed x,
            FT_Fixed y );
# 413 "../../../libs/freetype/include/freetype/internal/ftcalc.h"

# 23 "../../../libs/freetype/src/cff/cffobjs.c" 2


# 1 "../../../libs/freetype/include/freetype/ttnameid.h" 1
# 26 "../../../libs/freetype/include/freetype/ttnameid.h"

# 1232 "../../../libs/freetype/include/freetype/ttnameid.h"

# 26 "../../../libs/freetype/src/cff/cffobjs.c" 2
# 58 "../../../libs/freetype/src/cff/cffobjs.c"
  static PSH_Globals_Funcs
  cff_size_get_globals_funcs( CFF_Size size )
  {
    CFF_Face face = (CFF_Face)size->root.face;
    CFF_Font font = (CFF_Font)face->extra.data;
    PSHinter_Service pshinter = font->pshinter;
    FT_Module module;


    module = FT_Get_Module( size->root.face->driver->root.library,
                            "pshinter" );
    return ( module && pshinter && pshinter->get_globals_funcs )
           ? pshinter->get_globals_funcs( module )
           : 0;
  }


  static void
  cff_size_done( FT_Size cffsize )
  {
    CFF_Size size = (CFF_Size)cffsize;
    CFF_Face face = (CFF_Face)size->root.face;
    CFF_Font font = (CFF_Font)face->extra.data;
    CFF_Internal internal = (CFF_Internal)cffsize->internal;


    if ( internal )
    {
      PSH_Globals_Funcs funcs;


      funcs = cff_size_get_globals_funcs( size );
      if ( funcs )
      {
        FT_UInt i;


        funcs->destroy( internal->topfont );

        for ( i = font->num_subfonts; i > 0; i-- )
          funcs->destroy( internal->subfonts[i - 1] );
      }


    }
  }





  static void
  cff_make_private_dict( CFF_SubFont subfont,
                         PS_Private priv )
  {
    CFF_Private cpriv = &subfont->private_dict;
    FT_UInt n, count;


    memset( priv, 0, (FT_Offset)(sizeof ( *priv )) );

    count = priv->num_blue_values = cpriv->num_blue_values;
    for ( n = 0; n < count; n++ )
      priv->blue_values[n] = (FT_Short)cpriv->blue_values[n];

    count = priv->num_other_blues = cpriv->num_other_blues;
    for ( n = 0; n < count; n++ )
      priv->other_blues[n] = (FT_Short)cpriv->other_blues[n];

    count = priv->num_family_blues = cpriv->num_family_blues;
    for ( n = 0; n < count; n++ )
      priv->family_blues[n] = (FT_Short)cpriv->family_blues[n];

    count = priv->num_family_other_blues = cpriv->num_family_other_blues;
    for ( n = 0; n < count; n++ )
      priv->family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];

    priv->blue_scale = cpriv->blue_scale;
    priv->blue_shift = (FT_Int)cpriv->blue_shift;
    priv->blue_fuzz = (FT_Int)cpriv->blue_fuzz;

    priv->standard_width[0] = (FT_UShort)cpriv->standard_width;
    priv->standard_height[0] = (FT_UShort)cpriv->standard_height;

    count = priv->num_snap_widths = cpriv->num_snap_widths;
    for ( n = 0; n < count; n++ )
      priv->snap_widths[n] = (FT_Short)cpriv->snap_widths[n];

    count = priv->num_snap_heights = cpriv->num_snap_heights;
    for ( n = 0; n < count; n++ )
      priv->snap_heights[n] = (FT_Short)cpriv->snap_heights[n];

    priv->force_bold = cpriv->force_bold;
    priv->language_group = cpriv->language_group;
    priv->lenIV = cpriv->lenIV;
  }


  static FT_Error
  cff_size_init( FT_Size cffsize )
  {
    CFF_Size size = (CFF_Size)cffsize;
    FT_Error error = FT_Err_Ok;
    PSH_Globals_Funcs funcs = cff_size_get_globals_funcs( size );


    if ( funcs )
    {
      CFF_Face face = (CFF_Face)cffsize->face;
      CFF_Font font = (CFF_Font)face->extra.data;
      CFF_Internal internal = ((void *)0);

      PS_PrivateRec priv;
      FT_Memory memory = cffsize->face->memory;

      FT_UInt i;


      if ( ( ((internal) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *(internal) )), &error ))), error != 0 ) )
        goto Exit;

      cff_make_private_dict( &font->top_font, &priv );
      error = funcs->create( cffsize->face->memory, &priv,
                             &internal->topfont );
      if ( error )
        goto Exit;

      for ( i = font->num_subfonts; i > 0; i-- )
      {
        CFF_SubFont sub = font->subfonts[i - 1];


        cff_make_private_dict( sub, &priv );
        error = funcs->create( cffsize->face->memory, &priv,
                               &internal->subfonts[i - 1] );
        if ( error )
          goto Exit;
      }

      cffsize->internal = (FT_Size_Internal)(void*)internal;
    }

    size->strike_index = 0xFFFFFFFFUL;

  Exit:
    return error;
  }




  static FT_Error
  cff_size_select( FT_Size size,
                   FT_ULong strike_index )
  {
    CFF_Size cffsize = (CFF_Size)size;
    PSH_Globals_Funcs funcs;


    cffsize->strike_index = strike_index;

    FT_Select_Metrics( size->face, strike_index );

    funcs = cff_size_get_globals_funcs( cffsize );

    if ( funcs )
    {
      CFF_Face face = (CFF_Face)size->face;
      CFF_Font font = (CFF_Font)face->extra.data;
      CFF_Internal internal = (CFF_Internal)size->internal;

      FT_Long top_upm = (FT_Long)font->top_font.font_dict.units_per_em;
      FT_UInt i;


      funcs->set_scale( internal->topfont,
                        size->metrics.x_scale, size->metrics.y_scale,
                        0, 0 );

      for ( i = font->num_subfonts; i > 0; i-- )
      {
        CFF_SubFont sub = font->subfonts[i - 1];
        FT_Long sub_upm = (FT_Long)sub->font_dict.units_per_em;
        FT_Pos x_scale, y_scale;


        if ( top_upm != sub_upm )
        {
          x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
          y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
        }
        else
        {
          x_scale = size->metrics.x_scale;
          y_scale = size->metrics.y_scale;
        }

        funcs->set_scale( internal->subfonts[i - 1],
                          x_scale, y_scale, 0, 0 );
      }
    }

    return FT_Err_Ok;
  }




  static FT_Error
  cff_size_request( FT_Size size,
                    FT_Size_Request req )
  {
    CFF_Size cffsize = (CFF_Size)size;
    PSH_Globals_Funcs funcs;




    if ( ( size->face->face_flags & ( 1L << 1 ) ) )
    {
      CFF_Face cffface = (CFF_Face)size->face;
      SFNT_Service sfnt = (SFNT_Service)cffface->sfnt;
      FT_ULong strike_index;


      if ( sfnt->set_sbit_strike( cffface, req, &strike_index ) )
        cffsize->strike_index = 0xFFFFFFFFUL;
      else
        return cff_size_select( size, strike_index );
    }



    FT_Request_Metrics( size->face, req );

    funcs = cff_size_get_globals_funcs( cffsize );

    if ( funcs )
    {
      CFF_Face cffface = (CFF_Face)size->face;
      CFF_Font font = (CFF_Font)cffface->extra.data;
      CFF_Internal internal = (CFF_Internal)size->internal;

      FT_Long top_upm = (FT_Long)font->top_font.font_dict.units_per_em;
      FT_UInt i;


      funcs->set_scale( internal->topfont,
                        size->metrics.x_scale, size->metrics.y_scale,
                        0, 0 );

      for ( i = font->num_subfonts; i > 0; i-- )
      {
        CFF_SubFont sub = font->subfonts[i - 1];
        FT_Long sub_upm = (FT_Long)sub->font_dict.units_per_em;
        FT_Pos x_scale, y_scale;


        if ( top_upm != sub_upm )
        {
          x_scale = FT_MulDiv( size->metrics.x_scale, top_upm, sub_upm );
          y_scale = FT_MulDiv( size->metrics.y_scale, top_upm, sub_upm );
        }
        else
        {
          x_scale = size->metrics.x_scale;
          y_scale = size->metrics.y_scale;
        }

        funcs->set_scale( internal->subfonts[i - 1],
                          x_scale, y_scale, 0, 0 );
      }
    }

    return FT_Err_Ok;
  }
# 342 "../../../libs/freetype/src/cff/cffobjs.c"
  static void
  cff_slot_done( FT_GlyphSlot slot )
  {
    slot->internal->glyph_hints = ((void *)0);
  }


  static FT_Error
  cff_slot_init( FT_GlyphSlot slot )
  {
    CFF_Face face = (CFF_Face)slot->face;
    CFF_Font font = (CFF_Font)face->extra.data;
    PSHinter_Service pshinter = font->pshinter;


    if ( pshinter )
    {
      FT_Module module;


      module = FT_Get_Module( slot->face->driver->root.library,
                              "pshinter" );
      if ( module )
      {
        T2_Hints_Funcs funcs;


        funcs = pshinter->get_t2_funcs( module );
        slot->internal->glyph_hints = (void*)funcs;
      }
    }

    return FT_Err_Ok;
  }
# 384 "../../../libs/freetype/src/cff/cffobjs.c"
  static FT_String*
  cff_strcpy( FT_Memory memory,
              const FT_String* source )
  {
    FT_Error error;
    FT_String* result;


    (void)( ((result) = (char*)ft_mem_strdup( memory, (const char*)(source), &error )), error != 0 );

    ( (error) = (error) );

    return result;
  }






  static void
  remove_subset_prefix( FT_String* name )
  {
    FT_Int32 idx = 0;
    FT_Int32 length = (FT_Int32)strlen( name ) + 1;
    FT_Bool continue_search = 1;


    while ( continue_search )
    {
      if ( length >= 7 && name[6] == '+' )
      {
        for ( idx = 0; idx < 6; idx++ )
        {

          if ( !( 'A' <= name[idx] && name[idx] <= 'Z' ) )
            continue_search = 0;
        }

        if ( continue_search )
        {
          for ( idx = 7; idx < length; idx++ )
            name[idx - 7] = name[idx];
          length -= 7;
        }
      }
      else
        continue_search = 0;
    }
  }




  static void
  remove_style( FT_String* family_name,
                const FT_String* style_name )
  {
    FT_Int32 family_name_length, style_name_length;


    family_name_length = (FT_Int32)strlen( family_name );
    style_name_length = (FT_Int32)strlen( style_name );

    if ( family_name_length > style_name_length )
    {
      FT_Int idx;


      for ( idx = 1; idx <= style_name_length; ++idx )
      {
        if ( family_name[family_name_length - idx] !=
             style_name[style_name_length - idx] )
          break;
      }

      if ( idx > style_name_length )
      {

        idx = family_name_length - style_name_length - 1;



        while ( idx > 0 &&
                ( family_name[idx] == '-' ||
                  family_name[idx] == ' ' ||
                  family_name[idx] == '_' ||
                  family_name[idx] == '+' ) )
          --idx;

        if ( idx > 0 )
          family_name[idx + 1] = '\0';
      }
    }
  }


  static FT_Error
  cff_face_init( FT_Stream stream,
                 FT_Face cffface,
                 FT_Int face_index,
                 FT_Int num_params,
                 FT_Parameter* params )
  {
    CFF_Face face = (CFF_Face)cffface;
    FT_Error error;
    SFNT_Service sfnt;
    FT_Service_PsCMaps psnames;
    PSHinter_Service pshinter;
    FT_Bool pure_cff = 1;
    FT_Bool sfnt_format = 0;
    FT_Library library = cffface->driver->root.library;


    sfnt = (SFNT_Service)FT_Get_Module_Interface(
             library, "sfnt" );
    if ( !sfnt )
    {
      do { } while ( 0 );
      error = CFF_Err_Missing_Module;
      goto Exit;
    }

    do { FT_Module module = ((FT_Module)( ((FT_Face)(face))->driver )); FT_Pointer _tmp_; _tmp_ = ft_module_get_service( module, "postscript-cmaps" ); psnames = _tmp_; } while ( 0 );

    pshinter = (PSHinter_Service)FT_Get_Module_Interface(
                 library, "pshinter" );

    do { } while ( 0 );


    if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(0) )) ) != 0 ) )
      goto Exit;


    error = sfnt->init_face( stream, face, face_index, num_params, params );
    if ( !error )
    {
      if ( face->format_tag != (FT_Tag) ( ( (FT_ULong)'O' << 24 ) | ( (FT_ULong)'T' << 16 ) | ( (FT_ULong)'T' << 8 ) | (FT_ULong)'O' ) )
      {
        do { } while ( 0 );
        error = CFF_Err_Unknown_File_Format;
        goto Exit;
      }


      if ( face_index < 0 )
        return FT_Err_Ok;

      sfnt_format = 1;



      error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'h' << 24 ) | ( (FT_ULong)'e' << 16 ) | ( (FT_ULong)'a' << 8 ) | (FT_ULong)'d' ), stream, 0 );
      if ( !error )
      {
        pure_cff = 0;


        error = sfnt->load_face( stream, face, face_index,
                                 num_params, params );
        if ( error )
          goto Exit;
      }
      else
      {

        error = sfnt->load_cmap( face, stream );
        if ( error )
          goto Exit;
      }


      error = face->goto_table( face, (FT_Tag) ( ( (FT_ULong)'C' << 24 ) | ( (FT_ULong)'F' << 16 ) | ( (FT_ULong)'F' << 8 ) | (FT_ULong)' ' ), stream, 0 );
      if ( error )
        goto Exit;
    }
    else
    {

      if ( ( ( error = (FT_Stream_Seek( stream, (FT_ULong)(0) )) ) != 0 ) )
        goto Exit;
      error = FT_Err_Ok;
    }


    {
      CFF_Font cff = ((void *)0);
      CFF_FontRecDict dict;
      FT_Memory memory = cffface->memory;
      FT_Int32 flags;
      FT_UInt i;


      if ( ( ((cff) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *(cff) )), &error ))), error != 0 ) )
        goto Exit;

      face->extra.data = cff;
      error = cff_font_load( library, stream, face_index, cff, pure_cff );
      if ( error )
        goto Exit;



      if ( face_index < 0 )
        return FT_Err_Ok;

      cff->pshinter = pshinter;
      cff->psnames = psnames;

      cffface->face_index = face_index & 0xFFFF;





      cffface->num_glyphs = (FT_Long)cff->num_glyphs;

      dict = &cff->top_font.font_dict;



      if ( dict->cid_registry == 0xFFFFU && !psnames )
      {
        do { } while ( 0 )


                                                       ;
        error = CFF_Err_Missing_Module;
        goto Exit;
      }
# 634 "../../../libs/freetype/src/cff/cffobjs.c"
      if ( !dict->has_font_matrix )
        dict->units_per_em = pure_cff ? 1000 : face->root.units_per_EM;
# 645 "../../../libs/freetype/src/cff/cffobjs.c"
      {
        FT_Matrix* matrix = &dict->font_matrix;
        FT_Vector* offset = &dict->font_offset;
        FT_ULong* upm = &dict->units_per_em;
        FT_Fixed temp = ( (matrix->yy) < 0 ? -(matrix->yy) : (matrix->yy) );


        if ( temp != 0x10000L )
        {
          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );

          matrix->xx = FT_DivFix( matrix->xx, temp );
          matrix->yx = FT_DivFix( matrix->yx, temp );
          matrix->xy = FT_DivFix( matrix->xy, temp );
          matrix->yy = FT_DivFix( matrix->yy, temp );
          offset->x = FT_DivFix( offset->x, temp );
          offset->y = FT_DivFix( offset->y, temp );
        }

        offset->x >>= 16;
        offset->y >>= 16;
      }

      for ( i = cff->num_subfonts; i > 0; i-- )
      {
        CFF_FontRecDict sub = &cff->subfonts[i - 1]->font_dict;
        CFF_FontRecDict top = &cff->top_font.font_dict;

        FT_Matrix* matrix;
        FT_Vector* offset;
        FT_ULong* upm;
        FT_Fixed temp;


        if ( sub->has_font_matrix )
        {
          FT_Long scaling;





          if ( top->has_font_matrix )
          {
            if ( top->units_per_em > 1 && sub->units_per_em > 1 )
              scaling = (FT_Long)( (top->units_per_em) < (sub->units_per_em) ? (top->units_per_em) : (sub->units_per_em) )
                                                            ;
            else
              scaling = 1;

            FT_Matrix_Multiply_Scaled( &top->font_matrix,
                                       &sub->font_matrix,
                                       scaling );
            FT_Vector_Transform_Scaled( &sub->font_offset,
                                        &top->font_matrix,
                                        scaling );

            sub->units_per_em = (FT_ULong)
                                  FT_MulDiv( (FT_Long)sub->units_per_em,
                                             (FT_Long)top->units_per_em,
                                             scaling );
          }
        }
        else
        {
          sub->font_matrix = top->font_matrix;
          sub->font_offset = top->font_offset;

          sub->units_per_em = top->units_per_em;
        }

        matrix = &sub->font_matrix;
        offset = &sub->font_offset;
        upm = &sub->units_per_em;
        temp = ( (matrix->yy) < 0 ? -(matrix->yy) : (matrix->yy) );

        if ( temp != 0x10000L )
        {
          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );

          matrix->xx = FT_DivFix( matrix->xx, temp );
          matrix->yx = FT_DivFix( matrix->yx, temp );
          matrix->xy = FT_DivFix( matrix->xy, temp );
          matrix->yy = FT_DivFix( matrix->yy, temp );
          offset->x = FT_DivFix( offset->x, temp );
          offset->y = FT_DivFix( offset->y, temp );
        }

        offset->x >>= 16;
        offset->y >>= 16;
      }

      if ( pure_cff )
      {
        char* style_name = ((void *)0);



        cffface->num_faces = (FT_Long)cff->num_faces;


        if ( dict->cid_registry != 0xFFFFU )
          cffface->num_glyphs = (FT_Long)( cff->charset.max_cid + 1 );
        else
          cffface->num_glyphs = (FT_Long)cff->charstrings_index.count;


        cffface->bbox.xMin = dict->font_bbox.xMin >> 16;
        cffface->bbox.yMin = dict->font_bbox.yMin >> 16;

        cffface->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFF ) >> 16;
        cffface->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFF ) >> 16;

        cffface->units_per_EM = (FT_UShort)( dict->units_per_em );

        cffface->ascender = (FT_Short)( cffface->bbox.yMax );
        cffface->descender = (FT_Short)( cffface->bbox.yMin );

        cffface->height = (FT_Short)( ( cffface->units_per_EM * 12 ) / 10 );
        if ( cffface->height < cffface->ascender - cffface->descender )
          cffface->height = (FT_Short)( cffface->ascender - cffface->descender );

        cffface->underline_position =
          (FT_Short)( dict->underline_position >> 16 );
        cffface->underline_thickness =
          (FT_Short)( dict->underline_thickness >> 16 );


        cffface->family_name = cff_index_get_name(
                                 cff,
                                 (FT_UInt)( face_index & 0xFFFF ) );
        if ( cffface->family_name )
        {
          char* full = cff_index_get_sid_string( cff,
                                                    dict->full_name );
          char* fullp = full;
          char* family = cffface->family_name;
          char* family_name = ((void *)0);


          remove_subset_prefix( cffface->family_name );

          if ( dict->family_name )
          {
            family_name = cff_index_get_sid_string( cff,
                                                    dict->family_name );
            if ( family_name )
              family = family_name;
          }



          if ( full && family )
          {
            while ( *fullp )
            {

              if ( *fullp == *family )
              {
                family++;
                fullp++;
                continue;
              }


              if ( *fullp == ' ' || *fullp == '-' )
              {
                fullp++;
                continue;
              }


              if ( *family == ' ' || *family == '-' )
              {
                family++;
                continue;
              }

              if ( !*family && *fullp )
              {




                style_name = cff_strcpy( memory, fullp );


                remove_style( cffface->family_name, style_name );
              }
              break;
            }
          }
        }
        else
        {
          char *cid_font_name =
                   cff_index_get_sid_string( cff,
                                             dict->cid_font_name );



          if ( cid_font_name )
            cffface->family_name = cff_strcpy( memory, cid_font_name );
        }

        if ( style_name )
          cffface->style_name = style_name;
        else

          cffface->style_name = cff_strcpy( memory, (char *)"Regular" );





        flags = ( 1L << 0 ) |
                ( 1L << 4 ) |
                ( 1L << 11 );

        if ( sfnt_format )
          flags |= ( 1L << 3 );


        if ( dict->is_fixed_pitch )
          flags |= ( 1L << 2 );
# 878 "../../../libs/freetype/src/cff/cffobjs.c"
        cffface->face_flags |= flags;





        flags = 0;

        if ( dict->italic_angle )
          flags |= ( 1 << 0 );

        {
          char *weight = cff_index_get_sid_string( cff,
                                                    dict->weight );


          if ( weight )
            if ( !strcmp( weight, "Bold" ) ||
                 !strcmp( weight, "Black" ) )
              flags |= ( 1 << 1 );
        }


        if ( !(flags & ( 1 << 1 )) && cffface->style_name )
          if ( !strncmp( cffface->style_name, "Bold", 4 ) ||
               !strncmp( cffface->style_name, "Black", 5 ) )
            flags |= ( 1 << 1 );

        cffface->style_flags = flags;
      }





      if ( dict->cid_registry == 0xFFFFU )
        cffface->face_flags |= ( 1L << 9 );


      if ( dict->cid_registry != 0xFFFFU && pure_cff )
        cffface->face_flags |= ( 1L << 12 );
# 929 "../../../libs/freetype/src/cff/cffobjs.c"
      {
        FT_CharMapRec cmaprec;
        FT_CharMap cmap;
        FT_UInt nn;
        CFF_Encoding encoding = &cff->encoding;


        for ( nn = 0; nn < (FT_UInt)cffface->num_charmaps; nn++ )
        {
          cmap = cffface->charmaps[nn];


          if ( cmap->platform_id == 3 &&
               cmap->encoding_id == 1 )
            goto Skip_Unicode;


          if ( cmap->platform_id == 0 )
            goto Skip_Unicode;
        }



        if ( pure_cff && cff->top_font.font_dict.cid_registry != 0xFFFFU )
          goto Exit;


        cmaprec.face = cffface;
        cmaprec.platform_id = 3;
        cmaprec.encoding_id = 1;
        cmaprec.encoding = FT_ENCODING_UNICODE;

        nn = (FT_UInt)cffface->num_charmaps;

        error = FT_CMap_New( &cff_cmap_unicode_class_rec, ((void *)0),
                             &cmaprec, ((void *)0) );
        if ( error &&
             ( ( (error) & 0xFF ) != ( (CFF_Err_No_Unicode_Glyph_Name) & 0xFF ) ) )
          goto Exit;
        error = FT_Err_Ok;


        if ( cffface->charmap == ((void *)0) && nn != (FT_UInt)cffface->num_charmaps )
          cffface->charmap = cffface->charmaps[nn];

      Skip_Unicode:
        if ( encoding->count > 0 )
        {
          FT_CMap_Class clazz;


          cmaprec.face = cffface;
          cmaprec.platform_id = 7;

          if ( encoding->offset == 0 )
          {
            cmaprec.encoding_id = 0;
            cmaprec.encoding = FT_ENCODING_ADOBE_STANDARD;
            clazz = &cff_cmap_encoding_class_rec;
          }
          else if ( encoding->offset == 1 )
          {
            cmaprec.encoding_id = 1;
            cmaprec.encoding = FT_ENCODING_ADOBE_EXPERT;
            clazz = &cff_cmap_encoding_class_rec;
          }
          else
          {
            cmaprec.encoding_id = 2;
            cmaprec.encoding = FT_ENCODING_ADOBE_CUSTOM;
            clazz = &cff_cmap_encoding_class_rec;
          }

          error = FT_CMap_New( clazz, ((void *)0), &cmaprec, ((void *)0) );
        }
      }
    }

  Exit:
    return error;
  }


  static void
  cff_face_done( FT_Face cffface )
  {
    CFF_Face face = (CFF_Face)cffface;
    FT_Memory memory;
    SFNT_Service sfnt;


    if ( !face )
      return;

    memory = cffface->memory;
    sfnt = (SFNT_Service)face->sfnt;

    if ( sfnt )
      sfnt->done_face( face );

    {
      CFF_Font cff = (CFF_Font)face->extra.data;


      if ( cff )
      {
        cff_font_done( cff );
        do { ft_mem_free( memory, (face->extra.data) ); (face->extra.data) = ((void *)0); } while ( 0 );
      }
    }
  }


  static FT_Error
  cff_driver_init( FT_Module module )
  {
    CFF_Driver driver = (CFF_Driver)module;






    driver->hinting_engine = 1;


    driver->no_stem_darkening = 1;

    driver->darken_params[0] = 500;
    driver->darken_params[1] = 400;
    driver->darken_params[2] = 1000;
    driver->darken_params[3] = 275;
    driver->darken_params[4] = 1667;
    driver->darken_params[5] = 275;
    driver->darken_params[6] = 2333;
    driver->darken_params[7] = 0;

    return FT_Err_Ok;
  }


  static void
  cff_driver_done( FT_Module module )
  {
    ( (module) = (module) );
  }
# 28 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cffgload.c" 1
# 23 "../../../libs/freetype/src/cff/cffgload.c"
# 1 "../../../libs/freetype/include/freetype/ftoutln.h" 1
# 34 "../../../libs/freetype/include/freetype/ftoutln.h"

# 118 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Decompose( FT_Outline* outline,
                        const FT_Outline_Funcs* func_interface,
                        void* user );
# 154 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_New( FT_Library library,
                  FT_UInt numPoints,
                  FT_Int numContours,
                  FT_Outline *anoutline );


  extern FT_Error
  FT_Outline_New_Internal( FT_Memory memory,
                           FT_UInt numPoints,
                           FT_Int numContours,
                           FT_Outline *anoutline );
# 192 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Done( FT_Library library,
                   FT_Outline* outline );


  extern FT_Error
  FT_Outline_Done_Internal( FT_Memory memory,
                            FT_Outline* outline );
# 216 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Check( FT_Outline* outline );
# 246 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Get_CBox( const FT_Outline* outline,
                       FT_BBox *acbox );
# 267 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Translate( const FT_Outline* outline,
                        FT_Pos xOffset,
                        FT_Pos yOffset );
# 292 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Copy( const FT_Outline* source,
                   FT_Outline *target );
# 316 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Transform( const FT_Outline* outline,
                        const FT_Matrix* matrix );
# 364 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Embolden( FT_Outline* outline,
                       FT_Pos strength );
# 380 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_EmboldenXY( FT_Outline* outline,
                         FT_Pos xstrength,
                         FT_Pos ystrength );
# 405 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Reverse( FT_Outline* outline );
# 440 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Get_Bitmap( FT_Library library,
                         FT_Outline* outline,
                         const FT_Bitmap *abitmap );
# 482 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Render( FT_Library library,
                     FT_Outline* outline,
                     FT_Raster_Params* params );
# 523 "../../../libs/freetype/include/freetype/ftoutln.h"
  typedef enum FT_Orientation_
  {
    FT_ORIENTATION_TRUETYPE = 0,
    FT_ORIENTATION_POSTSCRIPT = 1,
    FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE,
    FT_ORIENTATION_FILL_LEFT = FT_ORIENTATION_POSTSCRIPT,
    FT_ORIENTATION_NONE

  } FT_Orientation;
# 558 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Orientation
  FT_Outline_Get_Orientation( FT_Outline* outline );





# 24 "../../../libs/freetype/src/cff/cffgload.c" 2





# 1 "../../../libs/freetype/src/cff/cf2ft.h" 1
# 43 "../../../libs/freetype/src/cff/cf2ft.h"
# 1 "../../../libs/freetype/src/cff/cf2types.h" 1
# 46 "../../../libs/freetype/src/cff/cf2types.h"

# 69 "../../../libs/freetype/src/cff/cf2types.h"
  typedef FT_Int32 CF2_F16Dot16;



# 44 "../../../libs/freetype/src/cff/cf2ft.h" 2
# 52 "../../../libs/freetype/src/cff/cf2ft.h"
# 1 "../../../libs/freetype/src/cff/cf2glue.h" 1
# 44 "../../../libs/freetype/src/cff/cf2glue.h"
# 1 "../../../libs/freetype/src/cff/cf2error.h" 1
# 52 "../../../libs/freetype/src/cff/cf2error.h"
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  CF2_Err_Ok = 0x00,


  CF2_Err_Cannot_Open_Resource = 0x01 + 0,

  CF2_Err_Unknown_File_Format = 0x02 + 0,

  CF2_Err_Invalid_File_Format = 0x03 + 0,

  CF2_Err_Invalid_Version = 0x04 + 0,

  CF2_Err_Lower_Module_Version = 0x05 + 0,

  CF2_Err_Invalid_Argument = 0x06 + 0,

  CF2_Err_Unimplemented_Feature = 0x07 + 0,

  CF2_Err_Invalid_Table = 0x08 + 0,

  CF2_Err_Invalid_Offset = 0x09 + 0,

  CF2_Err_Array_Too_Large = 0x0A + 0,

  CF2_Err_Missing_Module = 0x0B + 0,

  CF2_Err_Missing_Property = 0x0C + 0,




  CF2_Err_Invalid_Glyph_Index = 0x10 + 0,

  CF2_Err_Invalid_Character_Code = 0x11 + 0,

  CF2_Err_Invalid_Glyph_Format = 0x12 + 0,

  CF2_Err_Cannot_Render_Glyph = 0x13 + 0,

  CF2_Err_Invalid_Outline = 0x14 + 0,

  CF2_Err_Invalid_Composite = 0x15 + 0,

  CF2_Err_Too_Many_Hints = 0x16 + 0,

  CF2_Err_Invalid_Pixel_Size = 0x17 + 0,




  CF2_Err_Invalid_Handle = 0x20 + 0,

  CF2_Err_Invalid_Library_Handle = 0x21 + 0,

  CF2_Err_Invalid_Driver_Handle = 0x22 + 0,

  CF2_Err_Invalid_Face_Handle = 0x23 + 0,

  CF2_Err_Invalid_Size_Handle = 0x24 + 0,

  CF2_Err_Invalid_Slot_Handle = 0x25 + 0,

  CF2_Err_Invalid_CharMap_Handle = 0x26 + 0,

  CF2_Err_Invalid_Cache_Handle = 0x27 + 0,

  CF2_Err_Invalid_Stream_Handle = 0x28 + 0,




  CF2_Err_Too_Many_Drivers = 0x30 + 0,

  CF2_Err_Too_Many_Extensions = 0x31 + 0,




  CF2_Err_Out_Of_Memory = 0x40 + 0,

  CF2_Err_Unlisted_Object = 0x41 + 0,




  CF2_Err_Cannot_Open_Stream = 0x51 + 0,

  CF2_Err_Invalid_Stream_Seek = 0x52 + 0,

  CF2_Err_Invalid_Stream_Skip = 0x53 + 0,

  CF2_Err_Invalid_Stream_Read = 0x54 + 0,

  CF2_Err_Invalid_Stream_Operation = 0x55 + 0,

  CF2_Err_Invalid_Frame_Operation = 0x56 + 0,

  CF2_Err_Nested_Frame_Access = 0x57 + 0,

  CF2_Err_Invalid_Frame_Read = 0x58 + 0,




  CF2_Err_Raster_Uninitialized = 0x60 + 0,

  CF2_Err_Raster_Corrupted = 0x61 + 0,

  CF2_Err_Raster_Overflow = 0x62 + 0,

  CF2_Err_Raster_Negative_Height = 0x63 + 0,




  CF2_Err_Too_Many_Caches = 0x70 + 0,




  CF2_Err_Invalid_Opcode = 0x80 + 0,

  CF2_Err_Too_Few_Arguments = 0x81 + 0,

  CF2_Err_Stack_Overflow = 0x82 + 0,

  CF2_Err_Code_Overflow = 0x83 + 0,

  CF2_Err_Bad_Argument = 0x84 + 0,

  CF2_Err_Divide_By_Zero = 0x85 + 0,

  CF2_Err_Invalid_Reference = 0x86 + 0,

  CF2_Err_Debug_OpCode = 0x87 + 0,

  CF2_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  CF2_Err_Nested_DEFS = 0x89 + 0,

  CF2_Err_Invalid_CodeRange = 0x8A + 0,

  CF2_Err_Execution_Too_Long = 0x8B + 0,

  CF2_Err_Too_Many_Function_Defs = 0x8C + 0,

  CF2_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  CF2_Err_Table_Missing = 0x8E + 0,

  CF2_Err_Horiz_Header_Missing = 0x8F + 0,

  CF2_Err_Locations_Missing = 0x90 + 0,

  CF2_Err_Name_Table_Missing = 0x91 + 0,

  CF2_Err_CMap_Table_Missing = 0x92 + 0,

  CF2_Err_Hmtx_Table_Missing = 0x93 + 0,

  CF2_Err_Post_Table_Missing = 0x94 + 0,

  CF2_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  CF2_Err_Invalid_CharMap_Format = 0x96 + 0,

  CF2_Err_Invalid_PPem = 0x97 + 0,

  CF2_Err_Invalid_Vert_Metrics = 0x98 + 0,

  CF2_Err_Could_Not_Find_Context = 0x99 + 0,

  CF2_Err_Invalid_Post_Table_Format = 0x9A + 0,

  CF2_Err_Invalid_Post_Table = 0x9B + 0,




  CF2_Err_Syntax_Error = 0xA0 + 0,

  CF2_Err_Stack_Underflow = 0xA1 + 0,

  CF2_Err_Ignore = 0xA2 + 0,

  CF2_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  CF2_Err_Glyph_Too_Big = 0xA4 + 0,




  CF2_Err_Missing_Startfont_Field = 0xB0 + 0,

  CF2_Err_Missing_Font_Field = 0xB1 + 0,

  CF2_Err_Missing_Size_Field = 0xB2 + 0,

  CF2_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  CF2_Err_Missing_Chars_Field = 0xB4 + 0,

  CF2_Err_Missing_Startchar_Field = 0xB5 + 0,

  CF2_Err_Missing_Encoding_Field = 0xB6 + 0,

  CF2_Err_Missing_Bbx_Field = 0xB7 + 0,

  CF2_Err_Bbx_Too_Big = 0xB8 + 0,

  CF2_Err_Corrupted_Font_Header = 0xB9 + 0,

  CF2_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  CF2_Err_Max };
# 53 "../../../libs/freetype/src/cff/cf2error.h" 2
# 1 "../../../libs/freetype/src/cff/cf2ft.h" 1
# 54 "../../../libs/freetype/src/cff/cf2error.h" 2



# 97 "../../../libs/freetype/src/cff/cf2error.h"
  static void
  cf2_setError( FT_Error* error,
                FT_Error value );
# 113 "../../../libs/freetype/src/cff/cf2error.h"

# 45 "../../../libs/freetype/src/cff/cf2glue.h" 2
# 1 "../../../libs/freetype/src/cff/cf2fixed.h" 1
# 43 "../../../libs/freetype/src/cff/cf2fixed.h"






  typedef FT_Int32 CF2_Frac;
# 80 "../../../libs/freetype/src/cff/cf2fixed.h"
  typedef enum CF2_NumberType_
  {
    CF2_NumberFixed,
    CF2_NumberFrac,
    CF2_NumberInt

  } CF2_NumberType;



# 46 "../../../libs/freetype/src/cff/cf2glue.h" 2
# 1 "../../../libs/freetype/src/cff/cf2arrst.h" 1
# 46 "../../../libs/freetype/src/cff/cf2arrst.h"





  typedef struct CF2_ArrStackRec_
  {
    FT_Memory memory;
    FT_Error* error;

    size_t sizeItem;
    size_t allocated;
    size_t chunk;
    size_t count;
    size_t totalSize;

    void* ptr;

  } CF2_ArrStackRec, *CF2_ArrStack;


  static void
  cf2_arrstack_init( CF2_ArrStack arrstack,
                     FT_Memory memory,
                     FT_Error* error,
                     size_t sizeItem );
  static void
  cf2_arrstack_finalize( CF2_ArrStack arrstack );

  static void
  cf2_arrstack_setCount( CF2_ArrStack arrstack,
                         size_t numElements );
  static void
  cf2_arrstack_clear( CF2_ArrStack arrstack );
  static size_t
  cf2_arrstack_size( const CF2_ArrStack arrstack );

  static void*
  cf2_arrstack_getBuffer( const CF2_ArrStack arrstack );
  static void*
  cf2_arrstack_getPointer( const CF2_ArrStack arrstack,
                           size_t idx );

  static void
  cf2_arrstack_push( CF2_ArrStack arrstack,
                     const void* ptr );



# 47 "../../../libs/freetype/src/cff/cf2glue.h" 2
# 1 "../../../libs/freetype/src/cff/cf2read.h" 1
# 43 "../../../libs/freetype/src/cff/cf2read.h"



  typedef struct CF2_BufferRec_
  {
    FT_Error* error;
    const FT_Byte* start;
    const FT_Byte* end;
    const FT_Byte* ptr;

  } CF2_BufferRec, *CF2_Buffer;


  static FT_Fast
  cf2_buf_readByte( CF2_Buffer buf );
  static FT_Bool
  cf2_buf_isEnd( CF2_Buffer buf );



# 48 "../../../libs/freetype/src/cff/cf2glue.h" 2



# 61 "../../../libs/freetype/src/cff/cf2glue.h"
  typedef FT_Fast CF2_RenderingFlags;



  typedef enum CF2_PathOp_
  {
    CF2_PathOpMoveTo = 1,
    CF2_PathOpLineTo = 2,
    CF2_PathOpQuadTo = 3,
    CF2_PathOpCubeTo = 4

  } CF2_PathOp;



  typedef struct CF2_Matrix_
  {
    CF2_F16Dot16 a;
    CF2_F16Dot16 b;
    CF2_F16Dot16 c;
    CF2_F16Dot16 d;
    CF2_F16Dot16 tx;
    CF2_F16Dot16 ty;

  } CF2_Matrix;




  typedef struct CF2_FontRec_ CF2_FontRec, *CF2_Font;
  typedef struct CF2_HintRec_ CF2_HintRec, *CF2_Hint;
# 102 "../../../libs/freetype/src/cff/cf2glue.h"
  typedef struct CF2_CallbackParamsRec_
  {
    FT_Vector pt0;
    FT_Vector pt1;
    FT_Vector pt2;
    FT_Vector pt3;

    FT_Fast op;

  } CF2_CallbackParamsRec, *CF2_CallbackParams;



  typedef struct CF2_OutlineCallbacksRec_ CF2_OutlineCallbacksRec,
                                           *CF2_OutlineCallbacks;


  typedef void
  (*CF2_Callback_Type)( CF2_OutlineCallbacks callbacks,
                        const CF2_CallbackParams params );


  struct CF2_OutlineCallbacksRec_
  {
    CF2_Callback_Type moveTo;
    CF2_Callback_Type lineTo;
    CF2_Callback_Type quadTo;
    CF2_Callback_Type cubeTo;

    FT_Fast windingMomentum;

    FT_Memory memory;
    FT_Error* error;
  };



# 53 "../../../libs/freetype/src/cff/cf2ft.h" 2






  static FT_Error
  cf2_decoder_parse_charstrings( CFF_Decoder* decoder,
                                 FT_Byte* charstring_base,
                                 FT_ULong charstring_len );

  static CFF_SubFont
  cf2_getSubfont( CFF_Decoder* decoder );


  static CF2_F16Dot16
  cf2_getPpemY( CFF_Decoder* decoder );
  static CF2_F16Dot16
  cf2_getStdVW( CFF_Decoder* decoder );
  static CF2_F16Dot16
  cf2_getStdHW( CFF_Decoder* decoder );

  static void
  cf2_getBlueMetrics( CFF_Decoder* decoder,
                      CF2_F16Dot16* blueScale,
                      CF2_F16Dot16* blueShift,
                      CF2_F16Dot16* blueFuzz );
  static void
  cf2_getBlueValues( CFF_Decoder* decoder,
                     size_t* count,
                     FT_Pos* *data );
  static void
  cf2_getOtherBlues( CFF_Decoder* decoder,
                     size_t* count,
                     FT_Pos* *data );
  static void
  cf2_getFamilyBlues( CFF_Decoder* decoder,
                      size_t* count,
                      FT_Pos* *data );
  static void
  cf2_getFamilyOtherBlues( CFF_Decoder* decoder,
                           size_t* count,
                           FT_Pos* *data );

  static FT_Fast
  cf2_getLanguageGroup( CFF_Decoder* decoder );

  static FT_Fast
  cf2_initGlobalRegionBuffer( CFF_Decoder* decoder,
                              FT_Fast subrNum,
                              CF2_Buffer buf );
  static FT_Error
  cf2_getSeacComponent( CFF_Decoder* decoder,
                        FT_Fast code,
                        CF2_Buffer buf );
  static void
  cf2_freeSeacComponent( CFF_Decoder* decoder,
                         CF2_Buffer buf );
  static FT_Fast
  cf2_initLocalRegionBuffer( CFF_Decoder* decoder,
                             FT_Fast subrNum,
                             CF2_Buffer buf );

  static CF2_F16Dot16
  cf2_getDefaultWidthX( CFF_Decoder* decoder );
  static CF2_F16Dot16
  cf2_getNominalWidthX( CFF_Decoder* decoder );







  typedef struct CF2_OutlineRec_
  {
    CF2_OutlineCallbacksRec root;
    CFF_Decoder* decoder;

  } CF2_OutlineRec, *CF2_Outline;


  static void
  cf2_outline_reset( CF2_Outline outline );
  static void
  cf2_outline_close( CF2_Outline outline );



# 30 "../../../libs/freetype/src/cff/cffgload.c" 2
# 252 "../../../libs/freetype/src/cff/cffgload.c"
  static void
  cff_builder_init( CFF_Builder* builder,
                    TT_Face face,
                    CFF_Size size,
                    CFF_GlyphSlot glyph,
                    FT_Bool hinting )
  {
    builder->path_begun = 0;
    builder->load_points = 1;

    builder->face = face;
    builder->glyph = glyph;
    builder->memory = face->root.memory;

    if ( glyph )
    {
      FT_GlyphLoader loader = glyph->root.internal->loader;


      builder->loader = loader;
      builder->base = &loader->base.outline;
      builder->current = &loader->current.outline;
      FT_GlyphLoader_Rewind( loader );

      builder->hints_globals = ((void *)0);
      builder->hints_funcs = ((void *)0);

      if ( hinting && size )
      {
        CFF_Internal internal = (CFF_Internal)size->root.internal;


        builder->hints_globals = (void *)internal->topfont;
        builder->hints_funcs = glyph->root.internal->glyph_hints;
      }
    }

    builder->pos_x = 0;
    builder->pos_y = 0;

    builder->left_bearing.x = 0;
    builder->left_bearing.y = 0;
    builder->advance.x = 0;
    builder->advance.y = 0;
  }
# 312 "../../../libs/freetype/src/cff/cffgload.c"
  static void
  cff_builder_done( CFF_Builder* builder )
  {
    CFF_GlyphSlot glyph = builder->glyph;


    if ( glyph )
      glyph->root.outline = *builder->base;
  }
# 340 "../../../libs/freetype/src/cff/cffgload.c"
  static FT_Int
  cff_compute_bias( FT_Int in_charstring_type,
                    FT_UInt num_subrs )
  {
    FT_Int result;


    if ( in_charstring_type == 1 )
      result = 0;
    else if ( num_subrs < 1240 )
      result = 107;
    else if ( num_subrs < 33900U )
      result = 1131;
    else
      result = 32768U;

    return result;
  }
# 382 "../../../libs/freetype/src/cff/cffgload.c"
  static void
  cff_decoder_init( CFF_Decoder* decoder,
                    TT_Face face,
                    CFF_Size size,
                    CFF_GlyphSlot slot,
                    FT_Bool hinting,
                    FT_Render_Mode hint_mode )
  {
    CFF_Font cff = (CFF_Font)face->extra.data;



    memset( decoder, 0, (FT_Offset)(sizeof ( *decoder )) );


    cff_builder_init( &decoder->builder, face, size, slot, hinting );


    decoder->cff = cff;
    decoder->num_globals = cff->global_subrs_index.count;
    decoder->globals = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );

    decoder->hint_mode = hint_mode;
  }




  static FT_Error
  cff_decoder_prepare( CFF_Decoder* decoder,
                       CFF_Size size,
                       FT_UInt glyph_index )
  {
    CFF_Builder *builder = &decoder->builder;
    CFF_Font cff = (CFF_Font)builder->face->extra.data;
    CFF_SubFont sub = &cff->top_font;
    FT_Error error = FT_Err_Ok;



    if ( cff->num_subfonts )
    {
      FT_Byte fd_index = cff_fd_select_get( &cff->fd_select, glyph_index );


      if ( fd_index >= cff->num_subfonts )
      {
        do { } while ( 0 );
        error = CF2_Err_Invalid_File_Format;
        goto Exit;
      }

      do { } while ( 0 );

      sub = cff->subfonts[fd_index];

      if ( builder->hints_funcs && size )
      {
        CFF_Internal internal = (CFF_Internal)size->root.internal;



        builder->hints_globals = (void *)internal->subfonts[fd_index];
      }
    }

    decoder->num_locals = sub->local_subrs_index.count;
    decoder->locals = sub->local_subrs;
    decoder->locals_bias = cff_compute_bias(
                               decoder->cff->top_font.font_dict.charstring_type,
                               decoder->num_locals );

    decoder->glyph_width = sub->private_dict.default_width;
    decoder->nominal_width = sub->private_dict.nominal_width;

    decoder->current_subfont = sub;

  Exit:
    return error;
  }



  static FT_Error
  cff_check_points( CFF_Builder* builder,
                    FT_Int count )
  {
    return ( ( ( (count) == 0 || ( (FT_UInt)(builder->loader)->base.outline.n_points + (FT_UInt)(builder->loader)->current.outline.n_points + (FT_UInt)(count) ) <= (builder->loader)->max_points ) && ( (0) == 0 || ( (FT_UInt)(builder->loader)->base.outline.n_contours + (FT_UInt)(builder->loader)->current.outline.n_contours + (FT_UInt)(0) ) <= (builder->loader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (builder->loader), (FT_UInt)(count), (FT_UInt)(0) ) );
  }



  static void
  cff_builder_add_point( CFF_Builder* builder,
                         FT_Pos x,
                         FT_Pos y,
                         FT_Byte flag )
  {
    FT_Outline* outline = builder->current;


    if ( builder->load_points )
    {
      FT_Vector* point = outline->points + outline->n_points;
      FT_Byte* control = (FT_Byte*)outline->tags + outline->n_points;
# 502 "../../../libs/freetype/src/cff/cffgload.c"
      {

        point->x = x >> 10;
        point->y = y >> 10;
      }
      *control = (FT_Byte)( flag ? 1 : 2 );
    }

    outline->n_points++;
  }



  static FT_Error
  cff_builder_add_point1( CFF_Builder* builder,
                          FT_Pos x,
                          FT_Pos y )
  {
    FT_Error error;


    error = cff_check_points( builder, 1 );
    if ( !error )
      cff_builder_add_point( builder, x, y, 1 );

    return error;
  }



  static FT_Error
  cff_builder_add_contour( CFF_Builder* builder )
  {
    FT_Outline* outline = builder->current;
    FT_Error error;


    if ( !builder->load_points )
    {
      outline->n_contours++;
      return FT_Err_Ok;
    }

    error = ( ( ( (0) == 0 || ( (FT_UInt)(builder->loader)->base.outline.n_points + (FT_UInt)(builder->loader)->current.outline.n_points + (FT_UInt)(0) ) <= (builder->loader)->max_points ) && ( (1) == 0 || ( (FT_UInt)(builder->loader)->base.outline.n_contours + (FT_UInt)(builder->loader)->current.outline.n_contours + (FT_UInt)(1) ) <= (builder->loader)->max_contours ) ) ? 0 : FT_GlyphLoader_CheckPoints( (builder->loader), (FT_UInt)(0), (FT_UInt)(1) ) );
    if ( !error )
    {
      if ( outline->n_contours > 0 )
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );

      outline->n_contours++;
    }

    return error;
  }



  static FT_Error
  cff_builder_start_point( CFF_Builder* builder,
                           FT_Pos x,
                           FT_Pos y )
  {
    FT_Error error = FT_Err_Ok;



    if ( !builder->path_begun )
    {
      builder->path_begun = 1;
      error = cff_builder_add_contour( builder );
      if ( !error )
        error = cff_builder_add_point1( builder, x, y );
    }

    return error;
  }



  static void
  cff_builder_close_contour( CFF_Builder* builder )
  {
    FT_Outline* outline = builder->current;
    FT_Int first;


    if ( !outline )
      return;

    first = outline->n_contours <= 1
            ? 0 : outline->contours[outline->n_contours - 2] + 1;



    if ( outline->n_points > 1 )
    {
      FT_Vector* p1 = outline->points + first;
      FT_Vector* p2 = outline->points + outline->n_points - 1;
      FT_Byte* control = (FT_Byte*)outline->tags + outline->n_points - 1;




      if ( p1->x == p2->x && p1->y == p2->y )
        if ( *control == 1 )
          outline->n_points--;
    }

    if ( outline->n_contours > 0 )
    {


      if ( first == outline->n_points - 1 )
      {
        outline->n_contours--;
        outline->n_points--;
      }
      else
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );
    }
  }


  static FT_Int
  cff_lookup_glyph_by_stdcharcode( CFF_Font cff,
                                   FT_Int charcode )
  {
    FT_UInt n;
    FT_UShort glyph_sid;



    if ( !cff->charset.sids )
      return -1;


    if ( charcode < 0 || charcode > 255 )
      return -1;


    glyph_sid = cff_get_standard_encoding( (FT_UInt)charcode );

    for ( n = 0; n < cff->num_glyphs; n++ )
    {
      if ( cff->charset.sids[n] == glyph_sid )
        return (FT_Int)n;
    }

    return -1;
  }


  static FT_Error
  cff_get_glyph_data( TT_Face face,
                      FT_UInt glyph_index,
                      FT_Byte** pointer,
                      FT_ULong* length )
  {



    if ( face->root.internal->incremental_interface )
    {
      FT_Data data;
      FT_Error error =
                  face->root.internal->incremental_interface->funcs->get_glyph_data(
                    face->root.internal->incremental_interface->object,
                    glyph_index, &data );


      *pointer = (FT_Byte*)data.pointer;
      *length = (FT_ULong)data.length;

      return error;
    }
    else


    {
      CFF_Font cff = (CFF_Font)(face->extra.data);


      return cff_index_access_element( &cff->charstrings_index, glyph_index,
                                       pointer, length );
    }
  }


  static void
  cff_free_glyph_data( TT_Face face,
                       FT_Byte** pointer,
                       FT_ULong length )
  {







    if ( face->root.internal->incremental_interface )
    {
      FT_Data data;


      data.pointer = *pointer;
      data.length = (FT_Int)length;

      face->root.internal->incremental_interface->funcs->free_glyph_data(
        face->root.internal->incremental_interface->object, &data );
    }
    else


    {
      CFF_Font cff = (CFF_Font)(face->extra.data);


      cff_index_forget_element( &cff->charstrings_index, pointer );
    }
  }
# 2607 "../../../libs/freetype/src/cff/cffgload.c"
  static FT_Error
  cff_slot_load( CFF_GlyphSlot glyph,
                 CFF_Size size,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags )
  {
    FT_Error error;
    CFF_Decoder decoder;
    TT_Face face = (TT_Face)glyph->root.face;
    FT_Bool hinting, scaled, force_scaling;
    CFF_Font cff = (CFF_Font)face->extra.data;

    FT_Matrix font_matrix;
    FT_Vector font_offset;


    force_scaling = 0;




    if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
         cff->charset.cids )
    {

      if ( glyph_index != 0 )
      {
        glyph_index = cff_charset_cid_to_gindex( &cff->charset,
                                                 glyph_index );
        if ( glyph_index == 0 )
          return CF2_Err_Invalid_Argument;
      }
    }
    else if ( glyph_index >= cff->num_glyphs )
      return CF2_Err_Invalid_Argument;

    if ( load_flags & ( 1L << 10 ) )
      load_flags |= ( 1L << 0 ) | ( 1L << 1 );

    glyph->x_scale = 0x10000L;
    glyph->y_scale = 0x10000L;
    if ( size )
    {
      glyph->x_scale = size->root.metrics.x_scale;
      glyph->y_scale = size->root.metrics.y_scale;
    }







    if ( size )
    {
      CFF_Face cff_face = (CFF_Face)size->root.face;
      SFNT_Service sfnt = (SFNT_Service)cff_face->sfnt;
      FT_Stream stream = cff_face->root.stream;


      if ( size->strike_index != 0xFFFFFFFFUL &&
           sfnt->load_eblc &&
           ( load_flags & ( 1L << 3 ) ) == 0 )
      {
        TT_SBit_MetricsRec metrics;


        error = sfnt->load_sbit_image( face,
                                       size->strike_index,
                                       glyph_index,
                                       (FT_UInt)load_flags,
                                       stream,
                                       &glyph->root.bitmap,
                                       &metrics );

        if ( !error )
        {
          FT_Bool has_vertical_info;
          FT_UShort advance;
          FT_Short dummy;


          glyph->root.outline.n_points = 0;
          glyph->root.outline.n_contours = 0;

          glyph->root.metrics.width = (FT_Pos)metrics.width << 6;
          glyph->root.metrics.height = (FT_Pos)metrics.height << 6;

          glyph->root.metrics.horiBearingX = (FT_Pos)metrics.horiBearingX << 6;
          glyph->root.metrics.horiBearingY = (FT_Pos)metrics.horiBearingY << 6;
          glyph->root.metrics.horiAdvance = (FT_Pos)metrics.horiAdvance << 6;

          glyph->root.metrics.vertBearingX = (FT_Pos)metrics.vertBearingX << 6;
          glyph->root.metrics.vertBearingY = (FT_Pos)metrics.vertBearingY << 6;
          glyph->root.metrics.vertAdvance = (FT_Pos)metrics.vertAdvance << 6;

          glyph->root.format = FT_GLYPH_FORMAT_BITMAP;

          if ( load_flags & ( 1L << 4 ) )
          {
            glyph->root.bitmap_left = metrics.vertBearingX;
            glyph->root.bitmap_top = metrics.vertBearingY;
          }
          else
          {
            glyph->root.bitmap_left = metrics.horiBearingX;
            glyph->root.bitmap_top = metrics.horiBearingY;
          }



          (void)( (SFNT_Service)face->sfnt )->get_metrics( face, 0,
                                                           glyph_index,
                                                           &dummy,
                                                           &advance );
          glyph->root.linearHoriAdvance = advance;

          has_vertical_info = ( (FT_Bool)( face->vertical_info && face->vertical.number_Of_VMetrics > 0 ) )

                                                                       ;


          if ( has_vertical_info )
          {
            (void)( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                             glyph_index,
                                                             &dummy,
                                                             &advance );
            glyph->root.linearVertAdvance = advance;
          }
          else
          {

            if ( face->os2.version != 0xFFFFU )
              glyph->root.linearVertAdvance = (FT_Pos)
                ( face->os2.sTypoAscender - face->os2.sTypoDescender );
            else
              glyph->root.linearVertAdvance = (FT_Pos)
                ( face->horizontal.Ascender - face->horizontal.Descender );
          }

          return error;
        }
      }
    }




    if ( load_flags & ( 1L << 14 ) )
      return CF2_Err_Invalid_Argument;





    if ( cff->num_subfonts )
    {
      FT_Long top_upm, sub_upm;
      FT_Byte fd_index = cff_fd_select_get( &cff->fd_select,
                                             glyph_index );


      if ( fd_index >= cff->num_subfonts )
        fd_index = (FT_Byte)( cff->num_subfonts - 1 );

      top_upm = (FT_Long)cff->top_font.font_dict.units_per_em;
      sub_upm = (FT_Long)cff->subfonts[fd_index]->font_dict.units_per_em;


      font_matrix = cff->subfonts[fd_index]->font_dict.font_matrix;
      font_offset = cff->subfonts[fd_index]->font_dict.font_offset;

      if ( top_upm != sub_upm )
      {
        glyph->x_scale = FT_MulDiv( glyph->x_scale, top_upm, sub_upm );
        glyph->y_scale = FT_MulDiv( glyph->y_scale, top_upm, sub_upm );

        force_scaling = 1;
      }
    }
    else
    {
      font_matrix = cff->top_font.font_dict.font_matrix;
      font_offset = cff->top_font.font_dict.font_offset;
    }

    glyph->root.outline.n_points = 0;
    glyph->root.outline.n_contours = 0;



    hinting = ( (FT_Bool)( ( load_flags & ( 1L << 1 ) ) == 0 ) );
    scaled = ( (FT_Bool)( ( load_flags & ( 1L << 0 ) ) == 0 ) );

    glyph->hint = hinting;
    glyph->scaled = scaled;
    glyph->root.format = FT_GLYPH_FORMAT_OUTLINE;

    {





      FT_Byte* charstring;
      FT_ULong charstring_len;


      cff_decoder_init( &decoder, face, size, glyph, hinting,
                        ( (FT_Render_Mode)( ( (load_flags) >> 16 ) & 15 ) ) );

      if ( load_flags & ( 1L << 8 ) )
        decoder.width_only = 1;

      decoder.builder.no_recurse =
        (FT_Bool)( load_flags & ( 1L << 10 ) );


      error = cff_get_glyph_data( face, glyph_index,
                                  &charstring, &charstring_len );
      if ( error )
        goto Glyph_Build_Finished;

      error = cff_decoder_prepare( &decoder, size, glyph_index );
      if ( error )
        goto Glyph_Build_Finished;
# 2843 "../../../libs/freetype/src/cff/cffgload.c"
      {
        error = cf2_decoder_parse_charstrings( &decoder,
                                               charstring,
                                               charstring_len );



        if ( ( ( (error) & 0xFF ) == ( (CF2_Err_Glyph_Too_Big) & 0xFF ) ) )
        {



          hinting = 0;
          force_scaling = 1;
          glyph->hint = hinting;

          error = cf2_decoder_parse_charstrings( &decoder,
                                                 charstring,
                                                 charstring_len );
        }
      }

      cff_free_glyph_data( face, &charstring, charstring_len );

      if ( error )
        goto Glyph_Build_Finished;




      if ( face->root.internal->incremental_interface )
      {
        glyph->root.control_data = ((void *)0);
        glyph->root.control_len = 0;
      }
      else





      {
        CFF_Index csindex = &cff->charstrings_index;


        if ( csindex->offsets )
        {
          glyph->root.control_data = csindex->bytes +
                                     csindex->offsets[glyph_index] - 1;
          glyph->root.control_len = (FT_Long)charstring_len;
        }
      }

  Glyph_Build_Finished:

      if ( !error )
        cff_builder_done( &decoder.builder );

    }




    if ( !error &&
         face->root.internal->incremental_interface &&
         face->root.internal->incremental_interface->funcs->get_glyph_metrics )
    {
      FT_Incremental_MetricsRec metrics;


      metrics.bearing_x = decoder.builder.left_bearing.x;
      metrics.bearing_y = 0;
      metrics.advance = decoder.builder.advance.x;
      metrics.advance_v = decoder.builder.advance.y;

      error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                face->root.internal->incremental_interface->object,
                glyph_index, 0, &metrics );

      decoder.builder.left_bearing.x = metrics.bearing_x;
      decoder.builder.advance.x = metrics.advance;
      decoder.builder.advance.y = metrics.advance_v;
    }



    if ( !error )
    {






      if ( load_flags & ( 1L << 10 ) )
      {
        FT_Slot_Internal internal = glyph->root.internal;


        glyph->root.metrics.horiBearingX = decoder.builder.left_bearing.x;
        glyph->root.metrics.horiAdvance = decoder.glyph_width;
        internal->glyph_matrix = font_matrix;
        internal->glyph_delta = font_offset;
        internal->glyph_transformed = 1;
      }
      else
      {
        FT_BBox cbox;
        FT_Glyph_Metrics* metrics = &glyph->root.metrics;
        FT_Bool has_vertical_info;


        if ( face->horizontal.number_Of_HMetrics )
        {
          FT_Short horiBearingX = 0;
          FT_UShort horiAdvance = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 0,
                                                     glyph_index,
                                                     &horiBearingX,
                                                     &horiAdvance );
          metrics->horiAdvance = horiAdvance;
          metrics->horiBearingX = horiBearingX;
          glyph->root.linearHoriAdvance = horiAdvance;
        }
        else
        {

          metrics->horiAdvance = decoder.glyph_width;
          glyph->root.linearHoriAdvance = decoder.glyph_width;
        }

        glyph->root.internal->glyph_transformed = 0;

        has_vertical_info = ( (FT_Bool)( face->vertical_info && face->vertical.number_Of_VMetrics > 0 ) )
                                                                            ;


        if ( has_vertical_info )
        {
          FT_Short vertBearingY = 0;
          FT_UShort vertAdvance = 0;


          ( (SFNT_Service)face->sfnt )->get_metrics( face, 1,
                                                     glyph_index,
                                                     &vertBearingY,
                                                     &vertAdvance );
          metrics->vertBearingY = vertBearingY;
          metrics->vertAdvance = vertAdvance;
        }
        else
        {

          if ( face->os2.version != 0xFFFFU )
            metrics->vertAdvance = (FT_Pos)( face->os2.sTypoAscender -
                                             face->os2.sTypoDescender );
          else
            metrics->vertAdvance = (FT_Pos)( face->horizontal.Ascender -
                                             face->horizontal.Descender );
        }

        glyph->root.linearVertAdvance = metrics->vertAdvance;

        glyph->root.format = FT_GLYPH_FORMAT_OUTLINE;

        glyph->root.outline.flags = 0;
        if ( size && size->root.metrics.y_ppem < 24 )
          glyph->root.outline.flags |= 0x100;

        glyph->root.outline.flags |= 0x4;


        if ( font_matrix.xx != 0x10000L || font_matrix.yy != 0x10000L ||
             font_matrix.xy != 0 || font_matrix.yx != 0 )
        {
          FT_Outline_Transform( &glyph->root.outline, &font_matrix );

          metrics->horiAdvance = FT_MulFix_arm( (FT_Int32)(metrics->horiAdvance), (FT_Int32)(font_matrix.xx) )
                                                            ;
          metrics->vertAdvance = FT_MulFix_arm( (FT_Int32)(metrics->vertAdvance), (FT_Int32)(font_matrix.yy) )
                                                            ;
        }

        if ( font_offset.x || font_offset.y )
        {
          FT_Outline_Translate( &glyph->root.outline,
                                font_offset.x,
                                font_offset.y );

          metrics->horiAdvance += font_offset.x;
          metrics->vertAdvance += font_offset.y;
        }

        if ( ( load_flags & ( 1L << 0 ) ) == 0 || force_scaling )
        {

          FT_Int n;
          FT_Outline* cur = &glyph->root.outline;
          FT_Vector* vec = cur->points;
          FT_Fixed x_scale = glyph->x_scale;
          FT_Fixed y_scale = glyph->y_scale;



          if ( !hinting || !decoder.builder.hints_funcs )
            for ( n = cur->n_points; n > 0; n--, vec++ )
            {
              vec->x = FT_MulFix_arm( (FT_Int32)(vec->x), (FT_Int32)(x_scale) );
              vec->y = FT_MulFix_arm( (FT_Int32)(vec->y), (FT_Int32)(y_scale) );
            }


          metrics->horiAdvance = FT_MulFix_arm( (FT_Int32)(metrics->horiAdvance), (FT_Int32)(x_scale) );
          metrics->vertAdvance = FT_MulFix_arm( (FT_Int32)(metrics->vertAdvance), (FT_Int32)(y_scale) );
        }


        FT_Outline_Get_CBox( &glyph->root.outline, &cbox );

        metrics->width = cbox.xMax - cbox.xMin;
        metrics->height = cbox.yMax - cbox.yMin;

        metrics->horiBearingX = cbox.xMin;
        metrics->horiBearingY = cbox.yMax;

        if ( has_vertical_info )
          metrics->vertBearingX = metrics->horiBearingX -
                                    metrics->horiAdvance / 2;
        else
        {
          if ( load_flags & ( 1L << 4 ) )
            ft_synthesize_vertical_metrics( metrics,
                                            metrics->vertAdvance );
        }
      }
    }

    return error;
  }
# 29 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cffcmap.c" 1
# 35 "../../../libs/freetype/src/cff/cffcmap.c"
  static FT_Error
  cff_cmap_encoding_init( CFF_CMapStd cmap,
                          FT_Pointer pointer )
  {
    TT_Face face = (TT_Face)((FT_CMap)( cmap ))->charmap.face;
    CFF_Font cff = (CFF_Font)face->extra.data;
    CFF_Encoding encoding = &cff->encoding;

    ( (pointer) = (pointer) );


    cmap->gids = encoding->codes;

    return 0;
  }


  static void
  cff_cmap_encoding_done( CFF_CMapStd cmap )
  {
    cmap->gids = ((void *)0);
  }


  static FT_UInt
  cff_cmap_encoding_char_index( CFF_CMapStd cmap,
                                FT_UInt32 char_code )
  {
    FT_UInt result = 0;


    if ( char_code < 256 )
      result = cmap->gids[char_code];

    return result;
  }


  static FT_UInt32
  cff_cmap_encoding_char_next( CFF_CMapStd cmap,
                               FT_UInt32 *pchar_code )
  {
    FT_UInt result = 0;
    FT_UInt32 char_code = *pchar_code;


    *pchar_code = 0;

    if ( char_code < 255 )
    {
      FT_UInt code = (FT_UInt)(char_code + 1);


      for (;;)
      {
        if ( code >= 256 )
          break;

        result = cmap->gids[code];
        if ( result != 0 )
        {
          *pchar_code = code;
          break;
        }

        code++;
      }
    }
    return result;
  }


  const FT_CMap_ClassRec cff_cmap_encoding_class_rec = { sizeof ( CFF_CMapStdRec ), (FT_CMap_InitFunc) cff_cmap_encoding_init, (FT_CMap_DoneFunc) cff_cmap_encoding_done, (FT_CMap_CharIndexFunc)cff_cmap_encoding_char_index, (FT_CMap_CharNextFunc) cff_cmap_encoding_char_next, ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0) };
# 127 "../../../libs/freetype/src/cff/cffcmap.c"
  static const char*
  cff_sid_to_glyph_name( TT_Face face,
                         FT_UInt idx )
  {
    CFF_Font cff = (CFF_Font)face->extra.data;
    CFF_Charset charset = &cff->charset;
    FT_UInt sid = charset->sids[idx];


    return cff_index_get_sid_string( cff, sid );
  }


  static FT_Error
  cff_cmap_unicode_init( PS_Unicodes unicodes,
                         FT_Pointer pointer )
  {
    TT_Face face = (TT_Face)((FT_CMap)( unicodes ))->charmap.face;
    FT_Memory memory = ((FT_Face)(face))->memory;
    CFF_Font cff = (CFF_Font)face->extra.data;
    CFF_Charset charset = &cff->charset;
    FT_Service_PsCMaps psnames = (FT_Service_PsCMaps)cff->psnames;

    ( (pointer) = (pointer) );




    if ( !charset->sids )
      return CF2_Err_No_Unicode_Glyph_Name;

    return psnames->unicodes_init( memory,
                                   unicodes,
                                   cff->num_glyphs,
                                   (PS_GetGlyphNameFunc)&cff_sid_to_glyph_name,
                                   (PS_FreeGlyphNameFunc)((void *)0),
                                   (FT_Pointer)face );
  }


  static void
  cff_cmap_unicode_done( PS_Unicodes unicodes )
  {
    FT_Face face = ((FT_CMap)( unicodes ))->charmap.face;
    FT_Memory memory = ((FT_Face)(face))->memory;


    do { ft_mem_free( memory, (unicodes->maps) ); (unicodes->maps) = ((void *)0); } while ( 0 );
    unicodes->num_maps = 0;
  }


  static FT_UInt
  cff_cmap_unicode_char_index( PS_Unicodes unicodes,
                               FT_UInt32 char_code )
  {
    TT_Face face = (TT_Face)((FT_CMap)( unicodes ))->charmap.face;
    CFF_Font cff = (CFF_Font)face->extra.data;
    FT_Service_PsCMaps psnames = (FT_Service_PsCMaps)cff->psnames;


    return psnames->unicodes_char_index( unicodes, char_code );
  }


  static FT_UInt32
  cff_cmap_unicode_char_next( PS_Unicodes unicodes,
                              FT_UInt32 *pchar_code )
  {
    TT_Face face = (TT_Face)((FT_CMap)( unicodes ))->charmap.face;
    CFF_Font cff = (CFF_Font)face->extra.data;
    FT_Service_PsCMaps psnames = (FT_Service_PsCMaps)cff->psnames;


    return psnames->unicodes_char_next( unicodes, pchar_code );
  }


  const FT_CMap_ClassRec cff_cmap_unicode_class_rec = { sizeof ( PS_UnicodesRec ), (FT_CMap_InitFunc) cff_cmap_unicode_init, (FT_CMap_DoneFunc) cff_cmap_unicode_done, (FT_CMap_CharIndexFunc)cff_cmap_unicode_char_index, (FT_CMap_CharNextFunc) cff_cmap_unicode_char_next, ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0) };
# 30 "../../../libs/freetype/src/cff/cff.c" 2

# 1 "../../../libs/freetype/src/cff/cf2arrst.c" 1
# 55 "../../../libs/freetype/src/cff/cf2arrst.c"
  static void
  cf2_arrstack_init( CF2_ArrStack arrstack,
                     FT_Memory memory,
                     FT_Error* error,
                     size_t sizeItem )
  {
    do { } while ( 0 );


    arrstack->memory = memory;
    arrstack->error = error;
    arrstack->sizeItem = sizeItem;
    arrstack->allocated = 0;
    arrstack->chunk = 10;
    arrstack->count = 0;
    arrstack->totalSize = 0;
    arrstack->ptr = ((void *)0);
  }


  static void
  cf2_arrstack_finalize( CF2_ArrStack arrstack )
  {
    FT_Memory memory = arrstack->memory;


    do { } while ( 0 );

    arrstack->allocated = 0;
    arrstack->count = 0;
    arrstack->totalSize = 0;


    do { ft_mem_free( memory, (arrstack->ptr) ); (arrstack->ptr) = ((void *)0); } while ( 0 );
  }




  static FT_Bool
  cf2_arrstack_setNumElements( CF2_ArrStack arrstack,
                               size_t numElements )
  {
    do { } while ( 0 );

    {
      FT_Error error = FT_Err_Ok;
      FT_Memory memory = arrstack->memory;

      size_t newSize = numElements * arrstack->sizeItem;


      if ( numElements > 2147483647L / arrstack->sizeItem )
        goto exit;


      do { } while ( 0 );

      if ( !( ((arrstack->ptr) = (ft_mem_realloc( memory, 1, (FT_Long)(arrstack->totalSize), (FT_Long)(newSize), (arrstack->ptr), &error ))), error != 0 ) )
      {
        arrstack->allocated = numElements;
        arrstack->totalSize = newSize;

        if ( arrstack->count > numElements )
        {

          cf2_setError( arrstack->error, CF2_Err_Stack_Overflow );
          arrstack->count = numElements;
          return 0;
        }

        return 1;
      }
    }

  exit:

    cf2_setError( arrstack->error, CF2_Err_Out_Of_Memory );

    return 0;
  }



  static void
  cf2_arrstack_setCount( CF2_ArrStack arrstack,
                         size_t numElements )
  {
    do { } while ( 0 );

    if ( numElements > arrstack->allocated )
    {

      if ( !cf2_arrstack_setNumElements( arrstack, numElements ) )
        return;
    }

    arrstack->count = numElements;
  }



  static void
  cf2_arrstack_clear( CF2_ArrStack arrstack )
  {
    do { } while ( 0 );

    arrstack->count = 0;
  }



  static size_t
  cf2_arrstack_size( const CF2_ArrStack arrstack )
  {
    do { } while ( 0 );

    return arrstack->count;
  }


  static void*
  cf2_arrstack_getBuffer( const CF2_ArrStack arrstack )
  {
    do { } while ( 0 );

    return arrstack->ptr;
  }



  static void*
  cf2_arrstack_getPointer( const CF2_ArrStack arrstack,
                           size_t idx )
  {
    void* newPtr;


    do { } while ( 0 );

    if ( idx >= arrstack->count )
    {

      cf2_setError( arrstack->error, CF2_Err_Stack_Overflow );
      idx = 0;
    }

    newPtr = (FT_Byte*)arrstack->ptr + idx * arrstack->sizeItem;

    return newPtr;
  }





  static void
  cf2_arrstack_push( CF2_ArrStack arrstack,
                     const void* ptr )
  {
    do { } while ( 0 );

    if ( arrstack->count == arrstack->allocated )
    {

      if ( !cf2_arrstack_setNumElements(
             arrstack, arrstack->allocated + arrstack->chunk ) )
      {

        return;
      }
    }

    do { } while ( 0 );

    {
      size_t offset = arrstack->count * arrstack->sizeItem;
      void* newPtr = (FT_Byte*)arrstack->ptr + offset;


      memcpy( newPtr, ptr, (FT_Offset)(arrstack->sizeItem) );
      arrstack->count += 1;
    }
  }
# 32 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2blues.c" 1
# 42 "../../../libs/freetype/src/cff/cf2blues.c"
# 1 "../../../libs/freetype/src/cff/cf2blues.h" 1
# 75 "../../../libs/freetype/src/cff/cf2blues.h"

# 85 "../../../libs/freetype/src/cff/cf2blues.h"
  enum
  {
    CF2_GhostBottom = 0x1,
    CF2_GhostTop = 0x2,
    CF2_PairBottom = 0x4,
    CF2_PairTop = 0x8,
    CF2_Locked = 0x10,

    CF2_Synthetic = 0x20
  };
# 103 "../../../libs/freetype/src/cff/cf2blues.h"
  enum
  {
    CF2_ICF_Top = ( (CF2_F16Dot16)( (FT_UInt32)(880) << 16 ) ),
    CF2_ICF_Bottom = ( (CF2_F16Dot16)( (FT_UInt32)(-120) << 16 ) )
  };
# 118 "../../../libs/freetype/src/cff/cf2blues.h"
  struct CF2_HintRec_
  {
    FT_UFast flags;
    size_t index;

    CF2_F16Dot16 csCoord;
    CF2_F16Dot16 dsCoord;
    CF2_F16Dot16 scale;
  };


  typedef struct CF2_BlueRec_
  {
    CF2_F16Dot16 csBottomEdge;
    CF2_F16Dot16 csTopEdge;
    CF2_F16Dot16 csFlatEdge;
    CF2_F16Dot16 dsFlatEdge;

    FT_Bool bottomZone;

  } CF2_BlueRec;



  enum
  {
    CF2_MAX_BLUES = 7,
    CF2_MAX_OTHERBLUES = 5
  };


  typedef struct CF2_BluesRec_
  {
    CF2_F16Dot16 scale;
    FT_UFast count;
    FT_Bool suppressOvershoot;
    FT_Bool doEmBoxHints;

    CF2_F16Dot16 blueScale;
    CF2_F16Dot16 blueShift;
    CF2_F16Dot16 blueFuzz;

    CF2_F16Dot16 boost;

    CF2_HintRec emBoxTopEdge;
    CF2_HintRec emBoxBottomEdge;

    CF2_BlueRec zone[CF2_MAX_BLUES + CF2_MAX_OTHERBLUES];

  } CF2_BluesRec, *CF2_Blues;


  static void
  cf2_blues_init( CF2_Blues blues,
                  CF2_Font font );
  static FT_Bool
  cf2_blues_capture( const CF2_Blues blues,
                     CF2_Hint bottomHintEdge,
                     CF2_Hint topHintEdge );



# 43 "../../../libs/freetype/src/cff/cf2blues.c" 2
# 1 "../../../libs/freetype/src/cff/cf2hints.h" 1
# 43 "../../../libs/freetype/src/cff/cf2hints.h"



  enum
  {
    CF2_MAX_HINTS = 96
  };
# 71 "../../../libs/freetype/src/cff/cf2hints.h"
  typedef struct CF2_HintMaskRec_
  {
    FT_Error* error;

    FT_Bool isValid;
    FT_Bool isNew;

    size_t bitCount;
    size_t byteCount;

    FT_Byte mask[( CF2_MAX_HINTS + 7 ) / 8];

  } CF2_HintMaskRec, *CF2_HintMask;


  typedef struct CF2_StemHintRec_
  {
    FT_Bool used;

    CF2_F16Dot16 min;
    CF2_F16Dot16 max;

    CF2_F16Dot16 minDS;
    CF2_F16Dot16 maxDS;

  } CF2_StemHintRec, *CF2_StemHint;
# 121 "../../../libs/freetype/src/cff/cf2hints.h"
  enum
  {
    CF2_MAX_HINT_EDGES = CF2_MAX_HINTS * 2
  };


  typedef struct CF2_HintMapRec_
  {
    CF2_Font font;


    struct CF2_HintMapRec_* initialHintMap;


    CF2_ArrStack hintMoves;

    FT_Bool isValid;
    FT_Bool hinted;

    CF2_F16Dot16 scale;
    FT_UFast count;


    FT_UFast lastIndex;

    CF2_HintRec edge[CF2_MAX_HINT_EDGES];

  } CF2_HintMapRec, *CF2_HintMap;


  static FT_Bool
  cf2_hint_isValid( const CF2_Hint hint );
  static FT_Bool
  cf2_hint_isTop( const CF2_Hint hint );
  static FT_Bool
  cf2_hint_isBottom( const CF2_Hint hint );
  static void
  cf2_hint_lock( CF2_Hint hint );


  static void
  cf2_hintmap_init( CF2_HintMap hintmap,
                    CF2_Font font,
                    CF2_HintMap initialMap,
                    CF2_ArrStack hintMoves,
                    CF2_F16Dot16 scale );
  static void
  cf2_hintmap_build( CF2_HintMap hintmap,
                     CF2_ArrStack hStemHintArray,
                     CF2_ArrStack vStemHintArray,
                     CF2_HintMask hintMask,
                     CF2_F16Dot16 hintOrigin,
                     FT_Bool initialMap );
# 182 "../../../libs/freetype/src/cff/cf2hints.h"
  typedef struct CF2_GlyphPathRec_
  {


    CF2_Font font;
    CF2_OutlineCallbacks callbacks;


    CF2_HintMapRec hintMap;
    CF2_HintMapRec firstHintMap;
    CF2_HintMapRec initialHintMap;

    CF2_ArrStackRec hintMoves;

    CF2_F16Dot16 scaleX;
    CF2_F16Dot16 scaleC;
    CF2_F16Dot16 scaleY;

    FT_Vector fractionalTranslation;





    FT_Bool pathIsOpen;
    FT_Bool pathIsClosing;
    FT_Bool darken;
    FT_Bool moveIsPending;


    CF2_ArrStack hStemHintArray;
    CF2_ArrStack vStemHintArray;
    CF2_HintMask hintMask;
    CF2_F16Dot16 hintOriginY;
    const CF2_BluesRec* blues;

    CF2_F16Dot16 xOffset;
    CF2_F16Dot16 yOffset;


    CF2_F16Dot16 miterLimit;

    CF2_F16Dot16 snapThreshold;

    FT_Vector offsetStart0;
    FT_Vector offsetStart1;


    FT_Vector currentCS;

    FT_Vector currentDS;

    FT_Vector start;


    FT_Bool elemIsQueued;
    FT_Fast prevElemOp;

    FT_Vector prevElemP0;
    FT_Vector prevElemP1;
    FT_Vector prevElemP2;
    FT_Vector prevElemP3;

  } CF2_GlyphPathRec, *CF2_GlyphPath;


  static void
  cf2_glyphpath_init( CF2_GlyphPath glyphpath,
                      CF2_Font font,
                      CF2_OutlineCallbacks callbacks,
                      CF2_F16Dot16 scaleY,

                      CF2_ArrStack hStemHintArray,
                      CF2_ArrStack vStemHintArray,
                      CF2_HintMask hintMask,
                      CF2_F16Dot16 hintOrigin,
                      const CF2_Blues blues,
                      const FT_Vector* fractionalTranslation );
  static void
  cf2_glyphpath_finalize( CF2_GlyphPath glyphpath );

  static void
  cf2_glyphpath_moveTo( CF2_GlyphPath glyphpath,
                        CF2_F16Dot16 x,
                        CF2_F16Dot16 y );
  static void
  cf2_glyphpath_lineTo( CF2_GlyphPath glyphpath,
                        CF2_F16Dot16 x,
                        CF2_F16Dot16 y );
  static void
  cf2_glyphpath_curveTo( CF2_GlyphPath glyphpath,
                         CF2_F16Dot16 x1,
                         CF2_F16Dot16 y1,
                         CF2_F16Dot16 x2,
                         CF2_F16Dot16 y2,
                         CF2_F16Dot16 x3,
                         CF2_F16Dot16 y3 );
  static void
  cf2_glyphpath_closeOpenPath( CF2_GlyphPath glyphpath );



# 44 "../../../libs/freetype/src/cff/cf2blues.c" 2
# 1 "../../../libs/freetype/src/cff/cf2font.h" 1
# 47 "../../../libs/freetype/src/cff/cf2font.h"

# 60 "../../../libs/freetype/src/cff/cf2font.h"
  struct CF2_FontRec_
  {
    FT_Memory memory;
    FT_Error error;

    CF2_RenderingFlags renderingFlags;





    CF2_Matrix currentTransform;
    CF2_Matrix innerTransform;
    CF2_Matrix outerTransform;
    CF2_F16Dot16 ppem;

    FT_Fast unitsPerEm;

    CF2_F16Dot16 syntheticEmboldeningAmountX;
    CF2_F16Dot16 syntheticEmboldeningAmountY;


    CF2_OutlineRec outline;
    CFF_Decoder* decoder;
    CFF_SubFont lastSubfont;



    FT_Bool hinted;
    FT_Bool darkened;

    FT_Bool stemDarkened;

    FT_Int darkenParams[8];


    CF2_F16Dot16 stdVW;
    CF2_F16Dot16 stdHW;
    CF2_F16Dot16 darkenX;
    CF2_F16Dot16 darkenY;

    FT_Bool reverseWinding;


    CF2_BluesRec blues;
  };


  static FT_Error
  cf2_getGlyphOutline( CF2_Font font,
                       CF2_Buffer charstring,
                       const CF2_Matrix* transform,
                       CF2_F16Dot16* glyphWidth );



# 45 "../../../libs/freetype/src/cff/cf2blues.c" 2
# 65 "../../../libs/freetype/src/cff/cf2blues.c"
  static void
  cf2_blues_init( CF2_Blues blues,
                  CF2_Font font )
  {

    CFF_Decoder* decoder = font->decoder;

    CF2_F16Dot16 zoneHeight;
    CF2_F16Dot16 maxZoneHeight = 0;
    CF2_F16Dot16 csUnitsPerPixel;

    size_t numBlueValues;
    size_t numOtherBlues;
    size_t numFamilyBlues;
    size_t numFamilyOtherBlues;

    FT_Pos* blueValues;
    FT_Pos* otherBlues;
    FT_Pos* familyBlues;
    FT_Pos* familyOtherBlues;

    size_t i;
    CF2_F16Dot16 emBoxBottom, emBoxTop;
# 97 "../../../libs/freetype/src/cff/cf2blues.c"
    memset( blues, 0, (FT_Offset)(sizeof ( *(blues) )) );
    blues->scale = font->innerTransform.d;

    cf2_getBlueMetrics( decoder,
                        &blues->blueScale,
                        &blues->blueShift,
                        &blues->blueFuzz );

    cf2_getBlueValues( decoder, &numBlueValues, &blueValues );
    cf2_getOtherBlues( decoder, &numOtherBlues, &otherBlues );
    cf2_getFamilyBlues( decoder, &numFamilyBlues, &familyBlues );
    cf2_getFamilyOtherBlues( decoder, &numFamilyOtherBlues, &familyOtherBlues );
# 136 "../../../libs/freetype/src/cff/cf2blues.c"
    {
      emBoxBottom = CF2_ICF_Bottom;
      emBoxTop = CF2_ICF_Top;
    }

    if ( cf2_getLanguageGroup( decoder ) == 1 &&
         ( numBlueValues == 0 ||
           ( numBlueValues == 4 &&
             ( (CF2_F16Dot16)( (FT_UInt32)(blueValues[0]) << 16 ) ) < emBoxBottom &&
             ( (CF2_F16Dot16)( (FT_UInt32)(blueValues[1]) << 16 ) ) < emBoxBottom &&
             ( (CF2_F16Dot16)( (FT_UInt32)(blueValues[2]) << 16 ) ) > emBoxTop &&
             ( (CF2_F16Dot16)( (FT_UInt32)(blueValues[3]) << 16 ) ) > emBoxTop ) ) )
    {
# 160 "../../../libs/freetype/src/cff/cf2blues.c"
      blues->emBoxBottomEdge.csCoord = emBoxBottom - 0x0001;
      blues->emBoxBottomEdge.dsCoord = ( (CF2_F16Dot16)( ( (FT_UInt32)(FT_MulFix_arm( (FT_Int32)(blues->emBoxBottomEdge.csCoord), (FT_Int32)(blues->scale) )) + 0x8000U ) & 0xFFFF0000UL ) )


                                                            -
                                       ( (CF2_F16Dot16)( (0.5) * 65536.0 + 0.5 ) );
      blues->emBoxBottomEdge.scale = blues->scale;
      blues->emBoxBottomEdge.flags = CF2_GhostBottom |
                                       CF2_Locked |
                                       CF2_Synthetic;

      blues->emBoxTopEdge.csCoord = emBoxTop + 0x0001 +
                                    2 * font->darkenY;
      blues->emBoxTopEdge.dsCoord = ( (CF2_F16Dot16)( ( (FT_UInt32)(FT_MulFix_arm( (FT_Int32)(blues->emBoxTopEdge.csCoord), (FT_Int32)(blues->scale) )) + 0x8000U ) & 0xFFFF0000UL ) )


                                                         +
                                    ( (CF2_F16Dot16)( (0.5) * 65536.0 + 0.5 ) );
      blues->emBoxTopEdge.scale = blues->scale;
      blues->emBoxTopEdge.flags = CF2_GhostTop |
                                    CF2_Locked |
                                    CF2_Synthetic;

      blues->doEmBoxHints = 1;

      return;
    }



    for ( i = 0; i < numBlueValues; i += 2 )
    {
      blues->zone[blues->count].csBottomEdge =
        ( (CF2_F16Dot16)( (FT_UInt32)(blueValues[i]) << 16 ) );
      blues->zone[blues->count].csTopEdge =
        ( (CF2_F16Dot16)( (FT_UInt32)(blueValues[i + 1]) << 16 ) );

      zoneHeight = blues->zone[blues->count].csTopEdge -
                   blues->zone[blues->count].csBottomEdge;

      if ( zoneHeight < 0 )
      {
        do { } while ( 0 );
        continue;
      }

      if ( zoneHeight > maxZoneHeight )
      {


        maxZoneHeight = zoneHeight;
      }


      if ( i != 0 )
      {
        blues->zone[blues->count].csTopEdge += 2 * font->darkenY;
        blues->zone[blues->count].csBottomEdge += 2 * font->darkenY;
      }


      if ( i == 0 )
      {
        blues->zone[blues->count].bottomZone =
          1;
        blues->zone[blues->count].csFlatEdge =
          blues->zone[blues->count].csTopEdge;
      }
      else
      {
        blues->zone[blues->count].bottomZone =
          0;
        blues->zone[blues->count].csFlatEdge =
          blues->zone[blues->count].csBottomEdge;
      }

      blues->count += 1;
    }

    for ( i = 0; i < numOtherBlues; i += 2 )
    {
      blues->zone[blues->count].csBottomEdge =
        ( (CF2_F16Dot16)( (FT_UInt32)(otherBlues[i]) << 16 ) );
      blues->zone[blues->count].csTopEdge =
        ( (CF2_F16Dot16)( (FT_UInt32)(otherBlues[i + 1]) << 16 ) );

      zoneHeight = blues->zone[blues->count].csTopEdge -
                   blues->zone[blues->count].csBottomEdge;

      if ( zoneHeight < 0 )
      {
        do { } while ( 0 );
        continue;
      }

      if ( zoneHeight > maxZoneHeight )
      {


        maxZoneHeight = zoneHeight;
      }




      blues->zone[blues->count].bottomZone =
        1;
      blues->zone[blues->count].csFlatEdge =
        blues->zone[blues->count].csTopEdge;

      blues->count += 1;
    }







    csUnitsPerPixel = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) ), blues->scale );


    for ( i = 0; i < blues->count; i++ )
    {
      size_t j;
      CF2_F16Dot16 minDiff;
      CF2_F16Dot16 flatFamilyEdge, diff;

      CF2_F16Dot16 flatEdge = blues->zone[i].csFlatEdge;


      if ( blues->zone[i].bottomZone )
      {




        minDiff = ( (CF2_F16Dot16)0x7FFFFFFFL );

        for ( j = 0; j < numFamilyOtherBlues; j += 2 )
        {

          flatFamilyEdge = ( (CF2_F16Dot16)( (FT_UInt32)(familyOtherBlues[j + 1]) << 16 ) );

          diff = ( (flatEdge - flatFamilyEdge) < 0 ? -(flatEdge - flatFamilyEdge) : (flatEdge - flatFamilyEdge) );

          if ( diff < minDiff && diff < csUnitsPerPixel )
          {
            blues->zone[i].csFlatEdge = flatFamilyEdge;
            minDiff = diff;

            if ( diff == 0 )
              break;
          }
        }


        if ( numFamilyBlues >= 2 )
        {

          flatFamilyEdge = ( (CF2_F16Dot16)( (FT_UInt32)(familyBlues[1]) << 16 ) );

          diff = ( (flatEdge - flatFamilyEdge) < 0 ? -(flatEdge - flatFamilyEdge) : (flatEdge - flatFamilyEdge) );

          if ( diff < minDiff && diff < csUnitsPerPixel )
            blues->zone[i].csFlatEdge = flatFamilyEdge;
        }
      }
      else
      {





        minDiff = ( (CF2_F16Dot16)0x7FFFFFFFL );

        for ( j = 2; j < numFamilyBlues; j += 2 )
        {

          flatFamilyEdge = ( (CF2_F16Dot16)( (FT_UInt32)(familyBlues[j]) << 16 ) );


          flatFamilyEdge += 2 * font->darkenY;

          diff = ( (flatEdge - flatFamilyEdge) < 0 ? -(flatEdge - flatFamilyEdge) : (flatEdge - flatFamilyEdge) );

          if ( diff < minDiff && diff < csUnitsPerPixel )
          {
            blues->zone[i].csFlatEdge = flatFamilyEdge;
            minDiff = diff;

            if ( diff == 0 )
              break;
          }
        }
      }
    }






    if ( maxZoneHeight > 0 )
    {
      if ( blues->blueScale > FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) ),
                                         maxZoneHeight ) )
      {

        blues->blueScale = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) ),
                                      maxZoneHeight );
      }
# 393 "../../../libs/freetype/src/cff/cf2blues.c"
    }
# 403 "../../../libs/freetype/src/cff/cf2blues.c"
    if ( blues->scale < blues->blueScale )
    {
      blues->suppressOvershoot = 1;





      blues->boost = ( (CF2_F16Dot16)( (.6) * 65536.0 + 0.5 ) ) -
                       FT_MulDiv( ( (CF2_F16Dot16)( (.6) * 65536.0 + 0.5 ) ),
                                  blues->scale,
                                  blues->blueScale );
      if ( blues->boost > 0x7FFF )
      {

        blues->boost = 0x7FFF;
      }
    }


    if ( font->stemDarkened )
      blues->boost = 0;




    for ( i = 0; i < blues->count; i++ )
    {
      if ( blues->zone[i].bottomZone )
        blues->zone[i].dsFlatEdge = ( (CF2_F16Dot16)( ( (FT_UInt32)(FT_MulFix_arm( (FT_Int32)(blues->zone[i].csFlatEdge), (FT_Int32)(blues->scale) ) - blues->boost) + 0x8000U ) & 0xFFFF0000UL ) )



                                                    ;
      else
        blues->zone[i].dsFlatEdge = ( (CF2_F16Dot16)( ( (FT_UInt32)(FT_MulFix_arm( (FT_Int32)(blues->zone[i].csFlatEdge), (FT_Int32)(blues->scale) ) + blues->boost) + 0x8000U ) & 0xFFFF0000UL ) )



                                                    ;
    }
  }
# 464 "../../../libs/freetype/src/cff/cf2blues.c"
  static FT_Bool
  cf2_blues_capture( const CF2_Blues blues,
                     CF2_Hint bottomHintEdge,
                     CF2_Hint topHintEdge )
  {

    CF2_F16Dot16 csFuzz = blues->blueFuzz;


    CF2_F16Dot16 dsNew;


    CF2_F16Dot16 dsMove = 0;

    FT_Bool captured = 0;
    FT_UFast i;



    do { } while ( 0 )
                                                  ;


    for ( i = 0; i < blues->count; i++ )
    {
      if ( blues->zone[i].bottomZone &&
           cf2_hint_isBottom( bottomHintEdge ) )
      {
        if ( ( blues->zone[i].csBottomEdge - csFuzz ) <=
               bottomHintEdge->csCoord &&
             bottomHintEdge->csCoord <=
               ( blues->zone[i].csTopEdge + csFuzz ) )
        {


          if ( blues->suppressOvershoot )
            dsNew = blues->zone[i].dsFlatEdge;

          else if ( ( blues->zone[i].csTopEdge - bottomHintEdge->csCoord ) >=
                      blues->blueShift )
          {

            dsNew = ( (( (CF2_F16Dot16)( ( (FT_UInt32)(bottomHintEdge->dsCoord) + 0x8000U ) & 0xFFFF0000UL ) )) < (blues->zone[i].dsFlatEdge - ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) )) ? (( (CF2_F16Dot16)( ( (FT_UInt32)(bottomHintEdge->dsCoord) + 0x8000U ) & 0xFFFF0000UL ) )) : (blues->zone[i].dsFlatEdge - ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) )) )

                                                                       ;
          }

          else
          {

            dsNew = ( (CF2_F16Dot16)( ( (FT_UInt32)(bottomHintEdge->dsCoord) + 0x8000U ) & 0xFFFF0000UL ) );
          }

          dsMove = dsNew - bottomHintEdge->dsCoord;
          captured = 1;

          break;
        }
      }

      if ( !blues->zone[i].bottomZone && cf2_hint_isTop( topHintEdge ) )
      {
        if ( ( blues->zone[i].csBottomEdge - csFuzz ) <=
               topHintEdge->csCoord &&
             topHintEdge->csCoord <=
               ( blues->zone[i].csTopEdge + csFuzz ) )
        {


          if ( blues->suppressOvershoot )
            dsNew = blues->zone[i].dsFlatEdge;

          else if ( ( topHintEdge->csCoord - blues->zone[i].csBottomEdge ) >=
                      blues->blueShift )
          {

            dsNew = ( (( (CF2_F16Dot16)( ( (FT_UInt32)(topHintEdge->dsCoord) + 0x8000U ) & 0xFFFF0000UL ) )) > (blues->zone[i].dsFlatEdge + ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) )) ? (( (CF2_F16Dot16)( ( (FT_UInt32)(topHintEdge->dsCoord) + 0x8000U ) & 0xFFFF0000UL ) )) : (blues->zone[i].dsFlatEdge + ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) )) )

                                                                       ;
          }

          else
          {

            dsNew = ( (CF2_F16Dot16)( ( (FT_UInt32)(topHintEdge->dsCoord) + 0x8000U ) & 0xFFFF0000UL ) );
          }

          dsMove = dsNew - topHintEdge->dsCoord;
          captured = 1;

          break;
        }
      }
    }

    if ( captured )
    {

      if ( cf2_hint_isValid( bottomHintEdge ) )
      {
        bottomHintEdge->dsCoord += dsMove;
        cf2_hint_lock( bottomHintEdge );
      }

      if ( cf2_hint_isValid( topHintEdge ) )
      {
        topHintEdge->dsCoord += dsMove;
        cf2_hint_lock( topHintEdge );
      }
    }

    return captured;
  }
# 33 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2error.c" 1
# 43 "../../../libs/freetype/src/cff/cf2error.c"
  static void
  cf2_setError( FT_Error* error,
                FT_Error value )
  {
    if ( error && *error == 0 )
      *error = value;
  }
# 34 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2font.c" 1
# 47 "../../../libs/freetype/src/cff/cf2font.c"
# 1 "../../../libs/freetype/src/cff/cf2intrp.h" 1
# 47 "../../../libs/freetype/src/cff/cf2intrp.h"



  static void
  cf2_hintmask_init( CF2_HintMask hintmask,
                     FT_Error* error );
  static FT_Bool
  cf2_hintmask_isValid( const CF2_HintMask hintmask );
  static FT_Bool
  cf2_hintmask_isNew( const CF2_HintMask hintmask );
  static void
  cf2_hintmask_setNew( CF2_HintMask hintmask,
                       FT_Bool val );
  static FT_Byte*
  cf2_hintmask_getMaskPtr( CF2_HintMask hintmask );
  static void
  cf2_hintmask_setAll( CF2_HintMask hintmask,
                       size_t bitCount );

  static void
  cf2_interpT2CharString( CF2_Font font,
                          CF2_Buffer charstring,
                          CF2_OutlineCallbacks callbacks,
                          const FT_Vector* translation,
                          FT_Bool doingSeac,
                          CF2_F16Dot16 curX,
                          CF2_F16Dot16 curY,
                          CF2_F16Dot16* width );



# 48 "../../../libs/freetype/src/cff/cf2font.c" 2



  static void
  cf2_computeDarkening( CF2_F16Dot16 emRatio,
                        CF2_F16Dot16 ppem,
                        CF2_F16Dot16 stemWidth,
                        CF2_F16Dot16* darkenAmount,
                        CF2_F16Dot16 boldenAmount,
                        FT_Bool stemDarkened,
                        FT_Int* darkenParams )
  {
# 110 "../../../libs/freetype/src/cff/cf2font.c"
    CF2_F16Dot16 stemWidthPer1000, scaledStem;
    FT_Int logBase2;


    *darkenAmount = 0;

    if ( boldenAmount == 0 && !stemDarkened )
      return;


    if ( emRatio < ( (CF2_F16Dot16)( (.01) * 65536.0 + 0.5 ) ) )
      return;

    if ( stemDarkened )
    {
      FT_Int x1 = darkenParams[0];
      FT_Int y1 = darkenParams[1];
      FT_Int x2 = darkenParams[2];
      FT_Int y2 = darkenParams[3];
      FT_Int x3 = darkenParams[4];
      FT_Int y3 = darkenParams[5];
      FT_Int x4 = darkenParams[6];
      FT_Int y4 = darkenParams[7];







      stemWidthPer1000 = FT_MulFix_arm( (FT_Int32)(stemWidth + boldenAmount), (FT_Int32)(emRatio) );
# 156 "../../../libs/freetype/src/cff/cf2font.c"
      logBase2 = ( 31 - __builtin_clz( (FT_UInt32)stemWidthPer1000 ) ) +
                   ( 31 - __builtin_clz( (FT_UInt32)ppem ) );

      if ( logBase2 >= 46 )

        scaledStem = ( (CF2_F16Dot16)( (FT_UInt32)(x4) << 16 ) );
      else
        scaledStem = FT_MulFix_arm( (FT_Int32)(stemWidthPer1000), (FT_Int32)(ppem) );



      if ( scaledStem < ( (CF2_F16Dot16)( (FT_UInt32)(x1) << 16 ) ) )
        *darkenAmount = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(y1) << 16 ) ), ppem );

      else if ( scaledStem < ( (CF2_F16Dot16)( (FT_UInt32)(x2) << 16 ) ) )
      {
        FT_Int xdelta = x2 - x1;
        FT_Int ydelta = y2 - y1;
        FT_Int x = stemWidthPer1000 -
                           FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(x1) << 16 ) ), ppem );


        if ( !xdelta )
          goto Try_x3;

        *darkenAmount = FT_MulDiv( x, ydelta, xdelta ) +
                          FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(y1) << 16 ) ), ppem );
      }

      else if ( scaledStem < ( (CF2_F16Dot16)( (FT_UInt32)(x3) << 16 ) ) )
      {
      Try_x3:
        {
          FT_Int xdelta = x3 - x2;
          FT_Int ydelta = y3 - y2;
          FT_Int x = stemWidthPer1000 -
                             FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(x2) << 16 ) ), ppem );


          if ( !xdelta )
            goto Try_x4;

          *darkenAmount = FT_MulDiv( x, ydelta, xdelta ) +
                            FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(y2) << 16 ) ), ppem );
        }
      }

      else if ( scaledStem < ( (CF2_F16Dot16)( (FT_UInt32)(x4) << 16 ) ) )
      {
      Try_x4:
        {
          FT_Int xdelta = x4 - x3;
          FT_Int ydelta = y4 - y3;
          FT_Int x = stemWidthPer1000 -
                             FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(x3) << 16 ) ), ppem );


          if ( !xdelta )
            goto Use_y4;

          *darkenAmount = FT_MulDiv( x, ydelta, xdelta ) +
                            FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(y3) << 16 ) ), ppem );
        }
      }

      else
      {
      Use_y4:
        *darkenAmount = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(y4) << 16 ) ), ppem );
      }



      *darkenAmount = FT_DivFix( *darkenAmount, 2 * emRatio );
    }


    *darkenAmount += boldenAmount / 2;
  }





  static void
  cf2_font_setup( CF2_Font font,
                  const CF2_Matrix* transform )
  {

    CFF_Decoder* decoder = font->decoder;

    FT_Bool needExtraSetup = 0;


    CF2_F16Dot16 boldenX = font->syntheticEmboldeningAmountX;
    CF2_F16Dot16 boldenY = font->syntheticEmboldeningAmountY;

    CFF_SubFont subFont;
    CF2_F16Dot16 ppem;



    font->error = FT_Err_Ok;



    subFont = cf2_getSubfont( decoder );
    if ( font->lastSubfont != subFont )
    {
      font->lastSubfont = subFont;
      needExtraSetup = 1;
    }




    ppem = cf2_getPpemY( decoder );
    if ( font->ppem != ppem )
    {
      font->ppem = ppem;
      needExtraSetup = 1;
    }


    font->hinted = (FT_Bool)( font->renderingFlags & 1 );



    if ( memcmp( transform,
                    &font->currentTransform,
                    4 * sizeof ( CF2_F16Dot16 ) ) != 0 )
    {


      font->currentTransform = *transform;
      font->currentTransform.tx =
      font->currentTransform.ty = ( (CF2_F16Dot16)( (FT_UInt32)(0) << 16 ) );



      font->innerTransform = *transform;
      font->outerTransform.a =
      font->outerTransform.d = ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) );
      font->outerTransform.b =
      font->outerTransform.c = ( (CF2_F16Dot16)( (FT_UInt32)(0) << 16 ) );

      needExtraSetup = 1;
    }
# 312 "../../../libs/freetype/src/cff/cf2font.c"
    if ( font->stemDarkened != ( font->renderingFlags & 2 ) )
    {
      font->stemDarkened =
        (FT_Bool)( font->renderingFlags & 2 );


      needExtraSetup = 1;
    }



    if ( needExtraSetup )
    {
# 334 "../../../libs/freetype/src/cff/cf2font.c"
      CF2_F16Dot16 emRatio;
      CF2_F16Dot16 stdHW;
      FT_Fast unitsPerEm = font->unitsPerEm;


      if ( unitsPerEm == 0 )
        unitsPerEm = 1000;

      ppem = ( (( (CF2_F16Dot16)( (FT_UInt32)(4) << 16 ) )) > (font->ppem) ? (( (CF2_F16Dot16)( (FT_UInt32)(4) << 16 ) )) : (font->ppem) )
                                 ;
# 354 "../../../libs/freetype/src/cff/cf2font.c"
      emRatio = ( (CF2_F16Dot16)( (FT_UInt32)(1000) << 16 ) ) / unitsPerEm;
      font->stdVW = cf2_getStdVW( decoder );

      if ( font->stdVW <= 0 )
        font->stdVW = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(75) << 16 ) ), emRatio );

      if ( boldenX > 0 )
      {


        boldenX = ( (boldenX) > (FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(unitsPerEm) << 16 ) ), ppem )) ? (boldenX) : (FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(unitsPerEm) << 16 ) ), ppem )) )
                                                                           ;






        cf2_computeDarkening( emRatio,
                              ppem,
                              font->stdVW,
                              &font->darkenX,
                              boldenX,
                              0,
                              font->darkenParams );
      }
      else
        cf2_computeDarkening( emRatio,
                              ppem,
                              font->stdVW,
                              &font->darkenX,
                              0,
                              font->stemDarkened,
                              font->darkenParams );
# 399 "../../../libs/freetype/src/cff/cf2font.c"
      stdHW = cf2_getStdHW( decoder );

      if ( stdHW > 0 && font->stdVW > 2 * stdHW )
        font->stdHW = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(75) << 16 ) ), emRatio );
      else
      {

        font->stdHW = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(110) << 16 ) ), emRatio );
      }

      cf2_computeDarkening( emRatio,
                            ppem,
                            font->stdHW,
                            &font->darkenY,
                            boldenY,
                            font->stemDarkened,
                            font->darkenParams );

      if ( font->darkenX != 0 || font->darkenY != 0 )
        font->darkened = 1;
      else
        font->darkened = 0;

      font->reverseWinding = 0;


      cf2_blues_init( &font->blues, font );
    }
  }



  static FT_Error
  cf2_getGlyphOutline( CF2_Font font,
                       CF2_Buffer charstring,
                       const CF2_Matrix* transform,
                       CF2_F16Dot16* glyphWidth )
  {
    FT_Error lastError = FT_Err_Ok;

    FT_Vector translation;





    CF2_F16Dot16 advWidth = 0;
    FT_Bool needWinding;





    translation.x = transform->tx;
    translation.y = transform->ty;


    cf2_font_setup( font, transform );
    if ( font->error )
      goto exit;


    font->reverseWinding = 0;


    needWinding = font->darkened;

    while ( 1 )
    {

      cf2_outline_reset( &font->outline );


      cf2_interpT2CharString( font,
                              charstring,
                              (CF2_OutlineCallbacks)&font->outline,
                              &translation,
                              0,
                              0,
                              0,
                              &advWidth );

      if ( font->error )
        goto exit;

      if ( !needWinding )
        break;


      if ( font->outline.root.windingMomentum >= 0 )
        break;



      font->reverseWinding = 1;

      needWinding = 0;
    }


    cf2_outline_close( &font->outline );

  exit:

    *glyphWidth = advWidth;


    cf2_setError( &font->error, lastError );

    return font->error;
  }
# 35 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2ft.c" 1
# 55 "../../../libs/freetype/src/cff/cf2ft.c"
  static FT_Error
  cf2_checkTransform( const CF2_Matrix* transform,
                      FT_Fast unitsPerEm )
  {
    CF2_F16Dot16 maxScale;


    do { } while ( 0 );

    if ( transform->a <= 0 || transform->d <= 0 )
      return CF2_Err_Invalid_Size_Handle;

    do { } while ( 0 );
    do { } while ( 0 );

    if ( unitsPerEm > 0x7FFF )
      return CF2_Err_Glyph_Too_Big;

    maxScale = FT_DivFix( ( (CF2_F16Dot16)( (FT_UInt32)(2000) << 16 ) ), ( (CF2_F16Dot16)( (FT_UInt32)(unitsPerEm) << 16 ) ) );

    if ( transform->a > maxScale || transform->d > maxScale )
      return CF2_Err_Glyph_Too_Big;

    return FT_Err_Ok;
  }


  static void
  cf2_setGlyphWidth( CF2_Outline outline,
                     CF2_F16Dot16 width )
  {
    CFF_Decoder* decoder = outline->decoder;


    do { } while ( 0 );

    decoder->glyph_width = ( (FT_Short)( ( (FT_UInt32)(width) + 0x8000U ) >> 16 ) );
  }



  static void
  cf2_free_instance( void* ptr )
  {
    CF2_Font font = (CF2_Font)ptr;


    if ( font )
    {
      FT_Memory memory = font->memory;


      (void)memory;
    }
  }
# 119 "../../../libs/freetype/src/cff/cf2ft.c"
  static void
  cf2_builder_moveTo( CF2_OutlineCallbacks callbacks,
                      const CF2_CallbackParams params )
  {

    CF2_Outline outline = (CF2_Outline)callbacks;
    CFF_Builder* builder;

    (void)params;


    do { } while ( 0 );
    do { } while ( 0 );

    builder = &outline->decoder->builder;


    cff_builder_close_contour( builder );
    builder->path_begun = 0;
  }


  static void
  cf2_builder_lineTo( CF2_OutlineCallbacks callbacks,
                      const CF2_CallbackParams params )
  {
    FT_Error error;


    CF2_Outline outline = (CF2_Outline)callbacks;
    CFF_Builder* builder;


    do { } while ( 0 );
    do { } while ( 0 );

    builder = &outline->decoder->builder;

    if ( !builder->path_begun )
    {


      error = cff_builder_start_point( builder,
                                       params->pt0.x,
                                       params->pt0.y );
      if ( error )
      {
        if ( !*callbacks->error )
          *callbacks->error = error;
        return;
      }
    }


    error = cff_builder_add_point1( builder,
                                    params->pt1.x,
                                    params->pt1.y );
    if ( error )
    {
      if ( !*callbacks->error )
        *callbacks->error = error;
      return;
    }
  }


  static void
  cf2_builder_cubeTo( CF2_OutlineCallbacks callbacks,
                      const CF2_CallbackParams params )
  {
    FT_Error error;


    CF2_Outline outline = (CF2_Outline)callbacks;
    CFF_Builder* builder;


    do { } while ( 0 );
    do { } while ( 0 );

    builder = &outline->decoder->builder;

    if ( !builder->path_begun )
    {


      error = cff_builder_start_point( builder,
                                       params->pt0.x,
                                       params->pt0.y );
      if ( error )
      {
        if ( !*callbacks->error )
          *callbacks->error = error;
        return;
      }
    }


    error = cff_check_points( builder, 3 );
    if ( error )
    {
      if ( !*callbacks->error )
        *callbacks->error = error;
      return;
    }

    cff_builder_add_point( builder,
                           params->pt1.x,
                           params->pt1.y, 0 );
    cff_builder_add_point( builder,
                           params->pt2.x,
                           params->pt2.y, 0 );
    cff_builder_add_point( builder,
                           params->pt3.x,
                           params->pt3.y, 1 );
  }


  static void
  cf2_outline_init( CF2_Outline outline,
                    FT_Memory memory,
                    FT_Error* error )
  {
    memset( outline, 0, (FT_Offset)(sizeof ( CF2_OutlineRec )) );

    outline->root.memory = memory;
    outline->root.error = error;

    outline->root.moveTo = cf2_builder_moveTo;
    outline->root.lineTo = cf2_builder_lineTo;
    outline->root.cubeTo = cf2_builder_cubeTo;
  }



  static void
  cf2_getScaleAndHintFlag( CFF_Decoder* decoder,
                           CF2_F16Dot16* x_scale,
                           CF2_F16Dot16* y_scale,
                           FT_Bool* hinted,
                           FT_Bool* scaled )
  {
    do { } while ( 0 );


    *hinted = decoder->builder.glyph->hint;
    *scaled = decoder->builder.glyph->scaled;

    if ( *hinted )
    {
      *x_scale = ( decoder->builder.glyph->x_scale + 32 ) / 64;
      *y_scale = ( decoder->builder.glyph->y_scale + 32 ) / 64;
    }
    else
    {



      *x_scale = 0x0400;
      *y_scale = 0x0400;
    }
  }




  static FT_UShort
  cf2_getUnitsPerEm( CFF_Decoder* decoder )
  {
    do { } while ( 0 );
    do { } while ( 0 );

    return decoder->builder.face->root.units_per_EM;
  }



  static FT_Error
  cf2_decoder_parse_charstrings( CFF_Decoder* decoder,
                                 FT_Byte* charstring_base,
                                 FT_ULong charstring_len )
  {
    FT_Memory memory;
    FT_Error error = FT_Err_Ok;
    CF2_Font font;


    do { } while ( 0 );

    memory = decoder->builder.memory;


    font = (CF2_Font)decoder->cff->cf2_instance.data;


    if ( decoder->cff->cf2_instance.data == ((void *)0) )
    {
      decoder->cff->cf2_instance.finalizer =
        (FT_Generic_Finalizer)cf2_free_instance;

      if ( ( ((decoder->cff->cf2_instance.data) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( CF2_FontRec )), &error ))), error != 0 )
                                              )
        return CF2_Err_Out_Of_Memory;

      font = (CF2_Font)decoder->cff->cf2_instance.data;

      font->memory = memory;


      cf2_outline_init( &font->outline, font->memory, &font->error );
    }



    font->decoder = decoder;
    font->outline.decoder = decoder;

    {


      CFF_Builder* builder = &decoder->builder;
      CFF_Driver driver = (CFF_Driver)((FT_Face)(builder->face))->driver;


      FT_Error error2 = FT_Err_Ok;
      CF2_BufferRec buf;
      CF2_Matrix transform;
      CF2_F16Dot16 glyphWidth;

      FT_Bool hinted;
      FT_Bool scaled;




      do { } while ( 0 );

      memset( &buf, 0, (FT_Offset)(sizeof ( *(&buf) )) );
      buf.start =
      buf.ptr = charstring_base;
      buf.end = charstring_base + charstring_len;

      memset( &transform, 0, (FT_Offset)(sizeof ( *(&transform) )) );

      cf2_getScaleAndHintFlag( decoder,
                               &transform.a,
                               &transform.d,
                               &hinted,
                               &scaled );

      font->renderingFlags = 0;
      if ( hinted )
        font->renderingFlags |= 1;
      if ( scaled && !driver->no_stem_darkening )
        font->renderingFlags |= 2;

      font->darkenParams[0] = driver->darken_params[0];
      font->darkenParams[1] = driver->darken_params[1];
      font->darkenParams[2] = driver->darken_params[2];
      font->darkenParams[3] = driver->darken_params[3];
      font->darkenParams[4] = driver->darken_params[4];
      font->darkenParams[5] = driver->darken_params[5];
      font->darkenParams[6] = driver->darken_params[6];
      font->darkenParams[7] = driver->darken_params[7];



      font->unitsPerEm = (FT_Fast)cf2_getUnitsPerEm( decoder );

      if ( scaled )
      {
        error2 = cf2_checkTransform( &transform, font->unitsPerEm );
        if ( error2 )
          return error2;
      }

      error2 = cf2_getGlyphOutline( font, &buf, &transform, &glyphWidth );
      if ( error2 )
        return CF2_Err_Invalid_File_Format;

      cf2_setGlyphWidth( &font->outline, glyphWidth );

      return FT_Err_Ok;
    }
  }



  static CFF_SubFont
  cf2_getSubfont( CFF_Decoder* decoder )
  {
    do { } while ( 0 );

    return decoder->current_subfont;
  }



  static CF2_F16Dot16
  cf2_getPpemY( CFF_Decoder* decoder )
  {
    do { } while ( 0 )

                                                 ;
# 433 "../../../libs/freetype/src/cff/cf2ft.c"
    return ( (CF2_F16Dot16)( (FT_UInt32)(decoder->builder.face->root.size->metrics.y_ppem) << 16 ) )
                                                               ;
  }





  static CF2_F16Dot16
  cf2_getStdVW( CFF_Decoder* decoder )
  {
    do { } while ( 0 );

    return ( (CF2_F16Dot16)( (FT_UInt32)(decoder->current_subfont->private_dict.standard_height) << 16 ) )
                                                                     ;
  }


  static CF2_F16Dot16
  cf2_getStdHW( CFF_Decoder* decoder )
  {
    do { } while ( 0 );

    return ( (CF2_F16Dot16)( (FT_UInt32)(decoder->current_subfont->private_dict.standard_width) << 16 ) )
                                                                    ;
  }



  static void
  cf2_getBlueMetrics( CFF_Decoder* decoder,
                      CF2_F16Dot16* blueScale,
                      CF2_F16Dot16* blueShift,
                      CF2_F16Dot16* blueFuzz )
  {
    do { } while ( 0 );

    *blueScale = FT_DivFix(
                   decoder->current_subfont->private_dict.blue_scale,
                   ( (CF2_F16Dot16)( (FT_UInt32)(1000) << 16 ) ) );
    *blueShift = ( (CF2_F16Dot16)( (FT_UInt32)(decoder->current_subfont->private_dict.blue_shift) << 16 ) )
                                                                      ;
    *blueFuzz = ( (CF2_F16Dot16)( (FT_UInt32)(decoder->current_subfont->private_dict.blue_fuzz) << 16 ) )
                                                                     ;
  }




  static void
  cf2_getBlueValues( CFF_Decoder* decoder,
                     size_t* count,
                     FT_Pos* *data )
  {
    do { } while ( 0 );

    *count = decoder->current_subfont->private_dict.num_blue_values;
    *data = (FT_Pos*)
               &decoder->current_subfont->private_dict.blue_values;
  }


  static void
  cf2_getOtherBlues( CFF_Decoder* decoder,
                     size_t* count,
                     FT_Pos* *data )
  {
    do { } while ( 0 );

    *count = decoder->current_subfont->private_dict.num_other_blues;
    *data = (FT_Pos*)
               &decoder->current_subfont->private_dict.other_blues;
  }


  static void
  cf2_getFamilyBlues( CFF_Decoder* decoder,
                      size_t* count,
                      FT_Pos* *data )
  {
    do { } while ( 0 );

    *count = decoder->current_subfont->private_dict.num_family_blues;
    *data = (FT_Pos*)
               &decoder->current_subfont->private_dict.family_blues;
  }


  static void
  cf2_getFamilyOtherBlues( CFF_Decoder* decoder,
                           size_t* count,
                           FT_Pos* *data )
  {
    do { } while ( 0 );

    *count = decoder->current_subfont->private_dict.num_family_other_blues;
    *data = (FT_Pos*)
               &decoder->current_subfont->private_dict.family_other_blues;
  }


  static FT_Fast
  cf2_getLanguageGroup( CFF_Decoder* decoder )
  {
    do { } while ( 0 );

    return decoder->current_subfont->private_dict.language_group;
  }




  static FT_Fast
  cf2_initGlobalRegionBuffer( CFF_Decoder* decoder,
                              FT_Fast subrNum,
                              CF2_Buffer buf )
  {
    FT_UFast idx;


    do { } while ( 0 );

    memset( buf, 0, (FT_Offset)(sizeof ( *(buf) )) );

    idx = (FT_UFast)( subrNum + decoder->globals_bias );
    if ( idx >= decoder->num_globals )
      return 1;

    do { } while ( 0 );

    buf->start =
    buf->ptr = decoder->globals[idx];
    buf->end = decoder->globals[idx + 1];

    return 0;
  }




  static FT_Error
  cf2_getSeacComponent( CFF_Decoder* decoder,
                        FT_Fast code,
                        CF2_Buffer buf )
  {
    FT_Fast gid;
    FT_Byte* charstring;
    FT_ULong len;
    FT_Error error;


    do { } while ( 0 );

    memset( buf, 0, (FT_Offset)(sizeof ( *(buf) )) );




    if ( decoder->builder.face->root.internal->incremental_interface )
      gid = code;
    else

    {
      gid = cff_lookup_glyph_by_stdcharcode( decoder->cff, code );
      if ( gid < 0 )
        return CF2_Err_Invalid_Glyph_Format;
    }

    error = cff_get_glyph_data( decoder->builder.face,
                                (FT_UFast)gid,
                                &charstring,
                                &len );

    if ( error )
      return error;


    do { } while ( 0 );

    buf->start = charstring;
    buf->end = charstring + len;
    buf->ptr = buf->start;

    return FT_Err_Ok;
  }


  static void
  cf2_freeSeacComponent( CFF_Decoder* decoder,
                         CF2_Buffer buf )
  {
    do { } while ( 0 );

    cff_free_glyph_data( decoder->builder.face,
                         (FT_Byte**)&buf->start,
                         (FT_ULong)( buf->end - buf->start ) );
  }


  static FT_Fast
  cf2_initLocalRegionBuffer( CFF_Decoder* decoder,
                             FT_Fast subrNum,
                             CF2_Buffer buf )
  {
    FT_UFast idx;


    do { } while ( 0 );

    memset( buf, 0, (FT_Offset)(sizeof ( *(buf) )) );

    idx = (FT_UFast)( subrNum + decoder->locals_bias );
    if ( idx >= decoder->num_locals )
      return 1;

    do { } while ( 0 );

    buf->start =
    buf->ptr = decoder->locals[idx];
    buf->end = decoder->locals[idx + 1];

    return 0;
  }


  static CF2_F16Dot16
  cf2_getDefaultWidthX( CFF_Decoder* decoder )
  {
    do { } while ( 0 );

    return ( (CF2_F16Dot16)( (FT_UInt32)(decoder->current_subfont->private_dict.default_width) << 16 ) )
                                                                   ;
  }


  static CF2_F16Dot16
  cf2_getNominalWidthX( CFF_Decoder* decoder )
  {
    do { } while ( 0 );

    return ( (CF2_F16Dot16)( (FT_UInt32)(decoder->current_subfont->private_dict.nominal_width) << 16 ) )
                                                                   ;
  }


  static void
  cf2_outline_reset( CF2_Outline outline )
  {
    CFF_Decoder* decoder = outline->decoder;


    do { } while ( 0 );

    outline->root.windingMomentum = 0;

    FT_GlyphLoader_Rewind( decoder->builder.loader );
  }


  static void
  cf2_outline_close( CF2_Outline outline )
  {
    CFF_Decoder* decoder = outline->decoder;


    do { } while ( 0 );

    cff_builder_close_contour( &decoder->builder );

    FT_GlyphLoader_Add( decoder->builder.loader );
  }
# 36 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2hints.c" 1
# 58 "../../../libs/freetype/src/cff/cf2hints.c"
  typedef struct CF2_HintMoveRec_
  {
    size_t j;
    CF2_F16Dot16 moveUp;

  } CF2_HintMoveRec, *CF2_HintMove;




  static FT_Fast
  cf2_getWindingMomentum( CF2_F16Dot16 x1,
                          CF2_F16Dot16 y1,
                          CF2_F16Dot16 x2,
                          CF2_F16Dot16 y2 )
  {



    return ( x1 >> 16 ) * ( ( y2 - y1 ) >> 16 ) -
           ( y1 >> 16 ) * ( ( x2 - x1 ) >> 16 );
  }
# 89 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_hint_init( CF2_Hint hint,
                 const CF2_ArrStack stemHintArray,
                 size_t indexStemHint,
                 const CF2_Font font,
                 CF2_F16Dot16 hintOrigin,
                 CF2_F16Dot16 scale,
                 FT_Bool bottom )
  {
    CF2_F16Dot16 width;
    const CF2_StemHintRec* stemHint;


    memset( hint, 0, (FT_Offset)(sizeof ( *(hint) )) );

    stemHint = (const CF2_StemHintRec*)cf2_arrstack_getPointer(
                                         stemHintArray,
                                         indexStemHint );

    width = stemHint->max - stemHint->min;

    if ( width == ( (CF2_F16Dot16)( (FT_UInt32)(-21) << 16 ) ) )
    {


      if ( bottom )
      {
        hint->csCoord = stemHint->max;
        hint->flags = CF2_GhostBottom;
      }
      else
        hint->flags = 0;
    }

    else if ( width == ( (CF2_F16Dot16)( (FT_UInt32)(-20) << 16 ) ) )
    {


      if ( bottom )
        hint->flags = 0;
      else
      {
        hint->csCoord = stemHint->min;
        hint->flags = CF2_GhostTop;
      }
    }

    else if ( width < 0 )
    {
# 156 "../../../libs/freetype/src/cff/cf2hints.c"
      if ( bottom )
      {
        hint->csCoord = stemHint->max;
        hint->flags = CF2_PairBottom;
      }
      else
      {
        hint->csCoord = stemHint->min;
        hint->flags = CF2_PairTop;
      }
    }

    else
    {


      if ( bottom )
      {
        hint->csCoord = stemHint->min;
        hint->flags = CF2_PairBottom;
      }
      else
      {
        hint->csCoord = stemHint->max;
        hint->flags = CF2_PairTop;
      }
    }




    if ( cf2_hint_isTop( hint ) )
      hint->csCoord += 2 * font->darkenY;

    hint->csCoord += hintOrigin;
    hint->scale = scale;
    hint->index = indexStemHint;


    if ( hint->flags != 0 && stemHint->used )
    {
      if ( cf2_hint_isTop( hint ) )
        hint->dsCoord = stemHint->maxDS;
      else
        hint->dsCoord = stemHint->minDS;

      cf2_hint_lock( hint );
    }
    else
      hint->dsCoord = FT_MulFix_arm( (FT_Int32)(hint->csCoord), (FT_Int32)(scale) );
  }



  static void
  cf2_hint_initZero( CF2_Hint hint )
  {
    memset( hint, 0, (FT_Offset)(sizeof ( *(hint) )) );
  }


  static FT_Bool
  cf2_hint_isValid( const CF2_Hint hint )
  {
    return (FT_Bool)( hint->flags != 0 );
  }


  static FT_Bool
  cf2_hint_isPair( const CF2_Hint hint )
  {
    return (FT_Bool)( ( hint->flags &
                        ( CF2_PairBottom | CF2_PairTop ) ) != 0 );
  }


  static FT_Bool
  cf2_hint_isPairTop( const CF2_Hint hint )
  {
    return (FT_Bool)( ( hint->flags & CF2_PairTop ) != 0 );
  }


  static FT_Bool
  cf2_hint_isTop( const CF2_Hint hint )
  {
    return (FT_Bool)( ( hint->flags &
                        ( CF2_PairTop | CF2_GhostTop ) ) != 0 );
  }


  static FT_Bool
  cf2_hint_isBottom( const CF2_Hint hint )
  {
    return (FT_Bool)( ( hint->flags &
                        ( CF2_PairBottom | CF2_GhostBottom ) ) != 0 );
  }


  static FT_Bool
  cf2_hint_isLocked( const CF2_Hint hint )
  {
    return (FT_Bool)( ( hint->flags & CF2_Locked ) != 0 );
  }


  static FT_Bool
  cf2_hint_isSynthetic( const CF2_Hint hint )
  {
    return (FT_Bool)( ( hint->flags & CF2_Synthetic ) != 0 );
  }


  static void
  cf2_hint_lock( CF2_Hint hint )
  {
    hint->flags |= CF2_Locked;
  }


  static void
  cf2_hintmap_init( CF2_HintMap hintmap,
                    CF2_Font font,
                    CF2_HintMap initialMap,
                    CF2_ArrStack hintMoves,
                    CF2_F16Dot16 scale )
  {
    memset( hintmap, 0, (FT_Offset)(sizeof ( *(hintmap) )) );


    hintmap->hinted = font->hinted;
    hintmap->scale = scale;
    hintmap->font = font;
    hintmap->initialHintMap = initialMap;

    hintmap->hintMoves = hintMoves;
  }


  static FT_Bool
  cf2_hintmap_isValid( const CF2_HintMap hintmap )
  {
    return hintmap->isValid;
  }



  static CF2_F16Dot16
  cf2_hintmap_map( CF2_HintMap hintmap,
                   CF2_F16Dot16 csCoord )
  {
    if ( hintmap->count == 0 || ! hintmap->hinted )
    {

      return FT_MulFix_arm( (FT_Int32)(csCoord), (FT_Int32)(hintmap->scale) );
    }
    else
    {

      FT_UFast i = hintmap->lastIndex;

      do { } while ( 0 );


      while ( i < hintmap->count - 1 &&
              csCoord >= hintmap->edge[i + 1].csCoord )
        i += 1;


      while ( i > 0 && csCoord < hintmap->edge[i].csCoord )
        i -= 1;

      hintmap->lastIndex = i;

      if ( i == 0 && csCoord < hintmap->edge[0].csCoord )
      {

        return FT_MulFix_arm( (FT_Int32)(csCoord - hintmap->edge[0].csCoord), (FT_Int32)(hintmap->scale) )
                                           +
                 hintmap->edge[0].dsCoord;
      }
      else
      {




        return FT_MulFix_arm( (FT_Int32)(csCoord - hintmap->edge[i].csCoord), (FT_Int32)(hintmap->edge[i].scale) )
                                                   +
                 hintmap->edge[i].dsCoord;
      }
    }
  }
# 365 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_hintmap_adjustHints( CF2_HintMap hintmap )
  {
    size_t i, j;


    cf2_arrstack_clear( hintmap->hintMoves );
# 381 "../../../libs/freetype/src/cff/cf2hints.c"
    for ( i = 0; i < hintmap->count; i++ )
    {
      FT_Bool isPair = cf2_hint_isPair( &hintmap->edge[i] );



      j = isPair ? i + 1 : i;

      do { } while ( 0 );
      do { } while ( 0 );
      do { } while ( 0 );
      do { } while ( 0 )
                                                           ;

      if ( !cf2_hint_isLocked( &hintmap->edge[i] ) )
      {

        CF2_F16Dot16 fracDown = ( (hintmap->edge[i].dsCoord) - ( (CF2_F16Dot16)( (FT_UInt32)(hintmap->edge[i].dsCoord) & 0xFFFF0000UL ) ) );
        CF2_F16Dot16 fracUp = ( (hintmap->edge[j].dsCoord) - ( (CF2_F16Dot16)( (FT_UInt32)(hintmap->edge[j].dsCoord) & 0xFFFF0000UL ) ) );


        CF2_F16Dot16 downMoveDown = 0 - fracDown;
        CF2_F16Dot16 upMoveDown = 0 - fracUp;
        CF2_F16Dot16 downMoveUp = fracDown == 0
                                    ? 0
                                    : ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) ) - fracDown;
        CF2_F16Dot16 upMoveUp = fracUp == 0
                                    ? 0
                                    : ( (CF2_F16Dot16)( (FT_UInt32)(1) << 16 ) ) - fracUp;


        CF2_F16Dot16 moveUp = ( (downMoveUp) < (upMoveUp) ? (downMoveUp) : (upMoveUp) );

        CF2_F16Dot16 moveDown = ( (downMoveDown) > (upMoveDown) ? (downMoveDown) : (upMoveDown) );


        CF2_F16Dot16 move;

        CF2_F16Dot16 downMinCounter = ( (CF2_F16Dot16)( (0.5) * 65536.0 + 0.5 ) );
        CF2_F16Dot16 upMinCounter = ( (CF2_F16Dot16)( (0.5) * 65536.0 + 0.5 ) );
        FT_Bool saveEdge = 0;
# 440 "../../../libs/freetype/src/cff/cf2hints.c"
        if ( j >= hintmap->count - 1 ||
             hintmap->edge[j + 1].dsCoord >=
               hintmap->edge[j].dsCoord + moveUp + upMinCounter )
        {

          if ( i == 0 ||
               hintmap->edge[i - 1].dsCoord <=
                 hintmap->edge[i].dsCoord + moveDown - downMinCounter )
          {

            move = ( -moveDown < moveUp ) ? moveDown : moveUp;
          }
          else
            move = moveUp;
        }
        else
        {

          if ( i == 0 ||
               hintmap->edge[i - 1].dsCoord <=
                 hintmap->edge[i].dsCoord + moveDown - downMinCounter )
          {
            move = moveDown;

            saveEdge = (FT_Bool)( moveUp < -moveDown );
          }
          else
          {


            move = 0;
            saveEdge = 1;
          }
        }





        if ( saveEdge &&
             j < hintmap->count - 1 &&
             !cf2_hint_isLocked( &hintmap->edge[j + 1] ) )
        {
          CF2_HintMoveRec savedMove;


          savedMove.j = j;

          savedMove.moveUp = moveUp - move;

          cf2_arrstack_push( hintmap->hintMoves, &savedMove );
        }


        hintmap->edge[i].dsCoord += move;
        if ( isPair )
          hintmap->edge[j].dsCoord += move;
      }


      do { } while ( 0 )
                                                                           ;
      do { } while ( 0 )
                                                                       ;


      if ( i > 0 )
      {
        if ( hintmap->edge[i].csCoord != hintmap->edge[i - 1].csCoord )
          hintmap->edge[i - 1].scale =
            FT_DivFix(
              hintmap->edge[i].dsCoord - hintmap->edge[i - 1].dsCoord,
              hintmap->edge[i].csCoord - hintmap->edge[i - 1].csCoord );
      }

      if ( isPair )
      {
        if ( hintmap->edge[j].csCoord != hintmap->edge[j - 1].csCoord )
          hintmap->edge[j - 1].scale =
            FT_DivFix(
              hintmap->edge[j].dsCoord - hintmap->edge[j - 1].dsCoord,
              hintmap->edge[j].csCoord - hintmap->edge[j - 1].csCoord );

        i += 1;
      }
    }



    for ( i = cf2_arrstack_size( hintmap->hintMoves ); i > 0; i-- )
    {
      CF2_HintMove hintMove = (CF2_HintMove)
                      cf2_arrstack_getPointer( hintmap->hintMoves, i - 1 );


      j = hintMove->j;


      do { } while ( 0 );


      if ( hintmap->edge[j + 1].dsCoord >=
             hintmap->edge[j].dsCoord + hintMove->moveUp + ( (CF2_F16Dot16)( (0.5) * 65536.0 + 0.5 ) ) )
      {

        hintmap->edge[j].dsCoord += hintMove->moveUp;

        if ( cf2_hint_isPair( &hintmap->edge[j] ) )
        {
          do { } while ( 0 );
          hintmap->edge[j - 1].dsCoord += hintMove->moveUp;
        }
      }
    }
  }



  static void
  cf2_hintmap_insertHint( CF2_HintMap hintmap,
                          CF2_Hint bottomHintEdge,
                          CF2_Hint topHintEdge )
  {
    FT_UFast indexInsert;


    FT_Bool isPair = 1;
    CF2_Hint firstHintEdge = bottomHintEdge;
    CF2_Hint secondHintEdge = topHintEdge;




    do { } while ( 0 )
                                                   ;


    if ( !cf2_hint_isValid( bottomHintEdge ) )
    {

      firstHintEdge = topHintEdge;
      isPair = 0;
    }
    else if ( !cf2_hint_isValid( topHintEdge ) )
    {

      isPair = 0;
    }


    if ( isPair &&
         topHintEdge->csCoord < bottomHintEdge->csCoord )
      return;


    indexInsert = 0;
    for ( ; indexInsert < hintmap->count; indexInsert++ )
    {
      if ( hintmap->edge[indexInsert].csCoord >= firstHintEdge->csCoord )
        break;
    }
# 613 "../../../libs/freetype/src/cff/cf2hints.c"
    if ( indexInsert < hintmap->count )
    {


      if ( hintmap->edge[indexInsert].csCoord == firstHintEdge->csCoord )
        return;


      if ( isPair &&
           hintmap->edge[indexInsert].csCoord <= secondHintEdge->csCoord )
        return;


      if ( cf2_hint_isPairTop( &hintmap->edge[indexInsert] ) )
        return;
    }


    if ( cf2_hintmap_isValid( hintmap->initialHintMap ) &&
         !cf2_hint_isLocked( firstHintEdge ) )
    {
      if ( isPair )
      {


        CF2_F16Dot16 midpoint = cf2_hintmap_map(
                                 hintmap->initialHintMap,
                                 ( secondHintEdge->csCoord +
                                   firstHintEdge->csCoord ) / 2 );
        CF2_F16Dot16 halfWidth = FT_MulFix_arm( (FT_Int32)(( secondHintEdge->csCoord - firstHintEdge->csCoord ) / 2), (FT_Int32)(hintmap->scale) )


                                                 ;


        firstHintEdge->dsCoord = midpoint - halfWidth;
        secondHintEdge->dsCoord = midpoint + halfWidth;
      }
      else
        firstHintEdge->dsCoord = cf2_hintmap_map( hintmap->initialHintMap,
                                                  firstHintEdge->csCoord );
    }
# 677 "../../../libs/freetype/src/cff/cf2hints.c"
    if ( indexInsert > 0 )
    {

      if ( firstHintEdge->dsCoord < hintmap->edge[indexInsert - 1].dsCoord )
        return;
    }

    if ( indexInsert < hintmap->count )
    {

      if ( isPair )
      {
        if ( secondHintEdge->dsCoord > hintmap->edge[indexInsert].dsCoord )
          return;
      }
      else
      {
        if ( firstHintEdge->dsCoord > hintmap->edge[indexInsert].dsCoord )
          return;
      }
    }


    {
      FT_UFast iSrc = hintmap->count - 1;
      FT_UFast iDst = isPair ? hintmap->count + 1 : hintmap->count;

      FT_UFast count = hintmap->count - indexInsert;


      if ( iDst >= CF2_MAX_HINT_EDGES )
      {
        do { } while ( 0 );
        return;
      }

      while ( count-- )
        hintmap->edge[iDst--] = hintmap->edge[iSrc--];


      hintmap->edge[indexInsert] = *firstHintEdge;
      hintmap->count += 1;

      if ( isPair )
      {

        hintmap->edge[indexInsert + 1] = *secondHintEdge;
        hintmap->count += 1;
      }
    }

    return;
  }
# 746 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_hintmap_build( CF2_HintMap hintmap,
                     CF2_ArrStack hStemHintArray,
                     CF2_ArrStack vStemHintArray,
                     CF2_HintMask hintMask,
                     CF2_F16Dot16 hintOrigin,
                     FT_Bool initialMap )
  {
    FT_Byte* maskPtr;

    CF2_Font font = hintmap->font;
    CF2_HintMaskRec tempHintMask;

    size_t bitCount, i;
    FT_Byte maskByte;



    if ( !initialMap && !cf2_hintmap_isValid( hintmap->initialHintMap ) )
    {


      cf2_hintmask_init( &tempHintMask, hintMask->error );
      cf2_hintmap_build( hintmap->initialHintMap,
                         hStemHintArray,
                         vStemHintArray,
                         &tempHintMask,
                         hintOrigin,
                         1 );
    }

    if ( !cf2_hintmask_isValid( hintMask ) )
    {

      cf2_hintmask_setAll( hintMask,
                           cf2_arrstack_size( hStemHintArray ) +
                             cf2_arrstack_size( vStemHintArray ) );
      if ( !cf2_hintmask_isValid( hintMask ) )
          return;
    }


    hintmap->count = 0;
    hintmap->lastIndex = 0;


    tempHintMask = *hintMask;
    maskPtr = cf2_hintmask_getMaskPtr( &tempHintMask );


    bitCount = cf2_arrstack_size( hStemHintArray );


    if ( bitCount > hintMask->bitCount )
        return;


    if ( font->blues.doEmBoxHints )
    {
      CF2_HintRec dummy;


      cf2_hint_initZero( &dummy );


      cf2_hintmap_insertHint( hintmap,
                              &font->blues.emBoxBottomEdge,
                              &dummy );

      cf2_hintmap_insertHint( hintmap,
                              &dummy,
                              &font->blues.emBoxTopEdge );
    }



    for ( i = 0, maskByte = 0x80; i < bitCount; i++ )
    {
      if ( maskByte & *maskPtr )
      {

        CF2_HintRec bottomHintEdge, topHintEdge;


        cf2_hint_init( &bottomHintEdge,
                       hStemHintArray,
                       i,
                       font,
                       hintOrigin,
                       hintmap->scale,
                       1 );
        cf2_hint_init( &topHintEdge,
                       hStemHintArray,
                       i,
                       font,
                       hintOrigin,
                       hintmap->scale,
                       0 );

        if ( cf2_hint_isLocked( &bottomHintEdge ) ||
             cf2_hint_isLocked( &topHintEdge ) ||
             cf2_blues_capture( &font->blues,
                                &bottomHintEdge,
                                &topHintEdge ) )
        {

          cf2_hintmap_insertHint( hintmap, &bottomHintEdge, &topHintEdge );

          *maskPtr &= ~maskByte;
        }
      }

      if ( ( i & 7 ) == 7 )
      {

        maskPtr++;
        maskByte = 0x80;
      }
      else
        maskByte >>= 1;
    }
# 890 "../../../libs/freetype/src/cff/cf2hints.c"
    if ( initialMap )
    {




      if ( hintmap->count == 0 ||
           hintmap->edge[0].csCoord > 0 ||
           hintmap->edge[hintmap->count - 1].csCoord < 0 )
      {



        CF2_HintRec edge, invalid;


        cf2_hint_initZero( &edge );

        edge.flags = CF2_GhostBottom |
                     CF2_Locked |
                     CF2_Synthetic;
        edge.scale = hintmap->scale;

        cf2_hint_initZero( &invalid );
        cf2_hintmap_insertHint( hintmap, &edge, &invalid );
      }
    }
    else
    {


      maskPtr = cf2_hintmask_getMaskPtr( &tempHintMask );

      for ( i = 0, maskByte = 0x80; i < bitCount; i++ )
      {
        if ( maskByte & *maskPtr )
        {
          CF2_HintRec bottomHintEdge, topHintEdge;


          cf2_hint_init( &bottomHintEdge,
                         hStemHintArray,
                         i,
                         font,
                         hintOrigin,
                         hintmap->scale,
                         1 );
          cf2_hint_init( &topHintEdge,
                         hStemHintArray,
                         i,
                         font,
                         hintOrigin,
                         hintmap->scale,
                         0 );

          cf2_hintmap_insertHint( hintmap, &bottomHintEdge, &topHintEdge );
        }

        if ( ( i & 7 ) == 7 )
        {

          maskPtr++;
          maskByte = 0x80;
        }
        else
          maskByte >>= 1;
      }
    }
# 969 "../../../libs/freetype/src/cff/cf2hints.c"
    cf2_hintmap_adjustHints( hintmap );



    if ( !initialMap )
    {
      for ( i = 0; i < hintmap->count; i++ )
      {
        if ( !cf2_hint_isSynthetic( &hintmap->edge[i] ) )
        {


          CF2_StemHint stemhint = (CF2_StemHint)
                          cf2_arrstack_getPointer( hStemHintArray,
                                                   hintmap->edge[i].index );


          if ( cf2_hint_isTop( &hintmap->edge[i] ) )
            stemhint->maxDS = hintmap->edge[i].dsCoord;
          else
            stemhint->minDS = hintmap->edge[i].dsCoord;

          stemhint->used = 1;
        }
      }
    }


    hintmap->isValid = 1;


    cf2_hintmask_setNew( hintMask, 0 );
  }


  static void
  cf2_glyphpath_init( CF2_GlyphPath glyphpath,
                      CF2_Font font,
                      CF2_OutlineCallbacks callbacks,
                      CF2_F16Dot16 scaleY,

                      CF2_ArrStack hStemHintArray,
                      CF2_ArrStack vStemHintArray,
                      CF2_HintMask hintMask,
                      CF2_F16Dot16 hintOriginY,
                      const CF2_Blues blues,
                      const FT_Vector* fractionalTranslation )
  {
    memset( glyphpath, 0, (FT_Offset)(sizeof ( *(glyphpath) )) );

    glyphpath->font = font;
    glyphpath->callbacks = callbacks;

    cf2_arrstack_init( &glyphpath->hintMoves,
                       font->memory,
                       &font->error,
                       sizeof ( CF2_HintMoveRec ) );

    cf2_hintmap_init( &glyphpath->initialHintMap,
                      font,
                      &glyphpath->initialHintMap,
                      &glyphpath->hintMoves,
                      scaleY );
    cf2_hintmap_init( &glyphpath->firstHintMap,
                      font,
                      &glyphpath->initialHintMap,
                      &glyphpath->hintMoves,
                      scaleY );
    cf2_hintmap_init( &glyphpath->hintMap,
                      font,
                      &glyphpath->initialHintMap,
                      &glyphpath->hintMoves,
                      scaleY );

    glyphpath->scaleX = font->innerTransform.a;
    glyphpath->scaleC = font->innerTransform.c;
    glyphpath->scaleY = font->innerTransform.d;

    glyphpath->fractionalTranslation = *fractionalTranslation;





    glyphpath->hStemHintArray = hStemHintArray;
    glyphpath->vStemHintArray = vStemHintArray;
    glyphpath->hintMask = hintMask;
    glyphpath->hintOriginY = hintOriginY;
    glyphpath->blues = blues;
    glyphpath->darken = font->darkened;
    glyphpath->xOffset = font->darkenX;
    glyphpath->yOffset = font->darkenY;
    glyphpath->miterLimit = 2 * ( (( (glyphpath->xOffset) < 0 ? -(glyphpath->xOffset) : (glyphpath->xOffset) )) > (( (glyphpath->yOffset) < 0 ? -(glyphpath->yOffset) : (glyphpath->yOffset) )) ? (( (glyphpath->xOffset) < 0 ? -(glyphpath->xOffset) : (glyphpath->xOffset) )) : (( (glyphpath->yOffset) < 0 ? -(glyphpath->yOffset) : (glyphpath->yOffset) )) )

                                                                         ;


    glyphpath->snapThreshold = ( (CF2_F16Dot16)( (0.1f) * 65536.0 + 0.5 ) );

    glyphpath->moveIsPending = 1;
    glyphpath->pathIsOpen = 0;
    glyphpath->pathIsClosing = 0;
    glyphpath->elemIsQueued = 0;
  }


  static void
  cf2_glyphpath_finalize( CF2_GlyphPath glyphpath )
  {
    cf2_arrstack_finalize( &glyphpath->hintMoves );
  }
# 1088 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_glyphpath_hintPoint( CF2_GlyphPath glyphpath,
                           CF2_HintMap hintmap,
                           FT_Vector* ppt,
                           CF2_F16Dot16 x,
                           CF2_F16Dot16 y )
  {
    FT_Vector pt;


    pt.x = FT_MulFix_arm( (FT_Int32)(glyphpath->scaleX), (FT_Int32)(x) ) +
             FT_MulFix_arm( (FT_Int32)(glyphpath->scaleC), (FT_Int32)(y) );
    pt.y = cf2_hintmap_map( hintmap, y );

    ppt->x = FT_MulFix_arm( (FT_Int32)(glyphpath->font->outerTransform.a), (FT_Int32)(pt.x) ) +
               FT_MulFix_arm( (FT_Int32)(glyphpath->font->outerTransform.c), (FT_Int32)(pt.y) ) +
               glyphpath->fractionalTranslation.x;
    ppt->y = FT_MulFix_arm( (FT_Int32)(glyphpath->font->outerTransform.b), (FT_Int32)(pt.x) ) +
               FT_MulFix_arm( (FT_Int32)(glyphpath->font->outerTransform.d), (FT_Int32)(pt.y) ) +
               glyphpath->fractionalTranslation.y;
  }
# 1118 "../../../libs/freetype/src/cff/cf2hints.c"
  static FT_Bool
  cf2_glyphpath_computeIntersection( CF2_GlyphPath glyphpath,
                                     const FT_Vector* u1,
                                     const FT_Vector* u2,
                                     const FT_Vector* v1,
                                     const FT_Vector* v2,
                                     FT_Vector* intersection )
  {
# 1153 "../../../libs/freetype/src/cff/cf2hints.c"
    FT_Vector u, v, w;
    CF2_F16Dot16 denominator, s;


    u.x = ( ( (u2->x - u1->x) + 0x10 ) >> 5 );
    u.y = ( ( (u2->y - u1->y) + 0x10 ) >> 5 );
    v.x = ( ( (v2->x - v1->x) + 0x10 ) >> 5 );
    v.y = ( ( (v2->y - v1->y) + 0x10 ) >> 5 );
    w.x = ( ( (v1->x - u1->x) + 0x10 ) >> 5 );
    w.y = ( ( (v1->y - u1->y) + 0x10 ) >> 5 );

    denominator = ( FT_MulFix_arm( (FT_Int32)(u.x), (FT_Int32)(v.y) ) - FT_MulFix_arm( (FT_Int32)(u.y), (FT_Int32)(v.x) ) );

    if ( denominator == 0 )
      return 0;

    s = FT_DivFix( ( FT_MulFix_arm( (FT_Int32)(w.x), (FT_Int32)(v.y) ) - FT_MulFix_arm( (FT_Int32)(w.y), (FT_Int32)(v.x) ) ), denominator );

    intersection->x = u1->x + FT_MulFix_arm( (FT_Int32)(s), (FT_Int32)(u2->x - u1->x) );
    intersection->y = u1->y + FT_MulFix_arm( (FT_Int32)(s), (FT_Int32)(u2->y - u1->y) );
# 1183 "../../../libs/freetype/src/cff/cf2hints.c"
    if ( u1->x == u2->x &&
         ( (intersection->x - u1->x) < 0 ? -(intersection->x - u1->x) : (intersection->x - u1->x) ) < glyphpath->snapThreshold )
      intersection->x = u1->x;
    if ( u1->y == u2->y &&
         ( (intersection->y - u1->y) < 0 ? -(intersection->y - u1->y) : (intersection->y - u1->y) ) < glyphpath->snapThreshold )
      intersection->y = u1->y;

    if ( v1->x == v2->x &&
         ( (intersection->x - v1->x) < 0 ? -(intersection->x - v1->x) : (intersection->x - v1->x) ) < glyphpath->snapThreshold )
      intersection->x = v1->x;
    if ( v1->y == v2->y &&
         ( (intersection->y - v1->y) < 0 ? -(intersection->y - v1->y) : (intersection->y - v1->y) ) < glyphpath->snapThreshold )
      intersection->y = v1->y;


    if ( ( (intersection->x - ( u2->x + v1->x ) / 2) < 0 ? -(intersection->x - ( u2->x + v1->x ) / 2) : (intersection->x - ( u2->x + v1->x ) / 2) ) >
           glyphpath->miterLimit ||
         ( (intersection->y - ( u2->y + v1->y ) / 2) < 0 ? -(intersection->y - ( u2->y + v1->y ) / 2) : (intersection->y - ( u2->y + v1->y ) / 2) ) >
           glyphpath->miterLimit )
      return 0;

    return 1;
  }
# 1231 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_glyphpath_pushPrevElem( CF2_GlyphPath glyphpath,
                              CF2_HintMap hintmap,
                              FT_Vector* nextP0,
                              FT_Vector nextP1,
                              FT_Bool close )
  {
    CF2_CallbackParamsRec params;

    FT_Vector* prevP0;
    FT_Vector* prevP1;

    FT_Vector intersection = { 0, 0 };
    FT_Bool useIntersection = 0;


    do { } while ( 0 )
                                                          ;

    if ( glyphpath->prevElemOp == CF2_PathOpLineTo )
    {
      prevP0 = &glyphpath->prevElemP0;
      prevP1 = &glyphpath->prevElemP1;
    }
    else
    {
      prevP0 = &glyphpath->prevElemP2;
      prevP1 = &glyphpath->prevElemP3;
    }




    if ( prevP1->x != nextP0->x || prevP1->y != nextP0->y )
    {


      useIntersection = cf2_glyphpath_computeIntersection( glyphpath,
                                                           prevP0,
                                                           prevP1,
                                                           nextP0,
                                                           &nextP1,
                                                           &intersection );
      if ( useIntersection )
      {


        *prevP1 = intersection;
      }
    }

    params.pt0 = glyphpath->currentDS;

    switch( glyphpath->prevElemOp )
    {
    case CF2_PathOpLineTo:
      params.op = CF2_PathOpLineTo;



      if ( close )
      {

        cf2_glyphpath_hintPoint( glyphpath,
                                 &glyphpath->firstHintMap,
                                 &params.pt1,
                                 glyphpath->prevElemP1.x,
                                 glyphpath->prevElemP1.y );
      }
      else
      {
        cf2_glyphpath_hintPoint( glyphpath,
                                 hintmap,
                                 &params.pt1,
                                 glyphpath->prevElemP1.x,
                                 glyphpath->prevElemP1.y );
      }


      if ( params.pt0.x != params.pt1.x || params.pt0.y != params.pt1.y )
      {
        glyphpath->callbacks->lineTo( glyphpath->callbacks, &params );

        glyphpath->currentDS = params.pt1;
      }
      break;

    case CF2_PathOpCubeTo:
      params.op = CF2_PathOpCubeTo;


      cf2_glyphpath_hintPoint( glyphpath,
                               hintmap,
                               &params.pt1,
                               glyphpath->prevElemP1.x,
                               glyphpath->prevElemP1.y );
      cf2_glyphpath_hintPoint( glyphpath,
                               hintmap,
                               &params.pt2,
                               glyphpath->prevElemP2.x,
                               glyphpath->prevElemP2.y );
      cf2_glyphpath_hintPoint( glyphpath,
                               hintmap,
                               &params.pt3,
                               glyphpath->prevElemP3.x,
                               glyphpath->prevElemP3.y );

      glyphpath->callbacks->cubeTo( glyphpath->callbacks, &params );

      glyphpath->currentDS = params.pt3;

      break;
    }

    if ( !useIntersection || close )
    {





      if ( close )
      {


        cf2_glyphpath_hintPoint( glyphpath,
                                 &glyphpath->firstHintMap,
                                 &params.pt1,
                                 nextP0->x,
                                 nextP0->y );
      }
      else
      {
        cf2_glyphpath_hintPoint( glyphpath,
                                 hintmap,
                                 &params.pt1,
                                 nextP0->x,
                                 nextP0->y );
      }

      if ( params.pt1.x != glyphpath->currentDS.x ||
           params.pt1.y != glyphpath->currentDS.y )
      {

        params.op = CF2_PathOpLineTo;
        params.pt0 = glyphpath->currentDS;


        glyphpath->callbacks->lineTo( glyphpath->callbacks, &params );

        glyphpath->currentDS = params.pt1;
      }
    }

    if ( useIntersection )
    {

      *nextP0 = intersection;
    }
  }




  static void
  cf2_glyphpath_pushMove( CF2_GlyphPath glyphpath,
                          FT_Vector start )
  {
    CF2_CallbackParamsRec params;


    params.op = CF2_PathOpMoveTo;
    params.pt0 = glyphpath->currentDS;



    if ( !cf2_hintmap_isValid( &glyphpath->hintMap ) )
    {


      cf2_glyphpath_moveTo( glyphpath,
                            glyphpath->start.x,
                            glyphpath->start.y );
    }

    cf2_glyphpath_hintPoint( glyphpath,
                             &glyphpath->hintMap,
                             &params.pt1,
                             start.x,
                             start.y );


    glyphpath->callbacks->moveTo( glyphpath->callbacks, &params );

    glyphpath->currentDS = params.pt1;
    glyphpath->offsetStart0 = start;
  }
# 1440 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_glyphpath_computeOffset( CF2_GlyphPath glyphpath,
                               CF2_F16Dot16 x1,
                               CF2_F16Dot16 y1,
                               CF2_F16Dot16 x2,
                               CF2_F16Dot16 y2,
                               CF2_F16Dot16* x,
                               CF2_F16Dot16* y )
  {
    CF2_F16Dot16 dx = x2 - x1;
    CF2_F16Dot16 dy = y2 - y1;




    if ( glyphpath->font->reverseWinding )
    {
      dx = -dx;
      dy = -dy;
    }

    *x = *y = 0;

    if ( !glyphpath->darken )
        return;


    glyphpath->callbacks->windingMomentum +=
      cf2_getWindingMomentum( x1, y1, x2, y2 );


    if ( dx >= 0 )
    {
      if ( dy >= 0 )
      {


        if ( dx > 2 * dy )
        {

          *x = 0;
          *y = 0;
        }
        else if ( dy > 2 * dx )
        {

          *x = glyphpath->xOffset;
          *y = glyphpath->yOffset;
        }
        else
        {

          *x = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->xOffset) )
                                              ;
          *y = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (1.0 - 0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->yOffset) )
                                              ;
        }
      }
      else
      {


        if ( dx > -2 * dy )
        {

          *x = 0;
          *y = 0;
        }
        else if ( -dy > 2 * dx )
        {

          *x = -glyphpath->xOffset;
          *y = glyphpath->yOffset;
        }
        else
        {

          *x = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (-0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->xOffset) )
                                              ;
          *y = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (1.0 - 0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->yOffset) )
                                              ;
        }
      }
    }
    else
    {
      if ( dy >= 0 )
      {


        if ( -dx > 2 * dy )
        {

          *x = 0;
          *y = 2 * glyphpath->yOffset;
        }
        else if ( dy > -2 * dx )
        {

          *x = glyphpath->xOffset;
          *y = glyphpath->yOffset;
        }
        else
        {

          *x = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->xOffset) )
                                              ;
          *y = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (1.0 + 0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->yOffset) )
                                              ;
        }
      }
      else
      {


        if ( -dx > -2 * dy )
        {

          *x = 0;
          *y = 2 * glyphpath->yOffset;
        }
        else if ( -dy > -2 * dx )
        {

          *x = -glyphpath->xOffset;
          *y = glyphpath->yOffset;
        }
        else
        {

          *x = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (-0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->xOffset) )
                                              ;
          *y = FT_MulFix_arm( (FT_Int32)(( (CF2_F16Dot16)( (1.0 + 0.7) * 65536.0 + 0.5 ) )), (FT_Int32)(glyphpath->yOffset) )
                                              ;
        }
      }
    }
  }
# 1590 "../../../libs/freetype/src/cff/cf2hints.c"
  static void
  cf2_glyphpath_moveTo( CF2_GlyphPath glyphpath,
                        CF2_F16Dot16 x,
                        CF2_F16Dot16 y )
  {
    cf2_glyphpath_closeOpenPath( glyphpath );




    glyphpath->currentCS.x = glyphpath->start.x = x;
    glyphpath->currentCS.y = glyphpath->start.y = y;

    glyphpath->moveIsPending = 1;


    if ( !cf2_hintmap_isValid( &glyphpath->hintMap ) ||
         cf2_hintmask_isNew( glyphpath->hintMask ) )
      cf2_hintmap_build( &glyphpath->hintMap,
                         glyphpath->hStemHintArray,
                         glyphpath->vStemHintArray,
                         glyphpath->hintMask,
                         glyphpath->hintOriginY,
                         0 );


    glyphpath->firstHintMap = glyphpath->hintMap;
  }


  static void
  cf2_glyphpath_lineTo( CF2_GlyphPath glyphpath,
                        CF2_F16Dot16 x,
                        CF2_F16Dot16 y )
  {
    CF2_F16Dot16 xOffset, yOffset;
    FT_Vector P0, P1;
    FT_Bool newHintMap;
# 1637 "../../../libs/freetype/src/cff/cf2hints.c"
    newHintMap = cf2_hintmask_isNew( glyphpath->hintMask ) &&
                 !glyphpath->pathIsClosing;
# 1657 "../../../libs/freetype/src/cff/cf2hints.c"
    if ( glyphpath->currentCS.x == x &&
         glyphpath->currentCS.y == y &&
         !newHintMap )







      return;

    cf2_glyphpath_computeOffset( glyphpath,
                                 glyphpath->currentCS.x,
                                 glyphpath->currentCS.y,
                                 x,
                                 y,
                                 &xOffset,
                                 &yOffset );


    P0.x = glyphpath->currentCS.x + xOffset;
    P0.y = glyphpath->currentCS.y + yOffset;
    P1.x = x + xOffset;
    P1.y = y + yOffset;

    if ( glyphpath->moveIsPending )
    {

      cf2_glyphpath_pushMove( glyphpath, P0 );

      glyphpath->moveIsPending = 0;
      glyphpath->pathIsOpen = 1;

      glyphpath->offsetStart1 = P1;
    }

    if ( glyphpath->elemIsQueued )
    {
      do { } while ( 0 )
                                                             ;

      cf2_glyphpath_pushPrevElem( glyphpath,
                                  &glyphpath->hintMap,
                                  &P0,
                                  P1,
                                  0 );
    }


    glyphpath->elemIsQueued = 1;
    glyphpath->prevElemOp = CF2_PathOpLineTo;
    glyphpath->prevElemP0 = P0;
    glyphpath->prevElemP1 = P1;


    if ( newHintMap )
      cf2_hintmap_build( &glyphpath->hintMap,
                         glyphpath->hStemHintArray,
                         glyphpath->vStemHintArray,
                         glyphpath->hintMask,
                         glyphpath->hintOriginY,
                         0 );

    glyphpath->currentCS.x = x;
    glyphpath->currentCS.y = y;
  }


  static void
  cf2_glyphpath_curveTo( CF2_GlyphPath glyphpath,
                         CF2_F16Dot16 x1,
                         CF2_F16Dot16 y1,
                         CF2_F16Dot16 x2,
                         CF2_F16Dot16 y2,
                         CF2_F16Dot16 x3,
                         CF2_F16Dot16 y3 )
  {
    CF2_F16Dot16 xOffset1, yOffset1, xOffset3, yOffset3;
    FT_Vector P0, P1, P2, P3;



    cf2_glyphpath_computeOffset( glyphpath,
                                 glyphpath->currentCS.x,
                                 glyphpath->currentCS.y,
                                 x1,
                                 y1,
                                 &xOffset1,
                                 &yOffset1 );
    cf2_glyphpath_computeOffset( glyphpath,
                                 x2,
                                 y2,
                                 x3,
                                 y3,
                                 &xOffset3,
                                 &yOffset3 );


    glyphpath->callbacks->windingMomentum +=
      cf2_getWindingMomentum( x1, y1, x2, y2 );


    P0.x = glyphpath->currentCS.x + xOffset1;
    P0.y = glyphpath->currentCS.y + yOffset1;
    P1.x = x1 + xOffset1;
    P1.y = y1 + yOffset1;

    P2.x = x2 + xOffset3;
    P2.y = y2 + yOffset3;
    P3.x = x3 + xOffset3;
    P3.y = y3 + yOffset3;

    if ( glyphpath->moveIsPending )
    {

      cf2_glyphpath_pushMove( glyphpath, P0 );

      glyphpath->moveIsPending = 0;
      glyphpath->pathIsOpen = 1;

      glyphpath->offsetStart1 = P1;
    }

    if ( glyphpath->elemIsQueued )
    {
      do { } while ( 0 )
                                                             ;

      cf2_glyphpath_pushPrevElem( glyphpath,
                                  &glyphpath->hintMap,
                                  &P0,
                                  P1,
                                  0 );
    }


    glyphpath->elemIsQueued = 1;
    glyphpath->prevElemOp = CF2_PathOpCubeTo;
    glyphpath->prevElemP0 = P0;
    glyphpath->prevElemP1 = P1;
    glyphpath->prevElemP2 = P2;
    glyphpath->prevElemP3 = P3;


    if ( cf2_hintmask_isNew( glyphpath->hintMask ) )
      cf2_hintmap_build( &glyphpath->hintMap,
                         glyphpath->hStemHintArray,
                         glyphpath->vStemHintArray,
                         glyphpath->hintMask,
                         glyphpath->hintOriginY,
                         0 );

    glyphpath->currentCS.x = x3;
    glyphpath->currentCS.y = y3;
  }


  static void
  cf2_glyphpath_closeOpenPath( CF2_GlyphPath glyphpath )
  {
    if ( glyphpath->pathIsOpen )
    {





      glyphpath->pathIsClosing = 1;

      cf2_glyphpath_lineTo( glyphpath,
                            glyphpath->start.x,
                            glyphpath->start.y );


      if ( glyphpath->elemIsQueued )
        cf2_glyphpath_pushPrevElem( glyphpath,
                                    &glyphpath->hintMap,
                                    &glyphpath->offsetStart0,
                                    glyphpath->offsetStart1,
                                    1 );


      glyphpath->moveIsPending = 1;
      glyphpath->pathIsOpen = 0;
      glyphpath->pathIsClosing = 0;
      glyphpath->elemIsQueued = 0;
    }
  }
# 37 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2intrp.c" 1
# 44 "../../../libs/freetype/src/cff/cf2intrp.c"
# 1 "../../../libs/freetype/src/cff/cf2stack.h" 1
# 43 "../../../libs/freetype/src/cff/cf2stack.h"




  typedef struct CF2_StackNumber_
  {
    union
    {
      CF2_F16Dot16 r;
      CF2_Frac f;
      FT_Fast i;
    } u;

    CF2_NumberType type;

  } CF2_StackNumber;


  typedef struct CF2_StackRec_
  {
    FT_Memory memory;
    FT_Error* error;
    CF2_StackNumber buffer[48];
    CF2_StackNumber* top;

  } CF2_StackRec, *CF2_Stack;


  static CF2_Stack
  cf2_stack_init( FT_Memory memory,
                  FT_Error* error );
  static void
  cf2_stack_free( CF2_Stack stack );

  static FT_UFast
  cf2_stack_count( CF2_Stack stack );

  static void
  cf2_stack_pushInt( CF2_Stack stack,
                     FT_Fast val );
  static void
  cf2_stack_pushFixed( CF2_Stack stack,
                       CF2_F16Dot16 val );

  static FT_Fast
  cf2_stack_popInt( CF2_Stack stack );
  static CF2_F16Dot16
  cf2_stack_popFixed( CF2_Stack stack );

  static CF2_F16Dot16
  cf2_stack_getReal( CF2_Stack stack,
                     FT_UFast idx );

  static void
  cf2_stack_clear( CF2_Stack stack );



# 45 "../../../libs/freetype/src/cff/cf2intrp.c" 2
# 67 "../../../libs/freetype/src/cff/cf2intrp.c"
  static void
  cf2_hintmask_init( CF2_HintMask hintmask,
                     FT_Error* error )
  {
    memset( hintmask, 0, (FT_Offset)(sizeof ( *(hintmask) )) );

    hintmask->error = error;
  }


  static FT_Bool
  cf2_hintmask_isValid( const CF2_HintMask hintmask )
  {
    return hintmask->isValid;
  }


  static FT_Bool
  cf2_hintmask_isNew( const CF2_HintMask hintmask )
  {
    return hintmask->isNew;
  }


  static void
  cf2_hintmask_setNew( CF2_HintMask hintmask,
                       FT_Bool val )
  {
    hintmask->isNew = val;
  }





  static FT_Byte*
  cf2_hintmask_getMaskPtr( CF2_HintMask hintmask )
  {
    return hintmask->mask;
  }


  static size_t
  cf2_hintmask_setCounts( CF2_HintMask hintmask,
                          size_t bitCount )
  {
    if ( bitCount > CF2_MAX_HINTS )
    {

      cf2_setError( hintmask->error, CF2_Err_Invalid_Glyph_Format );
      return 0;
    }

    hintmask->bitCount = bitCount;
    hintmask->byteCount = ( hintmask->bitCount + 7 ) / 8;

    hintmask->isValid = 1;
    hintmask->isNew = 1;

    return bitCount;
  }




  static void
  cf2_hintmask_read( CF2_HintMask hintmask,
                     CF2_Buffer charstring,
                     size_t bitCount )
  {
    size_t i;
# 148 "../../../libs/freetype/src/cff/cf2intrp.c"
    if ( cf2_hintmask_setCounts( hintmask, bitCount ) == 0 )
      return;

    do { } while ( 0 );

    do { } while ( 0 );


    for ( i = 0; i < hintmask->byteCount; i++ )
    {
      hintmask->mask[i] = (FT_Byte)cf2_buf_readByte( charstring );
      do { } while ( 0 );
    }

    do { } while ( 0 );
# 171 "../../../libs/freetype/src/cff/cf2intrp.c"
  }


  static void
  cf2_hintmask_setAll( CF2_HintMask hintmask,
                       size_t bitCount )
  {
    size_t i;
    FT_UFast mask = ( 1 << ( -(FT_Fast)bitCount & 7 ) ) - 1;



    if ( cf2_hintmask_setCounts( hintmask, bitCount ) == 0 )
      return;

    do { } while ( 0 );
    do { } while ( 0 )
                                                                           ;


    for ( i = 0; i < hintmask->byteCount; i++ )
      hintmask->mask[i] = 0xFF;



    hintmask->mask[hintmask->byteCount - 1] &= ~mask;
  }



  enum
  {
    cf2_cmdRESERVED_0,
    cf2_cmdHSTEM,
    cf2_cmdRESERVED_2,
    cf2_cmdVSTEM,
    cf2_cmdVMOVETO,
    cf2_cmdRLINETO,
    cf2_cmdHLINETO,
    cf2_cmdVLINETO,
    cf2_cmdRRCURVETO,
    cf2_cmdRESERVED_9,
    cf2_cmdCALLSUBR,
    cf2_cmdRETURN,
    cf2_cmdESC,
    cf2_cmdRESERVED_13,
    cf2_cmdENDCHAR,
    cf2_cmdRESERVED_15,
    cf2_cmdRESERVED_16,
    cf2_cmdRESERVED_17,
    cf2_cmdHSTEMHM,
    cf2_cmdHINTMASK,
    cf2_cmdCNTRMASK,
    cf2_cmdRMOVETO,
    cf2_cmdHMOVETO,
    cf2_cmdVSTEMHM,
    cf2_cmdRCURVELINE,
    cf2_cmdRLINECURVE,
    cf2_cmdVVCURVETO,
    cf2_cmdHHCURVETO,
    cf2_cmdEXTENDEDNMBR,
    cf2_cmdCALLGSUBR,
    cf2_cmdVHCURVETO,
    cf2_cmdHVCURVETO
  };

  enum
  {
    cf2_escDOTSECTION,
    cf2_escRESERVED_1,
    cf2_escRESERVED_2,
    cf2_escAND,
    cf2_escOR,
    cf2_escNOT,
    cf2_escRESERVED_6,
    cf2_escRESERVED_7,
    cf2_escRESERVED_8,
    cf2_escABS,
    cf2_escADD,
    cf2_escSUB,
    cf2_escDIV,
    cf2_escRESERVED_13,
    cf2_escNEG,
    cf2_escEQ,
    cf2_escRESERVED_16,
    cf2_escRESERVED_17,
    cf2_escDROP,
    cf2_escRESERVED_19,
    cf2_escPUT,
    cf2_escGET,
    cf2_escIFELSE,
    cf2_escRANDOM,
    cf2_escMUL,
    cf2_escRESERVED_25,
    cf2_escSQRT,
    cf2_escDUP,
    cf2_escEXCH,
    cf2_escINDEX,
    cf2_escROLL,
    cf2_escRESERVED_31,
    cf2_escRESERVED_32,
    cf2_escRESERVED_33,
    cf2_escHFLEX,
    cf2_escFLEX,
    cf2_escHFLEX1,
    cf2_escFLEX1
  };



  static void
  cf2_doStems( const CF2_Font font,
               CF2_Stack opStack,
               CF2_ArrStack stemHintArray,
               CF2_F16Dot16* width,
               FT_Bool* haveWidth,
               CF2_F16Dot16 hintOffset )
  {
    FT_UFast i;
    FT_UFast count = cf2_stack_count( opStack );
    FT_Bool hasWidthArg = (FT_Bool)( count & 1 );


    CF2_F16Dot16 position = hintOffset;

    if ( hasWidthArg && ! *haveWidth )
      *width = cf2_stack_getReal( opStack, 0 ) +
                 cf2_getNominalWidthX( font->decoder );

    if ( font->decoder->width_only )
      goto exit;

    for ( i = hasWidthArg ? 1 : 0; i < count; i += 2 )
    {

      CF2_StemHintRec stemhint;


      stemhint.min =
        position += cf2_stack_getReal( opStack, i );
      stemhint.max =
        position += cf2_stack_getReal( opStack, i + 1 );

      stemhint.used = 0;
      stemhint.maxDS =
      stemhint.minDS = 0;

      cf2_arrstack_push( stemHintArray, &stemhint );
    }

    cf2_stack_clear( opStack );

  exit:

    *haveWidth = 1;
  }


  static void
  cf2_doFlex( CF2_Stack opStack,
              CF2_F16Dot16* curX,
              CF2_F16Dot16* curY,
              CF2_GlyphPath glyphPath,
              const FT_Bool* readFromStack,
              FT_Bool doConditionalLastRead )
  {
    CF2_F16Dot16 vals[14];
    FT_UFast index;
    FT_Bool isHFlex;
    FT_Fast top, i, j;


    vals[0] = *curX;
    vals[1] = *curY;
    index = 0;
    isHFlex = readFromStack[9] == 0;
    top = isHFlex ? 9 : 10;

    for ( i = 0; i < top; i++ )
    {
      vals[i + 2] = vals[i];
      if ( readFromStack[i] )
        vals[i + 2] += cf2_stack_getReal( opStack, index++ );
    }

    if ( isHFlex )
      vals[9 + 2] = *curY;

    if ( doConditionalLastRead )
    {
      FT_Bool lastIsX = (FT_Bool)( ( (vals[10] - *curX) < 0 ? -(vals[10] - *curX) : (vals[10] - *curX) ) >
                                        ( (vals[11] - *curY) < 0 ? -(vals[11] - *curY) : (vals[11] - *curY) ) );
      CF2_F16Dot16 lastVal = cf2_stack_getReal( opStack, index );


      if ( lastIsX )
      {
        vals[12] = vals[10] + lastVal;
        vals[13] = *curY;
      }
      else
      {
        vals[12] = *curX;
        vals[13] = vals[11] + lastVal;
      }
    }
    else
    {
      if ( readFromStack[10] )
        vals[12] = vals[10] + cf2_stack_getReal( opStack, index++ );
      else
        vals[12] = *curX;

      if ( readFromStack[11] )
        vals[13] = vals[11] + cf2_stack_getReal( opStack, index );
      else
        vals[13] = *curY;
    }

    for ( j = 0; j < 2; j++ )
      cf2_glyphpath_curveTo( glyphPath, vals[j * 6 + 2],
                                        vals[j * 6 + 3],
                                        vals[j * 6 + 4],
                                        vals[j * 6 + 5],
                                        vals[j * 6 + 6],
                                        vals[j * 6 + 7] );

    cf2_stack_clear( opStack );

    *curX = vals[12];
    *curY = vals[13];
  }
# 421 "../../../libs/freetype/src/cff/cf2intrp.c"
  static void
  cf2_interpT2CharString( CF2_Font font,
                          CF2_Buffer buf,
                          CF2_OutlineCallbacks callbacks,
                          const FT_Vector* translation,
                          FT_Bool doingSeac,
                          CF2_F16Dot16 curX,
                          CF2_F16Dot16 curY,
                          CF2_F16Dot16* width )
  {

    FT_Error lastError = FT_Err_Ok;


    CFF_Decoder* decoder = font->decoder;

    FT_Error* error = &font->error;
    FT_Memory memory = font->memory;

    CF2_F16Dot16 scaleY = font->innerTransform.d;
    CF2_F16Dot16 nominalWidthX = cf2_getNominalWidthX( decoder );


    CF2_F16Dot16 hintOriginY = curY;

    CF2_Stack opStack = ((void *)0);
    FT_Byte op1;


    FT_UInt32 instructionLimit = 20000000UL;

    CF2_ArrStackRec subrStack;

    FT_Bool haveWidth;
    CF2_Buffer charstring = ((void *)0);

    FT_Fast charstringIndex = -1;




    CF2_ArrStackRec hStemHintArray;
    CF2_ArrStackRec vStemHintArray;

    CF2_HintMaskRec hintMask;
    CF2_GlyphPathRec glyphPath;



    cf2_arrstack_init( &subrStack,
                       memory,
                       error,
                       sizeof ( CF2_BufferRec ) );
    cf2_arrstack_init( &hStemHintArray,
                       memory,
                       error,
                       sizeof ( CF2_StemHintRec ) );
    cf2_arrstack_init( &vStemHintArray,
                       memory,
                       error,
                       sizeof ( CF2_StemHintRec ) );


    cf2_hintmask_init( &hintMask, error );






    cf2_glyphpath_init( &glyphPath,
                        font,
                        callbacks,
                        scaleY,

                        &hStemHintArray,
                        &vStemHintArray,
                        &hintMask,
                        hintOriginY,
                        &font->blues,
                        translation );
# 519 "../../../libs/freetype/src/cff/cf2intrp.c"
    haveWidth = 0;
    *width = cf2_getDefaultWidthX( decoder );
# 530 "../../../libs/freetype/src/cff/cf2intrp.c"
    opStack = cf2_stack_init( memory, error );
    if ( !opStack )
    {
      lastError = CF2_Err_Out_Of_Memory;
      goto exit;
    }





    cf2_arrstack_setCount( &subrStack, 16 + 1 );

    charstring = (CF2_Buffer)cf2_arrstack_getBuffer( &subrStack );
    *charstring = *buf;

    charstringIndex = 0;


    if ( *error )
      goto exit;


    while ( 1 )
    {
      if ( cf2_buf_isEnd( charstring ) )
      {


        if ( charstringIndex )
          op1 = cf2_cmdRETURN;
        else
          op1 = cf2_cmdENDCHAR;
      }
      else
        op1 = (FT_Byte)cf2_buf_readByte( charstring );


      if ( *error )
        goto exit;

      instructionLimit--;
      if ( instructionLimit == 0 )
      {
        lastError = CF2_Err_Invalid_Glyph_Format;
        goto exit;
      }

      switch( op1 )
      {
      case cf2_cmdRESERVED_0:
      case cf2_cmdRESERVED_2:
      case cf2_cmdRESERVED_9:
      case cf2_cmdRESERVED_13:
      case cf2_cmdRESERVED_15:
      case cf2_cmdRESERVED_16:
      case cf2_cmdRESERVED_17:

        do { } while ( 0 );
        break;

      case cf2_cmdHSTEMHM:
      case cf2_cmdHSTEM:
        do { } while ( 0 );


        if ( cf2_hintmask_isValid( &hintMask ) )
        {
          do { } while ( 0 )
                                                          ;
          break;
        }

        cf2_doStems( font,
                     opStack,
                     &hStemHintArray,
                     width,
                     &haveWidth,
                     0 );

        if ( font->decoder->width_only )
            goto exit;

        break;

      case cf2_cmdVSTEMHM:
      case cf2_cmdVSTEM:
        do { } while ( 0 );


        if ( cf2_hintmask_isValid( &hintMask ) )
        {
          do { } while ( 0 )
                                                        ;
          break;
        }

        cf2_doStems( font,
                     opStack,
                     &vStemHintArray,
                     width,
                     &haveWidth,
                     0 );

        if ( font->decoder->width_only )
            goto exit;

        break;

      case cf2_cmdVMOVETO:
        do { } while ( 0 );

        if ( cf2_stack_count( opStack ) > 1 && !haveWidth )
          *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;


        haveWidth = 1;

        if ( font->decoder->width_only )
            goto exit;

        curY += cf2_stack_popFixed( opStack );

        cf2_glyphpath_moveTo( &glyphPath, curX, curY );

        break;

      case cf2_cmdRLINETO:
        {
          FT_UFast index;
          FT_UFast count = cf2_stack_count( opStack );


          do { } while ( 0 );

          for ( index = 0; index < count; index += 2 )
          {
            curX += cf2_stack_getReal( opStack, index + 0 );
            curY += cf2_stack_getReal( opStack, index + 1 );

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdHLINETO:
      case cf2_cmdVLINETO:
        {
          FT_UFast index;
          FT_UFast count = cf2_stack_count( opStack );

          FT_Bool isX = op1 == cf2_cmdHLINETO;


          do { } while ( 0 );

          for ( index = 0; index < count; index++ )
          {
            CF2_F16Dot16 v = cf2_stack_getReal( opStack, index );


            if ( isX )
              curX += v;
            else
              curY += v;

            isX = !isX;

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdRCURVELINE:
      case cf2_cmdRRCURVETO:
        {
          FT_UFast count = cf2_stack_count( opStack );
          FT_UFast index = 0;


          do { } while ( 0 )
                                                                  ;

          while ( index + 6 <= count )
          {
            CF2_F16Dot16 x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
            CF2_F16Dot16 y1 = cf2_stack_getReal( opStack, index + 1 ) + curY;
            CF2_F16Dot16 x2 = cf2_stack_getReal( opStack, index + 2 ) + x1;
            CF2_F16Dot16 y2 = cf2_stack_getReal( opStack, index + 3 ) + y1;
            CF2_F16Dot16 x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
            CF2_F16Dot16 y3 = cf2_stack_getReal( opStack, index + 5 ) + y2;


            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX = x3;
            curY = y3;
            index += 6;
          }

          if ( op1 == cf2_cmdRCURVELINE )
          {
            curX += cf2_stack_getReal( opStack, index + 0 );
            curY += cf2_stack_getReal( opStack, index + 1 );

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdCALLGSUBR:
      case cf2_cmdCALLSUBR:
        {
          FT_Fast subrNum;


          do { } while ( 0 )
                                                              ;

          if ( charstringIndex > 16 )
          {

            lastError = CF2_Err_Invalid_Glyph_Format;
            goto exit;
          }


          charstring = (CF2_Buffer)
                         cf2_arrstack_getPointer(
                           &subrStack,
                           (size_t)charstringIndex + 1 );


          subrNum = cf2_stack_popInt( opStack );

          switch ( op1 )
          {
          case cf2_cmdCALLGSUBR:
            do { } while ( 0 )

                                              ;

            if ( cf2_initGlobalRegionBuffer( decoder,
                                             subrNum,
                                             charstring ) )
            {
              lastError = CF2_Err_Invalid_Glyph_Format;
              goto exit;
            }
            break;

          default:

            do { } while ( 0 )

                                              ;

            if ( cf2_initLocalRegionBuffer( decoder,
                                            subrNum,
                                            charstring ) )
            {
              lastError = CF2_Err_Invalid_Glyph_Format;
              goto exit;
            }
          }

          charstringIndex += 1;
        }
        continue;

      case cf2_cmdRETURN:
        do { } while ( 0 );

        if ( charstringIndex < 1 )
        {

          lastError = CF2_Err_Invalid_Glyph_Format;
          goto exit;
        }


        charstring = (CF2_Buffer)
                       cf2_arrstack_getPointer(
                         &subrStack,
                         (FT_UFast)--charstringIndex );
        continue;

      case cf2_cmdESC:
        {
          FT_Byte op2 = (FT_Byte)cf2_buf_readByte( charstring );


          switch ( op2 )
          {
          case cf2_escDOTSECTION:

            do { } while ( 0 );

            break;


          case cf2_escAND:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escOR:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escNOT:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escABS:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escADD:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escSUB:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escDIV:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escNEG:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escEQ:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escDROP:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escPUT:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escGET:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escIFELSE:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escRANDOM:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escMUL:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escSQRT:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escDUP:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escEXCH:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escINDEX:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escROLL:
            do { } while ( 0 );

            do { } while ( 0 );
            break;

          case cf2_escHFLEX:
            {
              static const FT_Bool readFromStack[12] =
              {
                1 , 0 ,
                1 , 1 ,
                1 , 0 ,
                1 , 0 ,
                1 , 0 ,
                1 , 0
              };


              do { } while ( 0 );

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          0 );
            }
            continue;

          case cf2_escFLEX:
            {
              static const FT_Bool readFromStack[12] =
              {
                1 , 1 ,
                1 , 1 ,
                1 , 1 ,
                1 , 1 ,
                1 , 1 ,
                1 , 1
              };


              do { } while ( 0 );

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          0 );
            }
            break;

          case cf2_escHFLEX1:
            {
              static const FT_Bool readFromStack[12] =
              {
                1 , 1 ,
                1 , 1 ,
                1 , 0 ,
                1 , 0 ,
                1 , 1 ,
                1 , 0
              };


              do { } while ( 0 );

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          0 );
            }
            continue;

          case cf2_escFLEX1:
            {
              static const FT_Bool readFromStack[12] =
              {
                1 , 1 ,
                1 , 1 ,
                1 , 1 ,
                1 , 1 ,
                1 , 1 ,
                0 , 0
              };


              do { } while ( 0 );

              cf2_doFlex( opStack,
                          &curX,
                          &curY,
                          &glyphPath,
                          readFromStack,
                          1 );
            }
            continue;

          case cf2_escRESERVED_1:
          case cf2_escRESERVED_2:
          case cf2_escRESERVED_6:
          case cf2_escRESERVED_7:
          case cf2_escRESERVED_8:
          case cf2_escRESERVED_13:
          case cf2_escRESERVED_16:
          case cf2_escRESERVED_17:
          case cf2_escRESERVED_19:
          case cf2_escRESERVED_25:
          case cf2_escRESERVED_31:
          case cf2_escRESERVED_32:
          case cf2_escRESERVED_33:
          default:
            do { } while ( 0 );

          };

        }
        break;

      case cf2_cmdENDCHAR:
        do { } while ( 0 );

        if ( cf2_stack_count( opStack ) == 1 ||
             cf2_stack_count( opStack ) == 5 )
        {
          if ( !haveWidth )
            *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;
        }


        haveWidth = 1;

        if ( font->decoder->width_only )
            goto exit;


        cf2_glyphpath_closeOpenPath( &glyphPath );

        if ( cf2_stack_count( opStack ) > 1 )
        {



          FT_Fast achar;
          FT_Fast bchar;
          CF2_BufferRec component;
          CF2_F16Dot16 dummyWidth;
          FT_Error error2;


          if ( doingSeac )
          {
            lastError = CF2_Err_Invalid_Glyph_Format;
            goto exit;
          }

          achar = cf2_stack_popInt( opStack );
          bchar = cf2_stack_popInt( opStack );

          curY = cf2_stack_popFixed( opStack );
          curX = cf2_stack_popFixed( opStack );

          error2 = cf2_getSeacComponent( decoder, achar, &component );
          if ( error2 )
          {
             lastError = error2;
             goto exit;
          }
          cf2_interpT2CharString( font,
                                  &component,
                                  callbacks,
                                  translation,
                                  1,
                                  curX,
                                  curY,
                                  &dummyWidth );
          cf2_freeSeacComponent( decoder, &component );

          error2 = cf2_getSeacComponent( decoder, bchar, &component );
          if ( error2 )
          {
            lastError = error2;
            goto exit;
          }
          cf2_interpT2CharString( font,
                                  &component,
                                  callbacks,
                                  translation,
                                  1,
                                  0,
                                  0,
                                  &dummyWidth );
          cf2_freeSeacComponent( decoder, &component );
        }
        goto exit;

      case cf2_cmdCNTRMASK:
      case cf2_cmdHINTMASK:


        do { } while ( 0 );


        if ( cf2_stack_count( opStack ) > 1 &&
             cf2_hintmask_isValid( &hintMask ) )
        {
          do { } while ( 0 );
          break;
        }



        cf2_doStems( font,
                     opStack,
                     &vStemHintArray,
                     width,
                     &haveWidth,
                     0 );

        if ( font->decoder->width_only )
            goto exit;

        if ( op1 == cf2_cmdHINTMASK )
        {

          cf2_hintmask_read( &hintMask,
                             charstring,
                             cf2_arrstack_size( &hStemHintArray ) +
                               cf2_arrstack_size( &vStemHintArray ) );
        }
        else
        {
# 1200 "../../../libs/freetype/src/cff/cf2intrp.c"
          CF2_HintMapRec counterHintMap;
          CF2_HintMaskRec counterMask;


          cf2_hintmap_init( &counterHintMap,
                            font,
                            &glyphPath.initialHintMap,
                            &glyphPath.hintMoves,
                            scaleY );
          cf2_hintmask_init( &counterMask, error );

          cf2_hintmask_read( &counterMask,
                             charstring,
                             cf2_arrstack_size( &hStemHintArray ) +
                               cf2_arrstack_size( &vStemHintArray ) );
          cf2_hintmap_build( &counterHintMap,
                             &hStemHintArray,
                             &vStemHintArray,
                             &counterMask,
                             0,
                             0 );
        }
        break;

      case cf2_cmdRMOVETO:
        do { } while ( 0 );

        if ( cf2_stack_count( opStack ) > 2 && !haveWidth )
          *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;


        haveWidth = 1;

        if ( font->decoder->width_only )
            goto exit;

        curY += cf2_stack_popFixed( opStack );
        curX += cf2_stack_popFixed( opStack );

        cf2_glyphpath_moveTo( &glyphPath, curX, curY );

        break;

      case cf2_cmdHMOVETO:
        do { } while ( 0 );

        if ( cf2_stack_count( opStack ) > 1 && !haveWidth )
          *width = cf2_stack_getReal( opStack, 0 ) + nominalWidthX;


        haveWidth = 1;

        if ( font->decoder->width_only )
            goto exit;

        curX += cf2_stack_popFixed( opStack );

        cf2_glyphpath_moveTo( &glyphPath, curX, curY );

        break;

      case cf2_cmdRLINECURVE:
        {
          FT_UFast count = cf2_stack_count( opStack );
          FT_UFast index = 0;


          do { } while ( 0 );

          while ( index + 6 < count )
          {
            curX += cf2_stack_getReal( opStack, index + 0 );
            curY += cf2_stack_getReal( opStack, index + 1 );

            cf2_glyphpath_lineTo( &glyphPath, curX, curY );
            index += 2;
          }

          while ( index < count )
          {
            CF2_F16Dot16 x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
            CF2_F16Dot16 y1 = cf2_stack_getReal( opStack, index + 1 ) + curY;
            CF2_F16Dot16 x2 = cf2_stack_getReal( opStack, index + 2 ) + x1;
            CF2_F16Dot16 y2 = cf2_stack_getReal( opStack, index + 3 ) + y1;
            CF2_F16Dot16 x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;
            CF2_F16Dot16 y3 = cf2_stack_getReal( opStack, index + 5 ) + y2;


            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX = x3;
            curY = y3;
            index += 6;
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdVVCURVETO:
        {
          FT_UFast count, count1 = cf2_stack_count( opStack );
          FT_UFast index = 0;





          count = count1 & ~2U;
          index += count1 - count;

          do { } while ( 0 );

          while ( index < count )
          {
            CF2_F16Dot16 x1, y1, x2, y2, x3, y3;


            if ( ( count - index ) & 1 )
            {
              x1 = cf2_stack_getReal( opStack, index ) + curX;

              ++index;
            }
            else
              x1 = curX;

            y1 = cf2_stack_getReal( opStack, index + 0 ) + curY;
            x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
            y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
            x3 = x2;
            y3 = cf2_stack_getReal( opStack, index + 3 ) + y2;

            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX = x3;
            curY = y3;
            index += 4;
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdHHCURVETO:
        {
          FT_UFast count, count1 = cf2_stack_count( opStack );
          FT_UFast index = 0;





          count = count1 & ~2U;
          index += count1 - count;

          do { } while ( 0 );

          while ( index < count )
          {
            CF2_F16Dot16 x1, y1, x2, y2, x3, y3;


            if ( ( count - index ) & 1 )
            {
              y1 = cf2_stack_getReal( opStack, index ) + curY;

              ++index;
            }
            else
              y1 = curY;

            x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
            x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
            y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
            x3 = cf2_stack_getReal( opStack, index + 3 ) + x2;
            y3 = y2;

            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX = x3;
            curY = y3;
            index += 4;
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdVHCURVETO:
      case cf2_cmdHVCURVETO:
        {
          FT_UFast count, count1 = cf2_stack_count( opStack );
          FT_UFast index = 0;

          FT_Bool alternate = op1 == cf2_cmdHVCURVETO;






          count = count1 & ~2U;
          index += count1 - count;

          do { } while ( 0 );

          while ( index < count )
          {
            CF2_F16Dot16 x1, x2, x3, y1, y2, y3;


            if ( alternate )
            {
              x1 = cf2_stack_getReal( opStack, index + 0 ) + curX;
              y1 = curY;
              x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
              y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
              y3 = cf2_stack_getReal( opStack, index + 3 ) + y2;

              if ( count - index == 5 )
              {
                x3 = cf2_stack_getReal( opStack, index + 4 ) + x2;

                ++index;
              }
              else
                x3 = x2;

              alternate = 0;
            }
            else
            {
              x1 = curX;
              y1 = cf2_stack_getReal( opStack, index + 0 ) + curY;
              x2 = cf2_stack_getReal( opStack, index + 1 ) + x1;
              y2 = cf2_stack_getReal( opStack, index + 2 ) + y1;
              x3 = cf2_stack_getReal( opStack, index + 3 ) + x2;

              if ( count - index == 5 )
              {
                y3 = cf2_stack_getReal( opStack, index + 4 ) + y2;

                ++index;
              }
              else
                y3 = y2;

              alternate = 1;
            }

            cf2_glyphpath_curveTo( &glyphPath, x1, y1, x2, y2, x3, y3 );

            curX = x3;
            curY = y3;
            index += 4;
          }

          cf2_stack_clear( opStack );
        }
        continue;

      case cf2_cmdEXTENDEDNMBR:
        {
          FT_Fast v;


          v = (FT_Short)( ( cf2_buf_readByte( charstring ) << 8 ) |
                            cf2_buf_readByte( charstring ) );

          do { } while ( 0 );

          cf2_stack_pushInt( opStack, v );
        }
        continue;

      default:

        {
          if ( op1 <= 246 )
          {
            FT_Fast v;


            v = op1 - 139;

            do { } while ( 0 );


            cf2_stack_pushInt( opStack, v );
          }

          else if ( op1 <= 250 )
          {
            FT_Fast v;


            v = op1;
            v -= 247;
            v *= 256;
            v += cf2_buf_readByte( charstring );
            v += 108;

            do { } while ( 0 );


            cf2_stack_pushInt( opStack, v );
          }

          else if ( op1 <= 254 )
          {
            FT_Fast v;


            v = op1;
            v -= 251;
            v *= 256;
            v += cf2_buf_readByte( charstring );
            v = -v - 108;

            do { } while ( 0 );


            cf2_stack_pushInt( opStack, v );
          }

          else
          {
            CF2_F16Dot16 v;


            v = (CF2_F16Dot16)
                  ( ( (FT_UInt32)cf2_buf_readByte( charstring ) << 24 ) |
                    ( (FT_UInt32)cf2_buf_readByte( charstring ) << 16 ) |
                    ( (FT_UInt32)cf2_buf_readByte( charstring ) << 8 ) |
                      (FT_UInt32)cf2_buf_readByte( charstring ) );

            do { } while ( 0 );

            cf2_stack_pushFixed( opStack, v );
          }
        }
        continue;

      }

      cf2_stack_clear( opStack );

    }


    do { } while ( 0 )
                                                        ;

  exit:

    cf2_setError( error, lastError );


    cf2_glyphpath_finalize( &glyphPath );
    cf2_arrstack_finalize( &vStemHintArray );
    cf2_arrstack_finalize( &hStemHintArray );
    cf2_arrstack_finalize( &subrStack );
    cf2_stack_free( opStack );

    do { } while ( 0 );

    return;
  }
# 38 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2read.c" 1
# 79 "../../../libs/freetype/src/cff/cf2read.c"
  static FT_Fast
  cf2_buf_readByte( CF2_Buffer buf )
  {
    if ( buf->ptr < buf->end )
    {
# 93 "../../../libs/freetype/src/cff/cf2read.c"
      return *(buf->ptr)++;

    }
    else
    {
      cf2_setError( buf->error, CF2_Err_Invalid_Stream_Operation );
      return 0;
    }
  }



  static FT_Bool
  cf2_buf_isEnd( CF2_Buffer buf )
  {
    return (FT_Bool)( buf->ptr >= buf->end );
  }
# 39 "../../../libs/freetype/src/cff/cff.c" 2
# 1 "../../../libs/freetype/src/cff/cf2stack.c" 1
# 52 "../../../libs/freetype/src/cff/cf2stack.c"
  static CF2_Stack
  cf2_stack_init( FT_Memory memory,
                  FT_Error* e )
  {
    FT_Error error = FT_Err_Ok;

    CF2_Stack stack = ((void *)0);


    if ( !( ((stack) = (ft_mem_qalloc( memory, (FT_Long)(sizeof ( *(stack) )), &error ))), error != 0 ) )
    {

      stack->memory = memory;
      stack->error = e;
      stack->top = &stack->buffer[0];
    }

    return stack;
  }


  static void
  cf2_stack_free( CF2_Stack stack )
  {
    if ( stack )
    {
      FT_Memory memory = stack->memory;



      do { ft_mem_free( memory, (stack) ); (stack) = ((void *)0); } while ( 0 );
    }
  }


  static FT_UFast
  cf2_stack_count( CF2_Stack stack )
  {
    return (FT_UFast)( stack->top - &stack->buffer[0] );
  }


  static void
  cf2_stack_pushInt( CF2_Stack stack,
                     FT_Fast val )
  {
    if ( stack->top == &stack->buffer[48] )
    {
      cf2_setError( stack->error, CF2_Err_Stack_Overflow );
      return;
    }

    stack->top->u.i = val;
    stack->top->type = CF2_NumberInt;
    ++stack->top;
  }


  static void
  cf2_stack_pushFixed( CF2_Stack stack,
                       CF2_F16Dot16 val )
  {
    if ( stack->top == &stack->buffer[48] )
    {
      cf2_setError( stack->error, CF2_Err_Stack_Overflow );
      return;
    }

    stack->top->u.r = val;
    stack->top->type = CF2_NumberFixed;
    ++stack->top;
  }



  static FT_Fast
  cf2_stack_popInt( CF2_Stack stack )
  {
    if ( stack->top == &stack->buffer[0] )
    {
      cf2_setError( stack->error, CF2_Err_Stack_Underflow );
      return 0;
    }
    if ( stack->top[-1].type != CF2_NumberInt )
    {
      cf2_setError( stack->error, CF2_Err_Syntax_Error );
      return 0;
    }

    --stack->top;

    return stack->top->u.i;
  }




  static CF2_F16Dot16
  cf2_stack_popFixed( CF2_Stack stack )
  {
    if ( stack->top == &stack->buffer[0] )
    {
      cf2_setError( stack->error, CF2_Err_Stack_Underflow );
      return ( (CF2_F16Dot16)( (FT_UInt32)(0) << 16 ) );
    }

    --stack->top;

    switch ( stack->top->type )
    {
    case CF2_NumberInt:
      return ( (CF2_F16Dot16)( (FT_UInt32)(stack->top->u.i) << 16 ) );
    case CF2_NumberFrac:
      return ( (stack->top->u.f) < 0 ? -( ( -(stack->top->u.f) + 0x2000 ) >> 14 ) : ( ( (stack->top->u.f) + 0x2000 ) >> 14 ) );
    default:
      return stack->top->u.r;
    }
  }




  static CF2_F16Dot16
  cf2_stack_getReal( CF2_Stack stack,
                     FT_UFast idx )
  {
    do { } while ( 0 );

    if ( idx >= cf2_stack_count( stack ) )
    {
      cf2_setError( stack->error, CF2_Err_Stack_Overflow );
      return ( (CF2_F16Dot16)( (FT_UInt32)(0) << 16 ) );
    }

    switch ( stack->buffer[idx].type )
    {
    case CF2_NumberInt:
      return ( (CF2_F16Dot16)( (FT_UInt32)(stack->buffer[idx].u.i) << 16 ) );
    case CF2_NumberFrac:
      return ( (stack->buffer[idx].u.f) < 0 ? -( ( -(stack->buffer[idx].u.f) + 0x2000 ) >> 14 ) : ( ( (stack->buffer[idx].u.f) + 0x2000 ) >> 14 ) );
    default:
      return stack->buffer[idx].u.r;
    }
  }


  static void
  cf2_stack_clear( CF2_Stack stack )
  {
    stack->top = &stack->buffer[0];
  }
# 40 "../../../libs/freetype/src/cff/cff.c" 2
