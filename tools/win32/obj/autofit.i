# 1 "../../../libs/freetype/src/autofit/autofit.c"
# 1 "<command-line>"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "../../../libs/freetype/src/autofit/autofit.c"
# 20 "../../../libs/freetype/src/autofit/autofit.c"
# 1 "../../../libs/freetype/include/ft2build.h" 1
# 37 "../../../libs/freetype/include/ft2build.h"
# 1 "../../../libs/freetype/include/freetype/config/ftheader.h" 1
# 827 "../../../libs/freetype/include/freetype/config/ftheader.h"
# 1 "../../../libs/freetype/include/freetype/internal/internal.h" 1
# 828 "../../../libs/freetype/include/freetype/config/ftheader.h" 2
# 38 "../../../libs/freetype/include/ft2build.h" 2
# 21 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afpic.c" 1
# 20 "../../../libs/freetype/src/autofit/afpic.c"
# 1 "../../../libs/freetype/include/freetype/freetype.h" 1
# 33 "../../../libs/freetype/include/freetype/freetype.h"
# 1 "../../../libs/freetype/include/freetype/config/ftconfig.h" 1
# 42 "../../../libs/freetype/include/freetype/config/ftconfig.h"
# 1 "../../../libs/freetype/include/freetype/config/ftoption.h" 1
# 26 "../../../libs/freetype/include/freetype/config/ftoption.h"

# 896 "../../../libs/freetype/include/freetype/config/ftoption.h"

# 43 "../../../libs/freetype/include/freetype/config/ftconfig.h" 2
# 1 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 1
# 36 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 147 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 212 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 324 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 3 4
typedef unsigned int wchar_t;
# 37 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 60 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 1 3 4
# 34 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\syslimits.h" 1 3 4






# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 1 3 4
# 168 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 1 3 4
# 25 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 1 3 4
# 378 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 1 3 4
# 385 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 386 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\cdefs.h" 2 3 4
# 379 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 2 3 4
# 402 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 1 3 4
# 10 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs-hard.h" 1 3 4
# 11 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\gnu\\stubs.h" 2 3 4
# 403 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\features.h" 2 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4
# 143 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 1 3 4
# 160 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 1 3 4
# 38 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\linux\\limits.h" 1 3 4
# 39 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\local_lim.h" 2 3 4
# 161 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix1_lim.h" 2 3 4
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4



# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\posix2_lim.h" 1 3 4
# 148 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\limits.h" 2 3 4
# 169 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 2 3 4
# 8 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\syslimits.h" 2 3 4
# 35 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include-fixed\\limits.h" 2 3 4
# 61 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 78 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4





# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 2 3 4
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 127 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\xlocale.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 164 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4

# 236 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 282 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 427 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 445 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 534 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 644 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\string.h" 3 4

# 79 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 102 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 1 3 4
# 29 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4




# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4

# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 28 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 121 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\typesizes.h" 1 3 4
# 122 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;


__extension__ typedef int __fsword_t;

__extension__ typedef int __ssize_t;


__extension__ typedef long int __syscall_slong_t;

__extension__ typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 36 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 1 3 4
# 15 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 16 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 2 3 4




# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\wchar.h" 1 3 4
# 82 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\_g_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 2 3 4
# 49 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 1 3 4
# 40 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 2 3 4
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
  __off64_t _offset;
# 302 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 464 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef __off_t off_t;
# 102 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;




# 164 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\stdio_lim.h" 1 3 4
# 165 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 306 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 665 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 824 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sys_errlist.h" 1 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 913 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 943 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdio.h" 3 4

# 103 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 120 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 1 3 4
# 32 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4








# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitflags.h" 1 3 4
# 42 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 1 3 4
# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 1 3 4
# 36 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\endian.h" 1 3 4
# 37 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 2 3 4
# 60 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 1 3 4
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap-16.h" 1 3 4
# 35 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 2 3 4
# 43 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 74 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\endian.h" 2 3 4
# 65 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 67 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 305 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef __daddr_t daddr_t;

typedef __caddr_t caddr_t;







typedef __key_t key_t;
# 135 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 1 3 4
# 57 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4


typedef __clock_t clock_t;



# 73 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4


typedef __time_t time_t;



# 91 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
typedef __timer_t timer_t;
# 136 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4
# 149 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 150 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 197 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 222 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 1 3 4
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\select.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 1 3 4
# 22 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 1 3 4
# 120 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4

# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\time.h" 1 3 4
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4

# 106 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\select.h" 3 4

# 223 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 1 3 4
# 24 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\sysmacros.h" 3 4

# 226 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 1 3 4
# 37 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[36];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
# 144 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\pthreadtypes.h" 3 4
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;

    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 274 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\sys\\types.h" 2 3 4



# 315 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 1 3 4
# 24 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 3 4
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 25 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 493 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 513 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 530 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 578 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 620 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4





extern int system (const char *__command) ;

# 734 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 752 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 812 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 899 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 951 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\stdlib-float.h" 1 3 4
# 956 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 2 3 4
# 968 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdlib.h" 3 4

# 121 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 198 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4


# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\setjmp.h" 1 3 4
# 33 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\setjmp.h" 3 4
typedef int __jmp_buf[64] __attribute__((__aligned__ (8)));
# 30 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\sigset.h" 1 3 4
# 31 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));










extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 102 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 112 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\setjmp.h" 3 4

# 199 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 211 "../../../libs/freetype/include/freetype/config/ftstdlib.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdarg.h" 1 3 4
# 212 "../../../libs/freetype/include/freetype/config/ftstdlib.h" 2
# 44 "../../../libs/freetype/include/freetype/config/ftconfig.h" 2



# 162 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef signed short FT_Int16;
# 173 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef unsigned short FT_UInt16;
# 233 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef signed int FT_Int32;
  typedef unsigned int FT_UInt32;
# 249 "../../../libs/freetype/include/freetype/config/ftconfig.h"
  typedef int FT_Fast;
  typedef unsigned int FT_UFast;
# 461 "../../../libs/freetype/include/freetype/config/ftconfig.h"

# 34 "../../../libs/freetype/include/freetype/freetype.h" 2
# 1 "../../../libs/freetype/include/freetype/fttypes.h" 1
# 25 "../../../libs/freetype/include/freetype/fttypes.h"
# 1 "../../../libs/freetype/include/freetype/ftsystem.h" 1
# 26 "../../../libs/freetype/include/freetype/ftsystem.h"

# 66 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_MemoryRec_* FT_Memory;
# 88 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void*
  (*FT_Alloc_Func)( FT_Memory memory,
                    long size );
# 109 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void
  (*FT_Free_Func)( FT_Memory memory,
                   void* block );
# 142 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void*
  (*FT_Realloc_Func)( FT_Memory memory,
                      long cur_size,
                      long new_size,
                      void* block );
# 171 "../../../libs/freetype/include/freetype/ftsystem.h"
  struct FT_MemoryRec_
  {
    void* user;
    FT_Alloc_Func alloc;
    FT_Free_Func free;
    FT_Realloc_Func realloc;
  };
# 200 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_* FT_Stream;
# 213 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef union FT_StreamDesc_
  {
    long value;
    void* pointer;

  } FT_StreamDesc;
# 251 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream stream,
                       unsigned long offset,
                       unsigned char* buffer,
                       unsigned long count );
# 271 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream stream );
# 330 "../../../libs/freetype/include/freetype/ftsystem.h"
  typedef struct FT_StreamRec_
  {
    unsigned char* base;
    unsigned long size;
    unsigned long pos;

    FT_StreamDesc descriptor;
    FT_StreamDesc pathname;
    FT_Stream_IoFunc read;
    FT_Stream_CloseFunc close;

    FT_Memory memory;
    unsigned char* cursor;
    unsigned char* limit;

  } FT_StreamRec;





# 26 "../../../libs/freetype/include/freetype/fttypes.h" 2
# 1 "../../../libs/freetype/include/freetype/ftimage.h" 1
# 37 "../../../libs/freetype/include/freetype/ftimage.h"

# 58 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef signed long FT_Pos;
# 74 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Vector_
  {
    FT_Pos x;
    FT_Pos y;

  } FT_Vector;
# 115 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_BBox_
  {
    FT_Pos xMin, yMin;
    FT_Pos xMax, yMax;

  } FT_BBox;
# 180 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef enum FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,

    FT_PIXEL_MODE_MAX

  } FT_Pixel_Mode;
# 261 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Bitmap_
  {
    unsigned int rows;
    unsigned int width;
    int pitch;
    unsigned char* buffer;
    unsigned short num_grays;
    unsigned char pixel_mode;
    unsigned char palette_mode;
    void* palette;

  } FT_Bitmap;
# 334 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_
  {
    short n_contours;
    short n_points;

    FT_Vector* points;
    char* tags;
    short* contours;

    int flags;

  } FT_Outline;
# 492 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector* to,
                            void* user );
# 519 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector* to,
                            void* user );
# 550 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector* control,
                             const FT_Vector* to,
                             void* user );
# 582 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector* control1,
                             const FT_Vector* control2,
                             const FT_Vector* to,
                             void* user );
# 628 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc move_to;
    FT_Outline_LineToFunc line_to;
    FT_Outline_ConicToFunc conic_to;
    FT_Outline_CubicToFunc cubic_to;

    int shift;
    FT_Pos delta;

  } FT_Outline_Funcs;
# 715 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef enum FT_Glyph_Format_
  {
    FT_GLYPH_FORMAT_NONE = ( ( (unsigned long)0 << 24 ) | ( (unsigned long)0 << 16 ) | ( (unsigned long)0 << 8 ) | (unsigned long)0 ),

    FT_GLYPH_FORMAT_COMPOSITE = ( ( (unsigned long)'c' << 24 ) | ( (unsigned long)'o' << 16 ) | ( (unsigned long)'m' << 8 ) | (unsigned long)'p' ),
    FT_GLYPH_FORMAT_BITMAP = ( ( (unsigned long)'b' << 24 ) | ( (unsigned long)'i' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'s' ),
    FT_GLYPH_FORMAT_OUTLINE = ( ( (unsigned long)'o' << 24 ) | ( (unsigned long)'u' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'l' ),
    FT_GLYPH_FORMAT_PLOTTER = ( ( (unsigned long)'p' << 24 ) | ( (unsigned long)'l' << 16 ) | ( (unsigned long)'o' << 8 ) | (unsigned long)'t' )

  } FT_Glyph_Format;
# 800 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_RasterRec_* FT_Raster;
# 828 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Span_
  {
    short x;
    unsigned short len;
    unsigned char coverage;

  } FT_Span;
# 873 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_SpanFunc)( int y,
                  int count,
                  const FT_Span* spans,
                  void* user );
# 890 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_BitTest_Func)( int y,
                             int x,
                             void* user );
# 904 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_BitSet_Func)( int y,
                            int x,
                            void* user );
# 1007 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Params_
  {
    const FT_Bitmap* target;
    const void* source;
    int flags;
    FT_SpanFunc gray_spans;
    FT_SpanFunc black_spans;
    FT_Raster_BitTest_Func bit_test;
    FT_Raster_BitSet_Func bit_set;
    void* user;
    FT_BBox clip_box;

  } FT_Raster_Params;
# 1046 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_NewFunc)( void* memory,
                        FT_Raster* raster );
# 1064 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster raster );
# 1096 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster raster,
                          unsigned char* pool_base,
                          unsigned long pool_size );
# 1122 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster raster,
                            unsigned long mode,
                            void* args );
# 1164 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster raster,
                           const FT_Raster_Params* params );
# 1190 "../../../libs/freetype/include/freetype/ftimage.h"
  typedef struct FT_Raster_Funcs_
  {
    FT_Glyph_Format glyph_format;
    FT_Raster_NewFunc raster_new;
    FT_Raster_ResetFunc raster_reset;
    FT_Raster_SetModeFunc raster_set_mode;
    FT_Raster_RenderFunc raster_render;
    FT_Raster_DoneFunc raster_done;

  } FT_Raster_Funcs;





# 27 "../../../libs/freetype/include/freetype/fttypes.h" 2

# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stddef.h" 1 3 4
# 29 "../../../libs/freetype/include/freetype/fttypes.h" 2



# 108 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Bool;
# 120 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_FWord;
# 132 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UFWord;
# 143 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed char FT_Char;
# 154 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned char FT_Byte;
# 165 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef const FT_Byte* FT_Bytes;
# 176 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef FT_UInt32 FT_Tag;
# 187 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef char FT_String;
# 198 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_Short;
# 209 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned short FT_UShort;
# 220 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed int FT_Int;
# 231 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned int FT_UInt;
# 242 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Long;
# 253 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef unsigned long FT_ULong;
# 264 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed short FT_F2Dot14;
# 276 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_F26Dot6;
# 288 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef signed long FT_Fixed;
# 300 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef int FT_Error;
# 311 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef void* FT_Pointer;
# 324 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef size_t FT_Offset;
# 337 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef ptrdiff_t FT_PtrDist;
# 354 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_UnitVector_
  {
    FT_F2Dot14 x;
    FT_F2Dot14 y;

  } FT_UnitVector;
# 385 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Matrix_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;

  } FT_Matrix;
# 406 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Data_
  {
    const FT_Byte* pointer;
    FT_Int length;

  } FT_Data;
# 428 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef void (*FT_Generic_Finalizer)(void* object);
# 459 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_Generic_
  {
    void* data;
    FT_Generic_Finalizer finalizer;

  } FT_Generic;
# 515 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_* FT_ListNode;
# 526 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_* FT_List;
# 544 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListNodeRec_
  {
    FT_ListNode prev;
    FT_ListNode next;
    void* data;

  } FT_ListNodeRec;
# 567 "../../../libs/freetype/include/freetype/fttypes.h"
  typedef struct FT_ListRec_
  {
    FT_ListNode head;
    FT_ListNode tail;

  } FT_ListRec;
# 597 "../../../libs/freetype/include/freetype/fttypes.h"

# 35 "../../../libs/freetype/include/freetype/freetype.h" 2
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 107 "../../../libs/freetype/include/freetype/fterrors.h"
# 1 "../../../libs/freetype/include/freetype/ftmoderr.h" 1
# 138 "../../../libs/freetype/include/freetype/ftmoderr.h"
  enum {



  FT_Mod_Err_Base = 0,
  FT_Mod_Err_Autofit = 0,
  FT_Mod_Err_BDF = 0,
  FT_Mod_Err_Bzip2 = 0,
  FT_Mod_Err_Cache = 0,
  FT_Mod_Err_CFF = 0,
  FT_Mod_Err_CID = 0,
  FT_Mod_Err_Gzip = 0,
  FT_Mod_Err_LZW = 0,
  FT_Mod_Err_OTvalid = 0,
  FT_Mod_Err_PCF = 0,
  FT_Mod_Err_PFR = 0,
  FT_Mod_Err_PSaux = 0,
  FT_Mod_Err_PShinter = 0,
  FT_Mod_Err_PSnames = 0,
  FT_Mod_Err_Raster = 0,
  FT_Mod_Err_SFNT = 0,
  FT_Mod_Err_Smooth = 0,
  FT_Mod_Err_TrueType = 0,
  FT_Mod_Err_Type1 = 0,
  FT_Mod_Err_Type42 = 0,
  FT_Mod_Err_Winfonts = 0,
  FT_Mod_Err_GXvalid = 0,



  FT_Mod_Err_Max };
# 108 "../../../libs/freetype/include/freetype/fterrors.h" 2
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  FT_Err_Ok = 0x00,


  FT_Err_Cannot_Open_Resource = 0x01 + 0,

  FT_Err_Unknown_File_Format = 0x02 + 0,

  FT_Err_Invalid_File_Format = 0x03 + 0,

  FT_Err_Invalid_Version = 0x04 + 0,

  FT_Err_Lower_Module_Version = 0x05 + 0,

  FT_Err_Invalid_Argument = 0x06 + 0,

  FT_Err_Unimplemented_Feature = 0x07 + 0,

  FT_Err_Invalid_Table = 0x08 + 0,

  FT_Err_Invalid_Offset = 0x09 + 0,

  FT_Err_Array_Too_Large = 0x0A + 0,

  FT_Err_Missing_Module = 0x0B + 0,

  FT_Err_Missing_Property = 0x0C + 0,




  FT_Err_Invalid_Glyph_Index = 0x10 + 0,

  FT_Err_Invalid_Character_Code = 0x11 + 0,

  FT_Err_Invalid_Glyph_Format = 0x12 + 0,

  FT_Err_Cannot_Render_Glyph = 0x13 + 0,

  FT_Err_Invalid_Outline = 0x14 + 0,

  FT_Err_Invalid_Composite = 0x15 + 0,

  FT_Err_Too_Many_Hints = 0x16 + 0,

  FT_Err_Invalid_Pixel_Size = 0x17 + 0,




  FT_Err_Invalid_Handle = 0x20 + 0,

  FT_Err_Invalid_Library_Handle = 0x21 + 0,

  FT_Err_Invalid_Driver_Handle = 0x22 + 0,

  FT_Err_Invalid_Face_Handle = 0x23 + 0,

  FT_Err_Invalid_Size_Handle = 0x24 + 0,

  FT_Err_Invalid_Slot_Handle = 0x25 + 0,

  FT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  FT_Err_Invalid_Cache_Handle = 0x27 + 0,

  FT_Err_Invalid_Stream_Handle = 0x28 + 0,




  FT_Err_Too_Many_Drivers = 0x30 + 0,

  FT_Err_Too_Many_Extensions = 0x31 + 0,




  FT_Err_Out_Of_Memory = 0x40 + 0,

  FT_Err_Unlisted_Object = 0x41 + 0,




  FT_Err_Cannot_Open_Stream = 0x51 + 0,

  FT_Err_Invalid_Stream_Seek = 0x52 + 0,

  FT_Err_Invalid_Stream_Skip = 0x53 + 0,

  FT_Err_Invalid_Stream_Read = 0x54 + 0,

  FT_Err_Invalid_Stream_Operation = 0x55 + 0,

  FT_Err_Invalid_Frame_Operation = 0x56 + 0,

  FT_Err_Nested_Frame_Access = 0x57 + 0,

  FT_Err_Invalid_Frame_Read = 0x58 + 0,




  FT_Err_Raster_Uninitialized = 0x60 + 0,

  FT_Err_Raster_Corrupted = 0x61 + 0,

  FT_Err_Raster_Overflow = 0x62 + 0,

  FT_Err_Raster_Negative_Height = 0x63 + 0,




  FT_Err_Too_Many_Caches = 0x70 + 0,




  FT_Err_Invalid_Opcode = 0x80 + 0,

  FT_Err_Too_Few_Arguments = 0x81 + 0,

  FT_Err_Stack_Overflow = 0x82 + 0,

  FT_Err_Code_Overflow = 0x83 + 0,

  FT_Err_Bad_Argument = 0x84 + 0,

  FT_Err_Divide_By_Zero = 0x85 + 0,

  FT_Err_Invalid_Reference = 0x86 + 0,

  FT_Err_Debug_OpCode = 0x87 + 0,

  FT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  FT_Err_Nested_DEFS = 0x89 + 0,

  FT_Err_Invalid_CodeRange = 0x8A + 0,

  FT_Err_Execution_Too_Long = 0x8B + 0,

  FT_Err_Too_Many_Function_Defs = 0x8C + 0,

  FT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  FT_Err_Table_Missing = 0x8E + 0,

  FT_Err_Horiz_Header_Missing = 0x8F + 0,

  FT_Err_Locations_Missing = 0x90 + 0,

  FT_Err_Name_Table_Missing = 0x91 + 0,

  FT_Err_CMap_Table_Missing = 0x92 + 0,

  FT_Err_Hmtx_Table_Missing = 0x93 + 0,

  FT_Err_Post_Table_Missing = 0x94 + 0,

  FT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  FT_Err_Invalid_CharMap_Format = 0x96 + 0,

  FT_Err_Invalid_PPem = 0x97 + 0,

  FT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  FT_Err_Could_Not_Find_Context = 0x99 + 0,

  FT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  FT_Err_Invalid_Post_Table = 0x9B + 0,




  FT_Err_Syntax_Error = 0xA0 + 0,

  FT_Err_Stack_Underflow = 0xA1 + 0,

  FT_Err_Ignore = 0xA2 + 0,

  FT_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  FT_Err_Glyph_Too_Big = 0xA4 + 0,




  FT_Err_Missing_Startfont_Field = 0xB0 + 0,

  FT_Err_Missing_Font_Field = 0xB1 + 0,

  FT_Err_Missing_Size_Field = 0xB2 + 0,

  FT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  FT_Err_Missing_Chars_Field = 0xB4 + 0,

  FT_Err_Missing_Startchar_Field = 0xB5 + 0,

  FT_Err_Missing_Encoding_Field = 0xB6 + 0,

  FT_Err_Missing_Bbx_Field = 0xB7 + 0,

  FT_Err_Bbx_Too_Big = 0xB8 + 0,

  FT_Err_Corrupted_Font_Header = 0xB9 + 0,

  FT_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  FT_Err_Max };
# 36 "../../../libs/freetype/include/freetype/freetype.h" 2



# 309 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Glyph_Metrics_
  {
    FT_Pos width;
    FT_Pos height;

    FT_Pos horiBearingX;
    FT_Pos horiBearingY;
    FT_Pos horiAdvance;

    FT_Pos vertBearingX;
    FT_Pos vertBearingY;
    FT_Pos vertAdvance;

  } FT_Glyph_Metrics;
# 363 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Bitmap_Size_
  {
    FT_Short height;
    FT_Short width;

    FT_Pos size;

    FT_Pos x_ppem;
    FT_Pos y_ppem;

  } FT_Bitmap_Size;
# 409 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_LibraryRec_ *FT_Library;
# 429 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_ModuleRec_* FT_Module;
# 441 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_DriverRec_* FT_Driver;
# 455 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_RendererRec_* FT_Renderer;
# 495 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_* FT_Face;
# 526 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_* FT_Size;
# 547 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_* FT_GlyphSlot;
# 579 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_* FT_CharMap;
# 757 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Encoding_
  {
    FT_ENCODING_NONE = ( ( (FT_UInt32)(0) << 24 ) | ( (FT_UInt32)(0) << 16 ) | ( (FT_UInt32)(0) << 8 ) | (FT_UInt32)(0) ),

    FT_ENCODING_MS_SYMBOL = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('y') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('b') ),
    FT_ENCODING_UNICODE = ( ( (FT_UInt32)('u') << 24 ) | ( (FT_UInt32)('n') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('c') ),

    FT_ENCODING_SJIS = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('j') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_GB2312 = ( ( (FT_UInt32)('g') << 24 ) | ( (FT_UInt32)('b') << 16 ) | ( (FT_UInt32)(' ') << 8 ) | (FT_UInt32)(' ') ),
    FT_ENCODING_BIG5 = ( ( (FT_UInt32)('b') << 24 ) | ( (FT_UInt32)('i') << 16 ) | ( (FT_UInt32)('g') << 8 ) | (FT_UInt32)('5') ),
    FT_ENCODING_WANSUNG = ( ( (FT_UInt32)('w') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('n') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_JOHAB = ( ( (FT_UInt32)('j') << 24 ) | ( (FT_UInt32)('o') << 16 ) | ( (FT_UInt32)('h') << 8 ) | (FT_UInt32)('a') ),


    FT_ENCODING_MS_SJIS = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312 = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5 = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB = FT_ENCODING_JOHAB,

    FT_ENCODING_ADOBE_STANDARD = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('O') << 8 ) | (FT_UInt32)('B') ),
    FT_ENCODING_ADOBE_EXPERT = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('E') ),
    FT_ENCODING_ADOBE_CUSTOM = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('C') ),
    FT_ENCODING_ADOBE_LATIN_1 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('1') ),

    FT_ENCODING_OLD_LATIN_2 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('2') ),

    FT_ENCODING_APPLE_ROMAN = ( ( (FT_UInt32)('a') << 24 ) | ( (FT_UInt32)('r') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('n') )

  } FT_Encoding;
# 831 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_CharMapRec_
  {
    FT_Face face;
    FT_Encoding encoding;
    FT_UShort platform_id;
    FT_UShort encoding_id;

  } FT_CharMapRec;
# 862 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Face_InternalRec_* FT_Face_Internal;
# 1034 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_FaceRec_
  {
    FT_Long num_faces;
    FT_Long face_index;

    FT_Long face_flags;
    FT_Long style_flags;

    FT_Long num_glyphs;

    FT_String* family_name;
    FT_String* style_name;

    FT_Int num_fixed_sizes;
    FT_Bitmap_Size* available_sizes;

    FT_Int num_charmaps;
    FT_CharMap* charmaps;

    FT_Generic generic;




    FT_BBox bbox;

    FT_UShort units_per_EM;
    FT_Short ascender;
    FT_Short descender;
    FT_Short height;

    FT_Short max_advance_width;
    FT_Short max_advance_height;

    FT_Short underline_position;
    FT_Short underline_thickness;

    FT_GlyphSlot glyph;
    FT_Size size;
    FT_CharMap charmap;



    FT_Driver driver;
    FT_Memory memory;
    FT_Stream stream;

    FT_ListRec sizes_list;

    FT_Generic autohint;
    void* extensions;

    FT_Face_Internal internal;



  } FT_FaceRec;
# 1443 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_InternalRec_* FT_Size_Internal;
# 1501 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_Metrics_
  {
    FT_UShort x_ppem;
    FT_UShort y_ppem;

    FT_Fixed x_scale;
    FT_Fixed y_scale;

    FT_Pos ascender;
    FT_Pos descender;
    FT_Pos height;
    FT_Pos max_advance;

  } FT_Size_Metrics;
# 1536 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SizeRec_
  {
    FT_Face face;
    FT_Generic generic;
    FT_Size_Metrics metrics;
    FT_Size_Internal internal;

  } FT_SizeRec;
# 1562 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_SubGlyphRec_* FT_SubGlyph;
# 1574 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Slot_InternalRec_* FT_Slot_Internal;
# 1745 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_GlyphSlotRec_
  {
    FT_Library library;
    FT_Face face;
    FT_GlyphSlot next;
    FT_UInt reserved;
    FT_Generic generic;

    FT_Glyph_Metrics metrics;
    FT_Fixed linearHoriAdvance;
    FT_Fixed linearVertAdvance;
    FT_Vector advance;

    FT_Glyph_Format format;

    FT_Bitmap bitmap;
    FT_Int bitmap_left;
    FT_Int bitmap_top;

    FT_Outline outline;

    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

    void* control_data;
    long control_len;

    FT_Pos lsb_delta;
    FT_Pos rsb_delta;

    void* other;

    FT_Slot_Internal internal;

  } FT_GlyphSlotRec;
# 1817 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Init_FreeType( FT_Library *alibrary );
# 1836 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Done_FreeType( FT_Library library );
# 1899 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Parameter_
  {
    FT_ULong tag;
    FT_Pointer data;

  } FT_Parameter;
# 1965 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Open_Args_
  {
    FT_UInt flags;
    const FT_Byte* memory_base;
    FT_Long memory_size;
    FT_String* pathname;
    FT_Stream stream;
    FT_Module driver;
    FT_Int num_params;
    FT_Parameter* params;

  } FT_Open_Args;
# 2007 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_New_Face( FT_Library library,
               const char* filepathname,
               FT_Long face_index,
               FT_Face *aface );
# 2044 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_New_Memory_Face( FT_Library library,
                      const FT_Byte* file_base,
                      FT_Long file_size,
                      FT_Long face_index,
                      FT_Face *aface );
# 2192 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Open_Face( FT_Library library,
                const FT_Open_Args* args,
                FT_Long face_index,
                FT_Face *aface );
# 2216 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Attach_File( FT_Face face,
                  const char* filepathname );
# 2251 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Attach_Stream( FT_Face face,
                    FT_Open_Args* parameters );
# 2279 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Reference_Face( FT_Face face );
# 2302 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Done_Face( FT_Face face );
# 2324 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Select_Size( FT_Face face,
                  FT_Int strike_index );
# 2371 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;
# 2411 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_
  {
    FT_Size_Request_Type type;
    FT_Long width;
    FT_Long height;
    FT_UInt horiResolution;
    FT_UInt vertResolution;

  } FT_Size_RequestRec;
# 2430 "../../../libs/freetype/include/freetype/freetype.h"
  typedef struct FT_Size_RequestRec_ *FT_Size_Request;
# 2464 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Request_Size( FT_Face face,
                   FT_Size_Request req );
# 2505 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Char_Size( FT_Face face,
                    FT_F26Dot6 char_width,
                    FT_F26Dot6 char_height,
                    FT_UInt horz_resolution,
                    FT_UInt vert_resolution );
# 2540 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Pixel_Sizes( FT_Face face,
                      FT_UInt pixel_width,
                      FT_UInt pixel_height );
# 2582 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Load_Glyph( FT_Face face,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );
# 2617 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Load_Char( FT_Face face,
                FT_ULong char_code,
                FT_Int32 load_flags );
# 2925 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Set_Transform( FT_Face face,
                    FT_Matrix* matrix,
                    FT_Vector* delta );
# 2989 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;
# 3111 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Render_Glyph( FT_GlyphSlot slot,
                   FT_Render_Mode render_mode );
# 3142 "../../../libs/freetype/include/freetype/freetype.h"
  typedef enum FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;
# 3192 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Kerning( FT_Face face,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_UInt kern_mode,
                  FT_Vector *akerning );
# 3233 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Track_Kerning( FT_Face face,
                        FT_Fixed point_size,
                        FT_Int degree,
                        FT_Fixed* akerning );
# 3279 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_Glyph_Name( FT_Face face,
                     FT_UInt glyph_index,
                     FT_Pointer buffer,
                     FT_UInt buffer_max );
# 3305 "../../../libs/freetype/include/freetype/freetype.h"
  extern const char*
  FT_Get_Postscript_Name( FT_Face face );
# 3337 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Select_Charmap( FT_Face face,
                     FT_Encoding encoding );
# 3366 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Set_Charmap( FT_Face face,
                  FT_CharMap charmap );
# 3388 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Int
  FT_Get_Charmap_Index( FT_CharMap charmap );
# 3422 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Get_Char_Index( FT_Face face,
                     FT_ULong charcode );
# 3477 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_ULong
  FT_Get_First_Char( FT_Face face,
                     FT_UInt *agindex );
# 3511 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_ULong
  FT_Get_Next_Char( FT_Face face,
                    FT_ULong char_code,
                    FT_UInt *agindex );
# 3534 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Get_Name_Index( FT_Face face,
                     FT_String* glyph_name );
# 3610 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Error
  FT_Get_SubGlyph_Info( FT_GlyphSlot glyph,
                        FT_UInt sub_index,
                        FT_Int *p_index,
                        FT_UInt *p_flags,
                        FT_Int *p_arg1,
                        FT_Int *p_arg2,
                        FT_Matrix *p_transform );
# 3705 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UShort
  FT_Get_FSType_Flags( FT_Face face );
# 3791 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt
  FT_Face_GetCharVariantIndex( FT_Face face,
                               FT_ULong charcode,
                               FT_ULong variantSelector );
# 3827 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Int
  FT_Face_GetCharVariantIsDefault( FT_Face face,
                                   FT_ULong charcode,
                                   FT_ULong variantSelector );
# 3858 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetVariantSelectors( FT_Face face );
# 3891 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetVariantsOfChar( FT_Face face,
                             FT_ULong charcode );
# 3925 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_UInt32*
  FT_Face_GetCharsOfVariant( FT_Face face,
                             FT_ULong variantSelector );
# 3982 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_MulDiv( FT_Long a,
             FT_Long b,
             FT_Long c );
# 4017 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_MulFix( FT_Long a,
             FT_Long b );
# 4039 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Long
  FT_DivFix( FT_Long a,
             FT_Long b );
# 4059 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_RoundFix( FT_Fixed a );
# 4078 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_CeilFix( FT_Fixed a );
# 4097 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Fixed
  FT_FloorFix( FT_Fixed a );
# 4118 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Vector_Transform( FT_Vector* vec,
                       const FT_Matrix* matrix );
# 4208 "../../../libs/freetype/include/freetype/freetype.h"
  extern void
  FT_Library_Version( FT_Library library,
                      FT_Int *amajor,
                      FT_Int *aminor,
                      FT_Int *apatch );
# 4242 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Bool
  FT_Face_CheckTrueTypePatents( FT_Face face );
# 4272 "../../../libs/freetype/include/freetype/freetype.h"
  extern FT_Bool
  FT_Face_SetUnpatentedHinting( FT_Face face,
                                FT_Bool value );





# 21 "../../../libs/freetype/src/autofit/afpic.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
# 1 "../../../libs/freetype/include/freetype/ftrender.h" 1
# 24 "../../../libs/freetype/include/freetype/ftrender.h"
# 1 "../../../libs/freetype/include/freetype/ftmodapi.h" 1
# 33 "../../../libs/freetype/include/freetype/ftmodapi.h"

# 136 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Pointer FT_Module_Interface;
# 150 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Error
  (*FT_Module_Constructor)( FT_Module module );
# 165 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef void
  (*FT_Module_Destructor)( FT_Module module );
# 182 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef FT_Module_Interface
  (*FT_Module_Requester)( FT_Module module,
                          const char* name );
# 216 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef struct FT_Module_Class_
  {
    FT_ULong module_flags;
    FT_Long module_size;
    const FT_String* module_name;
    FT_Fixed module_version;
    FT_Fixed module_requires;

    const void* module_interface;

    FT_Module_Constructor module_init;
    FT_Module_Destructor module_done;
    FT_Module_Requester get_interface;

  } FT_Module_Class;
# 254 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Add_Module( FT_Library library,
                 const FT_Module_Class* clazz );
# 279 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Module
  FT_Get_Module( FT_Library library,
                 const char* module_name );
# 304 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Remove_Module( FT_Library library,
                    FT_Module module );
# 369 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Property_Set( FT_Library library,
                   const FT_String* module_name,
                   const FT_String* property_name,
                   const void* value );
# 433 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Property_Get( FT_Library library,
                   const FT_String* module_name,
                   const FT_String* property_name,
                   void* value );
# 463 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Reference_Library( FT_Library library );
# 499 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_New_Library( FT_Memory memory,
                  FT_Library *alibrary );
# 523 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_Error
  FT_Done_Library( FT_Library library );



  typedef void
  (*FT_DebugHook_Func)( void* arg );
# 559 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern void
  FT_Set_Debug_Hook( FT_Library library,
                     FT_UInt hook_index,
                     FT_DebugHook_Func debug_hook );
# 578 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern void
  FT_Add_Default_Modules( FT_Library library );
# 632 "../../../libs/freetype/include/freetype/ftmodapi.h"
  typedef enum FT_TrueTypeEngineType_
  {
    FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED,
    FT_TRUETYPE_ENGINE_TYPE_PATENTED

  } FT_TrueTypeEngineType;
# 661 "../../../libs/freetype/include/freetype/ftmodapi.h"
  extern FT_TrueTypeEngineType
  FT_Get_TrueType_Engine_Type( FT_Library library );





# 25 "../../../libs/freetype/include/freetype/ftrender.h" 2
# 1 "../../../libs/freetype/include/freetype/ftglyph.h" 1
# 46 "../../../libs/freetype/include/freetype/ftglyph.h"

# 69 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_Glyph_Class_ FT_Glyph_Class;
# 87 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_* FT_Glyph;
# 108 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_GlyphRec_
  {
    FT_Library library;
    const FT_Glyph_Class* clazz;
    FT_Glyph_Format format;
    FT_Vector advance;

  } FT_GlyphRec;
# 127 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_* FT_BitmapGlyph;
# 160 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_BitmapGlyphRec_
  {
    FT_GlyphRec root;
    FT_Int left;
    FT_Int top;
    FT_Bitmap bitmap;

  } FT_BitmapGlyphRec;
# 179 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_* FT_OutlineGlyph;
# 208 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef struct FT_OutlineGlyphRec_
  {
    FT_GlyphRec root;
    FT_Outline outline;

  } FT_OutlineGlyphRec;
# 234 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Get_Glyph( FT_GlyphSlot slot,
                FT_Glyph *aglyph );
# 258 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_Copy( FT_Glyph source,
                 FT_Glyph *target );
# 287 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_Transform( FT_Glyph glyph,
                      FT_Matrix* matrix,
                      FT_Vector* delta );
# 317 "../../../libs/freetype/include/freetype/ftglyph.h"
  typedef enum FT_Glyph_BBox_Mode_
  {
    FT_GLYPH_BBOX_UNSCALED = 0,
    FT_GLYPH_BBOX_SUBPIXELS = 0,
    FT_GLYPH_BBOX_GRIDFIT = 1,
    FT_GLYPH_BBOX_TRUNCATE = 2,
    FT_GLYPH_BBOX_PIXELS = 3

  } FT_Glyph_BBox_Mode;
# 406 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Glyph_Get_CBox( FT_Glyph glyph,
                     FT_UInt bbox_mode,
                     FT_BBox *acbox );
# 518 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Glyph_To_Bitmap( FT_Glyph* the_glyph,
                      FT_Render_Mode render_mode,
                      FT_Vector* origin,
                      FT_Bool destroy );
# 536 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Done_Glyph( FT_Glyph glyph );
# 569 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern void
  FT_Matrix_Multiply( const FT_Matrix* a,
                      FT_Matrix* b );
# 589 "../../../libs/freetype/include/freetype/ftglyph.h"
  extern FT_Error
  FT_Matrix_Invert( FT_Matrix* matrix );





# 26 "../../../libs/freetype/include/freetype/ftrender.h" 2



# 40 "../../../libs/freetype/include/freetype/ftrender.h"
  typedef FT_Error
  (*FT_Glyph_InitFunc)( FT_Glyph glyph,
                        FT_GlyphSlot slot );


  typedef void
  (*FT_Glyph_DoneFunc)( FT_Glyph glyph );

  typedef void
  (*FT_Glyph_TransformFunc)( FT_Glyph glyph,
                             const FT_Matrix* matrix,
                             const FT_Vector* delta );

  typedef void
  (*FT_Glyph_GetBBoxFunc)( FT_Glyph glyph,
                           FT_BBox* abbox );

  typedef FT_Error
  (*FT_Glyph_CopyFunc)( FT_Glyph source,
                        FT_Glyph target );

  typedef FT_Error
  (*FT_Glyph_PrepareFunc)( FT_Glyph glyph,
                           FT_GlyphSlot slot );
# 74 "../../../libs/freetype/include/freetype/ftrender.h"
  struct FT_Glyph_Class_
  {
    FT_Long glyph_size;
    FT_Glyph_Format glyph_format;
    FT_Glyph_InitFunc glyph_init;
    FT_Glyph_DoneFunc glyph_done;
    FT_Glyph_CopyFunc glyph_copy;
    FT_Glyph_TransformFunc glyph_transform;
    FT_Glyph_GetBBoxFunc glyph_bbox;
    FT_Glyph_PrepareFunc glyph_prepare;
  };


  typedef FT_Error
  (*FT_Renderer_RenderFunc)( FT_Renderer renderer,
                             FT_GlyphSlot slot,
                             FT_UInt mode,
                             const FT_Vector* origin );

  typedef FT_Error
  (*FT_Renderer_TransformFunc)( FT_Renderer renderer,
                                FT_GlyphSlot slot,
                                const FT_Matrix* matrix,
                                const FT_Vector* delta );


  typedef void
  (*FT_Renderer_GetCBoxFunc)( FT_Renderer renderer,
                              FT_GlyphSlot slot,
                              FT_BBox* cbox );


  typedef FT_Error
  (*FT_Renderer_SetModeFunc)( FT_Renderer renderer,
                              FT_ULong mode_tag,
                              FT_Pointer mode_ptr );
# 144 "../../../libs/freetype/include/freetype/ftrender.h"
  typedef struct FT_Renderer_Class_
  {
    FT_Module_Class root;

    FT_Glyph_Format glyph_format;

    FT_Renderer_RenderFunc render_glyph;
    FT_Renderer_TransformFunc transform_glyph;
    FT_Renderer_GetCBoxFunc get_glyph_cbox;
    FT_Renderer_SetModeFunc set_mode;

    FT_Raster_Funcs* raster_class;

  } FT_Renderer_Class;
# 183 "../../../libs/freetype/include/freetype/ftrender.h"
  extern FT_Renderer
  FT_Get_Renderer( FT_Library library,
                   FT_Glyph_Format format );
# 218 "../../../libs/freetype/include/freetype/ftrender.h"
  extern FT_Error
  FT_Set_Renderer( FT_Library library,
                   FT_Renderer renderer,
                   FT_UInt num_params,
                   FT_Parameter* parameters );





# 31 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/ftsizes.h" 1
# 42 "../../../libs/freetype/include/freetype/ftsizes.h"

# 99 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_New_Size( FT_Face face,
               FT_Size* size );
# 120 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_Done_Size( FT_Size size );
# 148 "../../../libs/freetype/include/freetype/ftsizes.h"
  extern FT_Error
  FT_Activate_Size( FT_Size size );





# 32 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/ftlcdfil.h" 1
# 33 "../../../libs/freetype/include/freetype/ftlcdfil.h"

# 173 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  typedef enum FT_LcdFilter_
  {
    FT_LCD_FILTER_NONE = 0,
    FT_LCD_FILTER_DEFAULT = 1,
    FT_LCD_FILTER_LIGHT = 2,
    FT_LCD_FILTER_LEGACY1 = 3,
    FT_LCD_FILTER_LEGACY = 16,

    FT_LCD_FILTER_MAX

  } FT_LcdFilter;
# 240 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  extern FT_Error
  FT_Library_SetLcdFilter( FT_Library library,
                           FT_LcdFilter filter );
# 281 "../../../libs/freetype/include/freetype/ftlcdfil.h"
  extern FT_Error
  FT_Library_SetLcdFilterWeights( FT_Library library,
                                  unsigned char *weights );





# 33 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftmemory.h" 1
# 28 "../../../libs/freetype/include/freetype/internal/ftmemory.h"

# 113 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_alloc( FT_Memory memory,
                FT_Long size,
                FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qalloc( FT_Memory memory,
                 FT_Long size,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_realloc( FT_Memory memory,
                  FT_Long item_size,
                  FT_Long cur_count,
                  FT_Long new_count,
                  void* block,
                  FT_Error *p_error );

  extern FT_Pointer
  ft_mem_qrealloc( FT_Memory memory,
                   FT_Long item_size,
                   FT_Long cur_count,
                   FT_Long new_count,
                   void* block,
                   FT_Error *p_error );

  extern void
  ft_mem_free( FT_Memory memory,
               const void* P );
# 342 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Pointer
  ft_mem_strdup( FT_Memory memory,
                 const char* str,
                 FT_Error *p_error );

  extern FT_Pointer
  ft_mem_dup( FT_Memory memory,
              const void* address,
              FT_ULong size,
              FT_Error *p_error );
# 370 "../../../libs/freetype/include/freetype/internal/ftmemory.h"
  extern FT_Int
  ft_mem_strcpyn( char* dst,
                  const char* src,
                  FT_ULong size );








# 34 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftgloadr.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"

# 43 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_GlyphLoaderRec_* FT_GlyphLoader ;
# 57 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  typedef struct FT_SubGlyphRec_
  {
    FT_Int index;
    FT_UShort flags;
    FT_Int arg1;
    FT_Int arg2;
    FT_Matrix transform;

  } FT_SubGlyphRec;


  typedef struct FT_GlyphLoadRec_
  {
    FT_Outline outline;
    FT_Vector* extra_points;
    FT_Vector* extra_points2;
    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

  } FT_GlyphLoadRec, *FT_GlyphLoad;


  typedef struct FT_GlyphLoaderRec_
  {
    FT_Memory memory;
    FT_UInt max_points;
    FT_UInt max_contours;
    FT_UInt max_subglyphs;
    FT_Bool use_extra;

    FT_GlyphLoadRec base;
    FT_GlyphLoadRec current;

    void* other;

  } FT_GlyphLoaderRec;



  extern FT_Error
  FT_GlyphLoader_New( FT_Memory memory,
                      FT_GlyphLoader *aloader );


  extern FT_Error
  FT_GlyphLoader_CreateExtra( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Done( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Reset( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Rewind( FT_GlyphLoader loader );



  extern FT_Error
  FT_GlyphLoader_CheckPoints( FT_GlyphLoader loader,
                              FT_UInt n_points,
                              FT_UInt n_contours );
# 147 "../../../libs/freetype/include/freetype/internal/ftgloadr.h"
  extern FT_Error
  FT_GlyphLoader_CheckSubGlyphs( FT_GlyphLoader loader,
                                 FT_UInt n_subs );


  extern void
  FT_GlyphLoader_Prepare( FT_GlyphLoader loader );


  extern void
  FT_GlyphLoader_Add( FT_GlyphLoader loader );


  extern FT_Error
  FT_GlyphLoader_CopyPoints( FT_GlyphLoader target,
                             FT_GlyphLoader source );





# 35 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftdriver.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftdriver.h"



  typedef FT_Error
  (*FT_Face_InitFunc)( FT_Stream stream,
                       FT_Face face,
                       FT_Int typeface_index,
                       FT_Int num_params,
                       FT_Parameter* parameters );

  typedef void
  (*FT_Face_DoneFunc)( FT_Face face );


  typedef FT_Error
  (*FT_Size_InitFunc)( FT_Size size );

  typedef void
  (*FT_Size_DoneFunc)( FT_Size size );


  typedef FT_Error
  (*FT_Slot_InitFunc)( FT_GlyphSlot slot );

  typedef void
  (*FT_Slot_DoneFunc)( FT_GlyphSlot slot );


  typedef FT_Error
  (*FT_Size_RequestFunc)( FT_Size size,
                          FT_Size_Request req );

  typedef FT_Error
  (*FT_Size_SelectFunc)( FT_Size size,
                         FT_ULong size_index );

  typedef FT_Error
  (*FT_Slot_LoadFunc)( FT_GlyphSlot slot,
                       FT_Size size,
                       FT_UInt glyph_index,
                       FT_Int32 load_flags );


  typedef FT_UInt
  (*FT_CharMap_CharIndexFunc)( FT_CharMap charmap,
                               FT_Long charcode );

  typedef FT_Long
  (*FT_CharMap_CharNextFunc)( FT_CharMap charmap,
                              FT_Long charcode );


  typedef FT_Error
  (*FT_Face_GetKerningFunc)( FT_Face face,
                             FT_UInt left_glyph,
                             FT_UInt right_glyph,
                             FT_Vector* kerning );


  typedef FT_Error
  (*FT_Face_AttachFunc)( FT_Face face,
                         FT_Stream stream );


  typedef FT_Error
  (*FT_Face_GetAdvancesFunc)( FT_Face face,
                              FT_UInt first,
                              FT_UInt count,
                              FT_Int32 flags,
                              FT_Fixed* advances );
# 166 "../../../libs/freetype/include/freetype/internal/ftdriver.h"
  typedef struct FT_Driver_ClassRec_
  {
    FT_Module_Class root;

    FT_Long face_object_size;
    FT_Long size_object_size;
    FT_Long slot_object_size;

    FT_Face_InitFunc init_face;
    FT_Face_DoneFunc done_face;

    FT_Size_InitFunc init_size;
    FT_Size_DoneFunc done_size;

    FT_Slot_InitFunc init_slot;
    FT_Slot_DoneFunc done_slot;

    FT_Slot_LoadFunc load_glyph;

    FT_Face_GetKerningFunc get_kerning;
    FT_Face_AttachFunc attach_file;
    FT_Face_GetAdvancesFunc get_advances;


    FT_Size_RequestFunc request_size;
    FT_Size_SelectFunc select_size;

  } FT_Driver_ClassRec, *FT_Driver_Class;
# 404 "../../../libs/freetype/include/freetype/internal/ftdriver.h"

# 36 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/autohint.h" 1
# 77 "../../../libs/freetype/include/freetype/internal/autohint.h"



  typedef struct FT_AutoHinterRec_ *FT_AutoHinter;
# 104 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalGetFunc)( FT_AutoHinter hinter,
                                  FT_Face face,
                                  void** global_hints,
                                  long* global_len );
# 126 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalDoneFunc)( FT_AutoHinter hinter,
                                   void* global );
# 146 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef void
  (*FT_AutoHinter_GlobalResetFunc)( FT_AutoHinter hinter,
                                    FT_Face face );
# 174 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef FT_Error
  (*FT_AutoHinter_GlyphLoadFunc)( FT_AutoHinter hinter,
                                  FT_GlyphSlot slot,
                                  FT_Size size,
                                  FT_UInt glyph_index,
                                  FT_Int32 load_flags );
# 190 "../../../libs/freetype/include/freetype/internal/autohint.h"
  typedef struct FT_AutoHinter_InterfaceRec_
  {
    FT_AutoHinter_GlobalResetFunc reset_face;
    FT_AutoHinter_GlobalGetFunc get_global_hints;
    FT_AutoHinter_GlobalDoneFunc done_global_hints;
    FT_AutoHinter_GlyphLoadFunc load_glyph;

  } FT_AutoHinter_InterfaceRec, *FT_AutoHinter_Interface;
# 239 "../../../libs/freetype/include/freetype/internal/autohint.h"

# 37 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftserv.h" 1
# 35 "../../../libs/freetype/include/freetype/internal/ftserv.h"

# 150 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceDescRec_
  {
    const char* serv_id;
    const void* serv_data;

  } FT_ServiceDescRec;

  typedef const FT_ServiceDescRec* FT_ServiceDesc;
# 608 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  extern FT_Pointer
  ft_service_list_lookup( FT_ServiceDesc service_descriptors,
                          const char* service_id );
# 634 "../../../libs/freetype/include/freetype/internal/ftserv.h"
  typedef struct FT_ServiceCacheRec_
  {
    FT_Pointer service_POSTSCRIPT_FONT_NAME;
    FT_Pointer service_MULTI_MASTERS;
    FT_Pointer service_GLYPH_DICT;
    FT_Pointer service_PFR_METRICS;
    FT_Pointer service_WINFNT;

  } FT_ServiceCacheRec, *FT_ServiceCache;
# 758 "../../../libs/freetype/include/freetype/internal/ftserv.h"

# 38 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2
# 1 "../../../libs/freetype/include/freetype/internal/ftpic.h" 1
# 30 "../../../libs/freetype/include/freetype/internal/ftpic.h"

# 66 "../../../libs/freetype/include/freetype/internal/ftpic.h"

# 39 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2


# 1 "../../../libs/freetype/include/freetype/ftincrem.h" 1
# 32 "../../../libs/freetype/include/freetype/ftincrem.h"

# 84 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_IncrementalRec_* FT_Incremental;
# 115 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_MetricsRec_
  {
    FT_Long bearing_x;
    FT_Long bearing_y;
    FT_Long advance;
    FT_Long advance_v;

  } FT_Incremental_MetricsRec;
# 134 "../../../libs/freetype/include/freetype/ftincrem.h"
   typedef struct FT_Incremental_MetricsRec_* FT_Incremental_Metrics;
# 178 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Error
  (*FT_Incremental_GetGlyphDataFunc)( FT_Incremental incremental,
                                      FT_UInt glyph_index,
                                      FT_Data* adata );
# 203 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef void
  (*FT_Incremental_FreeGlyphDataFunc)( FT_Incremental incremental,
                                       FT_Data* data );
# 240 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Error
  (*FT_Incremental_GetGlyphMetricsFunc)
                      ( FT_Incremental incremental,
                        FT_UInt glyph_index,
                        FT_Bool vertical,
                        FT_Incremental_MetricsRec *ametrics );
# 269 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_FuncsRec_
  {
    FT_Incremental_GetGlyphDataFunc get_glyph_data;
    FT_Incremental_FreeGlyphDataFunc free_glyph_data;
    FT_Incremental_GetGlyphMetricsFunc get_glyph_metrics;

  } FT_Incremental_FuncsRec;
# 314 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef struct FT_Incremental_InterfaceRec_
  {
    const FT_Incremental_FuncsRec* funcs;
    FT_Incremental object;

  } FT_Incremental_InterfaceRec;
# 331 "../../../libs/freetype/include/freetype/ftincrem.h"
  typedef FT_Incremental_InterfaceRec* FT_Incremental_Interface;
# 349 "../../../libs/freetype/include/freetype/ftincrem.h"

# 42 "../../../libs/freetype/include/freetype/internal/ftobjs.h" 2




# 128 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_CMapRec_* FT_CMap;


  typedef const struct FT_CMap_ClassRec_* FT_CMap_Class;


  typedef struct FT_CMapRec_
  {
    FT_CharMapRec charmap;
    FT_CMap_Class clazz;

  } FT_CMapRec;
# 152 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef FT_Error
  (*FT_CMap_InitFunc)( FT_CMap cmap,
                       FT_Pointer init_data );

  typedef void
  (*FT_CMap_DoneFunc)( FT_CMap cmap );

  typedef FT_UInt
  (*FT_CMap_CharIndexFunc)( FT_CMap cmap,
                            FT_UInt32 char_code );

  typedef FT_UInt
  (*FT_CMap_CharNextFunc)( FT_CMap cmap,
                           FT_UInt32 *achar_code );

  typedef FT_UInt
  (*FT_CMap_CharVarIndexFunc)( FT_CMap cmap,
                               FT_CMap unicode_cmap,
                               FT_UInt32 char_code,
                               FT_UInt32 variant_selector );

  typedef FT_Bool
  (*FT_CMap_CharVarIsDefaultFunc)( FT_CMap cmap,
                                   FT_UInt32 char_code,
                                   FT_UInt32 variant_selector );

  typedef FT_UInt32 *
  (*FT_CMap_VariantListFunc)( FT_CMap cmap,
                              FT_Memory mem );

  typedef FT_UInt32 *
  (*FT_CMap_CharVariantListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 char_code );

  typedef FT_UInt32 *
  (*FT_CMap_VariantCharListFunc)( FT_CMap cmap,
                                  FT_Memory mem,
                                  FT_UInt32 variant_selector );


  typedef struct FT_CMap_ClassRec_
  {
    FT_ULong size;
    FT_CMap_InitFunc init;
    FT_CMap_DoneFunc done;
    FT_CMap_CharIndexFunc char_index;
    FT_CMap_CharNextFunc char_next;




    FT_CMap_CharVarIndexFunc char_var_index;
    FT_CMap_CharVarIsDefaultFunc char_var_default;
    FT_CMap_VariantListFunc variant_list;
    FT_CMap_CharVariantListFunc charvariant_list;
    FT_CMap_VariantCharListFunc variantchar_list;

  } FT_CMap_ClassRec;
# 286 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_CMap_New( FT_CMap_Class clazz,
               FT_Pointer init_data,
               FT_CharMap charmap,
               FT_CMap *acmap );


  extern void
  FT_CMap_Done( FT_CMap cmap );
# 356 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Face_InternalRec_
  {
    FT_Matrix transform_matrix;
    FT_Vector transform_delta;
    FT_Int transform_flags;

    FT_ServiceCacheRec services;


    FT_Incremental_InterfaceRec* incremental_interface;


    FT_Bool ignore_unpatented_hinter;
    FT_Int refcount;

  } FT_Face_InternalRec;
# 410 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_Slot_InternalRec_
  {
    FT_GlyphLoader loader;
    FT_UInt flags;
    FT_Bool glyph_transformed;
    FT_Matrix glyph_matrix;
    FT_Vector glyph_delta;
    void* glyph_hints;

  } FT_GlyphSlot_InternalRec;
# 472 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_ModuleRec_
  {
    FT_Module_Class* clazz;
    FT_Library library;
    FT_Memory memory;

  } FT_ModuleRec;
# 534 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern const void*
  FT_Get_Module_Interface( FT_Library library,
                           const char* mod_name );

  extern FT_Pointer
  ft_module_get_service( FT_Module module,
                         const char* service_id );
# 595 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Error
  FT_New_GlyphSlot( FT_Face face,
                    FT_GlyphSlot *aslot );
# 613 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_GlyphSlot( FT_GlyphSlot slot );
# 630 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Select_Metrics( FT_Face face,
                     FT_ULong strike_index );



  extern void
  FT_Request_Metrics( FT_Face face,
                      FT_Size_Request req );



  extern FT_Error
  FT_Match_Size( FT_Face face,
                 FT_Size_Request req,
                 FT_Bool ignore_width,
                 FT_ULong* size_index );




  extern void
  ft_synthesize_vertical_metrics( FT_Glyph_Metrics* metrics,
                                  FT_Pos advance );




  extern void
  ft_glyphslot_free_bitmap( FT_GlyphSlot slot );



  extern FT_Error
  ft_glyphslot_alloc_bitmap( FT_GlyphSlot slot,
                             FT_ULong size );




  extern void
  ft_glyphslot_set_bitmap( FT_GlyphSlot slot,
                           FT_Byte* buffer );
# 694 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_RendererRec_
  {
    FT_ModuleRec root;
    FT_Renderer_Class* clazz;
    FT_Glyph_Format glyph_format;
    FT_Glyph_Class glyph_class;

    FT_Raster raster;
    FT_Raster_RenderFunc raster_render;
    FT_Renderer_RenderFunc render;

  } FT_RendererRec;
# 750 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_DriverRec_
  {
    FT_ModuleRec root;
    FT_Driver_Class clazz;
    FT_ListRec faces_list;
    FT_GlyphLoader glyph_loader;

  } FT_DriverRec;
# 785 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef void (*FT_Bitmap_LcdFilterFunc)( FT_Bitmap* bitmap,
                                            FT_Render_Mode render_mode,
                                            FT_Library library );
# 859 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  typedef struct FT_LibraryRec_
  {
    FT_Memory memory;

    FT_Int version_major;
    FT_Int version_minor;
    FT_Int version_patch;

    FT_UInt num_modules;
    FT_Module modules[32];

    FT_ListRec renderers;
    FT_Renderer cur_renderer;
    FT_Module auto_hinter;

    FT_Byte* raster_pool;

    FT_ULong raster_pool_size;

    FT_DebugHook_Func debug_hooks[4];


    FT_LcdFilter lcd_filter;
    FT_Int lcd_extra;
    FT_Byte lcd_weights[7];
    FT_Bitmap_LcdFilterFunc lcd_filter_func;






    FT_Int refcount;

  } FT_LibraryRec;


  extern FT_Renderer
  FT_Lookup_Renderer( FT_Library library,
                      FT_Glyph_Format format,
                      FT_ListNode* node );

  extern FT_Error
  FT_Render_Glyph_Internal( FT_Library library,
                            FT_GlyphSlot slot,
                            FT_Render_Mode render_mode );

  typedef const char*
  (*FT_Face_GetPostscriptNameFunc)( FT_Face face );

  typedef FT_Error
  (*FT_Face_GetGlyphNameFunc)( FT_Face face,
                               FT_UInt glyph_index,
                               FT_Pointer buffer,
                               FT_UInt buffer_max );

  typedef FT_UInt
  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face face,
                                    FT_String* glyph_name );
# 933 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Memory
  FT_New_Memory( void );
# 948 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern void
  FT_Done_Memory( FT_Memory memory );
# 961 "../../../libs/freetype/include/freetype/internal/ftobjs.h"
  extern FT_Raster_Funcs ft_default_raster;
# 1569 "../../../libs/freetype/include/freetype/internal/ftobjs.h"

# 22 "../../../libs/freetype/src/autofit/afpic.c" 2
# 1 "../../../libs/freetype/src/autofit/afpic.h" 1
# 23 "../../../libs/freetype/src/autofit/afpic.c" 2
# 1 "../../../libs/freetype/src/autofit/afglobal.h" 1
# 24 "../../../libs/freetype/src/autofit/afglobal.h"
# 1 "../../../libs/freetype/src/autofit/aftypes.h" 1
# 38 "../../../libs/freetype/src/autofit/aftypes.h"
# 1 "../../../libs/freetype/include/freetype/ftoutln.h" 1
# 34 "../../../libs/freetype/include/freetype/ftoutln.h"

# 118 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Decompose( FT_Outline* outline,
                        const FT_Outline_Funcs* func_interface,
                        void* user );
# 154 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_New( FT_Library library,
                  FT_UInt numPoints,
                  FT_Int numContours,
                  FT_Outline *anoutline );


  extern FT_Error
  FT_Outline_New_Internal( FT_Memory memory,
                           FT_UInt numPoints,
                           FT_Int numContours,
                           FT_Outline *anoutline );
# 192 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Done( FT_Library library,
                   FT_Outline* outline );


  extern FT_Error
  FT_Outline_Done_Internal( FT_Memory memory,
                            FT_Outline* outline );
# 216 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Check( FT_Outline* outline );
# 246 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Get_CBox( const FT_Outline* outline,
                       FT_BBox *acbox );
# 267 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Translate( const FT_Outline* outline,
                        FT_Pos xOffset,
                        FT_Pos yOffset );
# 292 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Copy( const FT_Outline* source,
                   FT_Outline *target );
# 316 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Transform( const FT_Outline* outline,
                        const FT_Matrix* matrix );
# 364 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Embolden( FT_Outline* outline,
                       FT_Pos strength );
# 380 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_EmboldenXY( FT_Outline* outline,
                         FT_Pos xstrength,
                         FT_Pos ystrength );
# 405 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern void
  FT_Outline_Reverse( FT_Outline* outline );
# 440 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Get_Bitmap( FT_Library library,
                         FT_Outline* outline,
                         const FT_Bitmap *abitmap );
# 482 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Error
  FT_Outline_Render( FT_Library library,
                     FT_Outline* outline,
                     FT_Raster_Params* params );
# 523 "../../../libs/freetype/include/freetype/ftoutln.h"
  typedef enum FT_Orientation_
  {
    FT_ORIENTATION_TRUETYPE = 0,
    FT_ORIENTATION_POSTSCRIPT = 1,
    FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE,
    FT_ORIENTATION_FILL_LEFT = FT_ORIENTATION_POSTSCRIPT,
    FT_ORIENTATION_NONE

  } FT_Orientation;
# 558 "../../../libs/freetype/include/freetype/ftoutln.h"
  extern FT_Orientation
  FT_Outline_Get_Orientation( FT_Outline* outline );





# 39 "../../../libs/freetype/src/autofit/aftypes.h" 2

# 1 "../../../libs/freetype/include/freetype/internal/ftdebug.h" 1
# 33 "../../../libs/freetype/include/freetype/internal/ftdebug.h"

# 116 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern FT_Int
  FT_Trace_Get_Count( void );
# 143 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern const char*
  FT_Trace_Get_Name( FT_Int idx );
# 247 "../../../libs/freetype/include/freetype/internal/ftdebug.h"
  extern void
  ft_debug_init( void );


# 41 "../../../libs/freetype/src/autofit/aftypes.h" 2

# 1 "../../../libs/freetype/src/autofit/afblue.h" 1
# 26 "../../../libs/freetype/src/autofit/afblue.h"

# 75 "../../../libs/freetype/src/autofit/afblue.h"
  typedef enum AF_Blue_String_
  {
    AF_BLUE_STRING_ARABIC_TOP = 0,
    AF_BLUE_STRING_ARABIC_BOTTOM = 13,
    AF_BLUE_STRING_ARABIC_JOIN = 24,
    AF_BLUE_STRING_CYRILLIC_CAPITAL_TOP = 27,
    AF_BLUE_STRING_CYRILLIC_CAPITAL_BOTTOM = 44,
    AF_BLUE_STRING_CYRILLIC_SMALL = 61,
    AF_BLUE_STRING_CYRILLIC_SMALL_DESCENDER = 78,
    AF_BLUE_STRING_DEVANAGARI_BASE = 85,
    AF_BLUE_STRING_DEVANAGARI_TOP = 110,
    AF_BLUE_STRING_DEVANAGARI_HEAD = 135,
    AF_BLUE_STRING_DEVANAGARI_BOTTOM = 160,
    AF_BLUE_STRING_GREEK_CAPITAL_TOP = 167,
    AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM = 182,
    AF_BLUE_STRING_GREEK_SMALL_BETA_TOP = 195,
    AF_BLUE_STRING_GREEK_SMALL = 208,
    AF_BLUE_STRING_GREEK_SMALL_DESCENDER = 225,
    AF_BLUE_STRING_HEBREW_TOP = 242,
    AF_BLUE_STRING_HEBREW_BOTTOM = 259,
    AF_BLUE_STRING_HEBREW_DESCENDER = 272,
    AF_BLUE_STRING_LAO_TOP = 283,
    AF_BLUE_STRING_LAO_BOTTOM = 308,
    AF_BLUE_STRING_LAO_ASCENDER = 333,
    AF_BLUE_STRING_LAO_LARGE_ASCENDER = 346,
    AF_BLUE_STRING_LAO_DESCENDER = 356,
    AF_BLUE_STRING_LATIN_CAPITAL_TOP = 375,
    AF_BLUE_STRING_LATIN_CAPITAL_BOTTOM = 384,
    AF_BLUE_STRING_LATIN_SMALL_F_TOP = 393,
    AF_BLUE_STRING_LATIN_SMALL = 401,
    AF_BLUE_STRING_LATIN_SMALL_DESCENDER = 409,
    AF_BLUE_STRING_LATIN_SUBS_CAPITAL_TOP = 415,
    AF_BLUE_STRING_LATIN_SUBS_CAPITAL_BOTTOM = 431,
    AF_BLUE_STRING_LATIN_SUBS_SMALL_F_TOP = 447,
    AF_BLUE_STRING_LATIN_SUBS_SMALL = 463,
    AF_BLUE_STRING_LATIN_SUBS_SMALL_DESCENDER = 491,
    AF_BLUE_STRING_LATIN_SUPS_CAPITAL_TOP = 507,
    AF_BLUE_STRING_LATIN_SUPS_CAPITAL_BOTTOM = 531,
    AF_BLUE_STRING_LATIN_SUPS_SMALL_F_TOP = 553,
    AF_BLUE_STRING_LATIN_SUPS_SMALL = 573,
    AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER = 592,
    AF_BLUE_STRING_TELUGU_TOP = 601,
    AF_BLUE_STRING_TELUGU_BOTTOM = 623,
    AF_BLUE_STRING_THAI_TOP = 645,
    AF_BLUE_STRING_THAI_BOTTOM = 664,
    AF_BLUE_STRING_THAI_ASCENDER = 686,
    AF_BLUE_STRING_THAI_LARGE_ASCENDER = 696,
    AF_BLUE_STRING_THAI_DESCENDER = 706,
    AF_BLUE_STRING_THAI_LARGE_DESCENDER = 719,
    AF_BLUE_STRING_THAI_DIGIT_TOP = 726,
    af_blue_1_1 = 735,

    AF_BLUE_STRING_CJK_TOP = af_blue_1_1 + 1,
    AF_BLUE_STRING_CJK_BOTTOM = af_blue_1_1 + 153,
    af_blue_1_1_1 = af_blue_1_1 + 304,





    af_blue_1_1_2 = af_blue_1_1_1 + 0,

    af_blue_1_2 = af_blue_1_1_2 + 0,





    AF_BLUE_STRING_MAX

  } AF_Blue_String;


  extern const char
  af_blue_strings[];
# 181 "../../../libs/freetype/src/autofit/afblue.h"
  typedef enum AF_Blue_Stringset_
  {
    AF_BLUE_STRINGSET_ARAB = 0,
    AF_BLUE_STRINGSET_CYRL = 4,
    AF_BLUE_STRINGSET_DEVA = 10,
    AF_BLUE_STRINGSET_GREK = 16,
    AF_BLUE_STRINGSET_HEBR = 23,
    AF_BLUE_STRINGSET_LAO = 27,
    AF_BLUE_STRINGSET_LATN = 33,
    AF_BLUE_STRINGSET_LATB = 40,
    AF_BLUE_STRINGSET_LATP = 47,
    AF_BLUE_STRINGSET_TELU = 54,
    AF_BLUE_STRINGSET_THAI = 57,
    af_blue_2_1 = 65,

    AF_BLUE_STRINGSET_HANI = af_blue_2_1 + 0,
    af_blue_2_1_1 = af_blue_2_1 + 2,



    af_blue_2_1_2 = af_blue_2_1_1 + 0,

    af_blue_2_2 = af_blue_2_1_2 + 1,





    AF_BLUE_STRINGSET_MAX

  } AF_Blue_Stringset;


  typedef struct AF_Blue_StringRec_
  {
    AF_Blue_String string;
    FT_UShort properties;

  } AF_Blue_StringRec;


  extern const AF_Blue_StringRec
  af_blue_stringsets[];




# 43 "../../../libs/freetype/src/autofit/aftypes.h" 2







# 77 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef struct AF_WidthRec_
  {
    FT_Pos org;
    FT_Pos cur;
    FT_Pos fit;

  } AF_WidthRec, *AF_Width;


  static void
  af_sort_pos( FT_UInt count,
               FT_Pos* table );

  static void
  af_sort_and_quantize_widths( FT_UInt* count,
                               AF_Width widths,
                               FT_Pos threshold );
# 110 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef FT_Int AF_Angle;
# 156 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef struct AF_GlyphHintsRec_* AF_GlyphHints;
# 178 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef struct AF_ScalerRec_
  {
    FT_Face face;
    FT_Fixed x_scale;
    FT_Fixed y_scale;
    FT_Pos x_delta;
    FT_Pos y_delta;
    FT_Render_Mode render_mode;
    FT_UInt32 flags;

  } AF_ScalerRec, *AF_Scaler;
# 198 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef struct AF_StyleMetricsRec_* AF_StyleMetrics;




  typedef FT_Error
  (*AF_WritingSystem_InitMetricsFunc)( AF_StyleMetrics metrics,
                                       FT_Face face );

  typedef void
  (*AF_WritingSystem_ScaleMetricsFunc)( AF_StyleMetrics metrics,
                                        AF_Scaler scaler );

  typedef void
  (*AF_WritingSystem_DoneMetricsFunc)( AF_StyleMetrics metrics );

  typedef void
  (*AF_WritingSystem_GetStdWidthsFunc)( AF_StyleMetrics metrics,
                                        FT_Pos* stdHW,
                                        FT_Pos* stdVW );


  typedef FT_Error
  (*AF_WritingSystem_InitHintsFunc)( AF_GlyphHints hints,
                                     AF_StyleMetrics metrics );

  typedef void
  (*AF_WritingSystem_ApplyHintsFunc)( FT_UInt glyph_index,
                                      AF_GlyphHints hints,
                                      FT_Outline* outline,
                                      AF_StyleMetrics metrics );
# 264 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef enum AF_WritingSystem_
  {

# 1 "../../../libs/freetype/src/autofit/afwrtsys.h" 1
# 43 "../../../libs/freetype/src/autofit/afwrtsys.h"
  AF_WRITING_SYSTEM_DUMMY,
  AF_WRITING_SYSTEM_LATIN,
  AF_WRITING_SYSTEM_CJK,
  AF_WRITING_SYSTEM_INDIC,
# 268 "../../../libs/freetype/src/autofit/aftypes.h" 2

    AF_WRITING_SYSTEM_MAX

  } AF_WritingSystem;




  typedef struct AF_WritingSystemClassRec_
  {
    AF_WritingSystem writing_system;

    FT_Offset style_metrics_size;
    AF_WritingSystem_InitMetricsFunc style_metrics_init;
    AF_WritingSystem_ScaleMetricsFunc style_metrics_scale;
    AF_WritingSystem_DoneMetricsFunc style_metrics_done;
    AF_WritingSystem_GetStdWidthsFunc style_metrics_getstdw;

    AF_WritingSystem_InitHintsFunc style_hints_init;
    AF_WritingSystem_ApplyHintsFunc style_hints_apply;

  } AF_WritingSystemClassRec;

  typedef const AF_WritingSystemClassRec* AF_WritingSystemClass;
# 316 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef enum AF_Script_
  {

# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  AF_SCRIPT_ARAB,




  AF_SCRIPT_CYRL,




  AF_SCRIPT_DEVA,




  AF_SCRIPT_GREK,




  AF_SCRIPT_HEBR,





  AF_SCRIPT_LAO,




  AF_SCRIPT_LATN,




  AF_SCRIPT_LATB,




  AF_SCRIPT_LATP,




  AF_SCRIPT_NONE,





  AF_SCRIPT_TELU,




  AF_SCRIPT_THAI,






  AF_SCRIPT_BENG,




  AF_SCRIPT_GUJR,




  AF_SCRIPT_GURU,




  AF_SCRIPT_KNDA,




  AF_SCRIPT_LIMB,




  AF_SCRIPT_MLYM,




  AF_SCRIPT_ORYA,




  AF_SCRIPT_SINH,




  AF_SCRIPT_SUND,




  AF_SCRIPT_SYLO,




  AF_SCRIPT_TAML,




  AF_SCRIPT_TIBT,
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  AF_SCRIPT_HANI,
# 320 "../../../libs/freetype/src/autofit/aftypes.h" 2

    AF_SCRIPT_MAX

  } AF_Script;


  typedef struct AF_Script_UniRangeRec_
  {
    FT_UInt32 first;
    FT_UInt32 last;

  } AF_Script_UniRangeRec;



  typedef const AF_Script_UniRangeRec* AF_Script_UniRange;


  typedef struct AF_ScriptClassRec_
  {
    AF_Script script;


    AF_Script_UniRange script_uni_ranges;
    AF_Script_UniRange script_uni_nonbase_ranges;

    FT_UInt32 standard_char1;
    FT_UInt32 standard_char2;
    FT_UInt32 standard_char3;

  } AF_ScriptClassRec;

  typedef const AF_ScriptClassRec* AF_ScriptClass;
# 408 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef enum AF_Coverage_
  {
# 1 "../../../libs/freetype/src/autofit/afcover.h" 1
# 35 "../../../libs/freetype/src/autofit/afcover.h"
  AF_COVERAGE_PETITE_CAPITALS_FROM_CAPITALS,



  AF_COVERAGE_SMALL_CAPITALS_FROM_CAPITALS,
# 66 "../../../libs/freetype/src/autofit/afcover.h"
  AF_COVERAGE_ORDINALS,



  AF_COVERAGE_PETITE_CAPITALS,



  AF_COVERAGE_RUBY,



  AF_COVERAGE_SCIENTIFIC_INFERIORS,



  AF_COVERAGE_SMALL_CAPITALS,



  AF_COVERAGE_SUBSCRIPT,



  AF_COVERAGE_SUPERSCRIPT,



  AF_COVERAGE_TITLING,
# 411 "../../../libs/freetype/src/autofit/aftypes.h" 2

    AF_COVERAGE_DEFAULT

  } AF_Coverage;
# 435 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef enum AF_Style_
  {

# 1 "../../../libs/freetype/src/autofit/afstyles.h" 1
# 86 "../../../libs/freetype/src/autofit/afstyles.h"
  AF_STYLE_ARAB_DFLT,






  AF_STYLE_CYRL_C2CP, AF_STYLE_CYRL_C2SC, AF_STYLE_CYRL_ORDN, AF_STYLE_CYRL_PCAP, AF_STYLE_CYRL_SINF, AF_STYLE_CYRL_SMCP, AF_STYLE_CYRL_SUBS, AF_STYLE_CYRL_SUPS, AF_STYLE_CYRL_TITL, AF_STYLE_CYRL_DFLT,

  AF_STYLE_DEVA_DFLT,






  AF_STYLE_GREK_C2CP, AF_STYLE_GREK_C2SC, AF_STYLE_GREK_ORDN, AF_STYLE_GREK_PCAP, AF_STYLE_GREK_SINF, AF_STYLE_GREK_SMCP, AF_STYLE_GREK_SUBS, AF_STYLE_GREK_SUPS, AF_STYLE_GREK_TITL, AF_STYLE_GREK_DFLT,

  AF_STYLE_HEBR_DFLT,






  AF_STYLE_LAO_DFLT,






  AF_STYLE_LATN_C2CP, AF_STYLE_LATN_C2SC, AF_STYLE_LATN_ORDN, AF_STYLE_LATN_PCAP, AF_STYLE_LATN_SINF, AF_STYLE_LATN_SMCP, AF_STYLE_LATN_SUBS, AF_STYLE_LATN_SUPS, AF_STYLE_LATN_TITL, AF_STYLE_LATN_DFLT,

  AF_STYLE_LATB_DFLT,






  AF_STYLE_LATP_DFLT,
# 143 "../../../libs/freetype/src/autofit/afstyles.h"
  AF_STYLE_NONE_DFLT,






  AF_STYLE_TELU_DFLT,






  AF_STYLE_THAI_DFLT,
# 176 "../../../libs/freetype/src/autofit/afstyles.h"
  AF_STYLE_BENG_DFLT,
  AF_STYLE_GUJR_DFLT,
  AF_STYLE_GURU_DFLT,
  AF_STYLE_KNDA_DFLT,
  AF_STYLE_LIMB_DFLT,
  AF_STYLE_MLYM_DFLT,
  AF_STYLE_ORYA_DFLT,
  AF_STYLE_SINH_DFLT,
  AF_STYLE_SUND_DFLT,
  AF_STYLE_SYLO_DFLT,
  AF_STYLE_TAML_DFLT,
  AF_STYLE_TIBT_DFLT,





  AF_STYLE_HANI_DFLT,
# 439 "../../../libs/freetype/src/autofit/aftypes.h" 2

    AF_STYLE_MAX

  } AF_Style;


  typedef struct AF_StyleClassRec_
  {
    AF_Style style;

    AF_WritingSystem writing_system;
    AF_Script script;
    AF_Blue_Stringset blue_stringset;
    AF_Coverage coverage;

  } AF_StyleClassRec;

  typedef const AF_StyleClassRec* AF_StyleClass;
# 467 "../../../libs/freetype/src/autofit/aftypes.h"
  typedef struct AF_FaceGlobalsRec_* AF_FaceGlobals;





  typedef struct AF_StyleMetricsRec_
  {
    AF_StyleClass style_class;
    AF_ScalerRec scaler;
    FT_Bool digits_have_same_width;

    AF_FaceGlobals globals;

  } AF_StyleMetricsRec;
# 645 "../../../libs/freetype/src/autofit/aftypes.h"

# 25 "../../../libs/freetype/src/autofit/afglobal.h" 2
# 1 "../../../libs/freetype/src/autofit/afmodule.h" 1
# 27 "../../../libs/freetype/src/autofit/afmodule.h"








  typedef struct AF_ModuleRec_
  {
    FT_ModuleRec root;

    FT_UInt fallback_style;
    FT_UInt default_script;



    FT_Bool no_stem_darkening;
    FT_Int darken_params[8];

  } AF_ModuleRec, *AF_Module;


extern const FT_Module_Class autofit_module_class;



# 26 "../../../libs/freetype/src/autofit/afglobal.h" 2
# 1 "../../../libs/freetype/src/autofit/hbshim.h" 1
# 29 "../../../libs/freetype/src/autofit/hbshim.h"
# 1 "../../../libs/harfbuzz-ng/src/hb.h" 1
# 31 "../../../libs/harfbuzz-ng/src/hb.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-blob.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-blob.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 65 "../../../libs/harfbuzz-ng/src/hb-common.h"
# 1 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdint.h" 1 3 4
# 9 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdint.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 1 3 4
# 26 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wchar.h" 1 3 4
# 27 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 2 3 4
# 1 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\bits\\wordsize.h" 1 3 4
# 28 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 2 3 4
# 48 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 125 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 3 4
typedef int intptr_t;


typedef unsigned int uintptr_t;
# 137 "d:\\devtools\\linaro\\arm-linux-gnueabihf\\libc\\usr\\include\\stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 10 "d:\\devtools\\linaro\\lib\\gcc\\arm-linux-gnueabihf\\4.8.3\\include\\stdint.h" 2 3 4
# 66 "../../../libs/harfbuzz-ng/src/hb-common.h" 2







typedef int hb_bool_t;

typedef uint32_t hb_codepoint_t;
typedef int32_t hb_position_t;
typedef uint32_t hb_mask_t;

typedef union _hb_var_int_t {
  uint32_t u32;
  int32_t i32;
  uint16_t u16[2];
  int16_t i16[2];
  uint8_t u8[4];
  int8_t i8[4];
} hb_var_int_t;




typedef uint32_t hb_tag_t;
# 101 "../../../libs/harfbuzz-ng/src/hb-common.h"
hb_tag_t
hb_tag_from_string (const char *str, int len);


void
hb_tag_to_string (hb_tag_t tag, char *buf);




typedef enum {
  HB_DIRECTION_INVALID = 0,
  HB_DIRECTION_LTR = 4,
  HB_DIRECTION_RTL,
  HB_DIRECTION_TTB,
  HB_DIRECTION_BTT
} hb_direction_t;


hb_direction_t
hb_direction_from_string (const char *str, int len);

const char *
hb_direction_to_string (hb_direction_t direction);
# 137 "../../../libs/harfbuzz-ng/src/hb-common.h"
typedef const struct hb_language_impl_t *hb_language_t;


hb_language_t
hb_language_from_string (const char *str, int len);

const char *
hb_language_to_string (hb_language_t language);



hb_language_t
hb_language_get_default (void);







typedef enum
{
          HB_SCRIPT_COMMON = ((hb_tag_t)((((uint8_t)('Z'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('y'))<<8)|((uint8_t)('y')))),
          HB_SCRIPT_INHERITED = ((hb_tag_t)((((uint8_t)('Z'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('h')))),
          HB_SCRIPT_UNKNOWN = ((hb_tag_t)((((uint8_t)('Z'))<<24)|(((uint8_t)('z'))<<16)|(((uint8_t)('z'))<<8)|((uint8_t)('z')))),

          HB_SCRIPT_ARABIC = ((hb_tag_t)((((uint8_t)('A'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('b')))),
          HB_SCRIPT_ARMENIAN = ((hb_tag_t)((((uint8_t)('A'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('n')))),
          HB_SCRIPT_BENGALI = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_CYRILLIC = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('l')))),
          HB_SCRIPT_DEVANAGARI = ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('v'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_GEORGIAN = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('o'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_GREEK = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('e'))<<8)|((uint8_t)('k')))),
          HB_SCRIPT_GUJARATI = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('j'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_GURMUKHI = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('u')))),
          HB_SCRIPT_HANGUL = ((hb_tag_t)((((uint8_t)('H'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_HAN = ((hb_tag_t)((((uint8_t)('H'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_HEBREW = ((hb_tag_t)((((uint8_t)('H'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_HIRAGANA = ((hb_tag_t)((((uint8_t)('H'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_KANNADA = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('n'))<<16)|(((uint8_t)('d'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_KATAKANA = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_LAO = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('o'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_LATIN = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('t'))<<8)|((uint8_t)('n')))),
          HB_SCRIPT_MALAYALAM = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('l'))<<16)|(((uint8_t)('y'))<<8)|((uint8_t)('m')))),
          HB_SCRIPT_ORIYA = ((hb_tag_t)((((uint8_t)('O'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('y'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_TAMIL = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('l')))),
          HB_SCRIPT_TELUGU = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('u')))),
          HB_SCRIPT_THAI = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('i')))),

          HB_SCRIPT_TIBETAN = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('t')))),

          HB_SCRIPT_BOPOMOFO = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('o'))<<16)|(((uint8_t)('p'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_BRAILLE = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_CANADIAN_SYLLABICS = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('s')))),
          HB_SCRIPT_CHEROKEE = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('e'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_ETHIOPIC = ((hb_tag_t)((((uint8_t)('E'))<<24)|(((uint8_t)('t'))<<16)|(((uint8_t)('h'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_KHMER = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_MONGOLIAN = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('o'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_MYANMAR = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_OGHAM = ((hb_tag_t)((((uint8_t)('O'))<<24)|(((uint8_t)('g'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('m')))),
          HB_SCRIPT_RUNIC = ((hb_tag_t)((((uint8_t)('R'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_SINHALA = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('h')))),
          HB_SCRIPT_SYRIAC = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('c')))),
          HB_SCRIPT_THAANA = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_YI = ((hb_tag_t)((((uint8_t)('Y'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('i'))<<8)|((uint8_t)('i')))),

          HB_SCRIPT_DESERET = ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('s'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('t')))),
          HB_SCRIPT_GOTHIC = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('o'))<<16)|(((uint8_t)('t'))<<8)|((uint8_t)('h')))),
          HB_SCRIPT_OLD_ITALIC = ((hb_tag_t)((((uint8_t)('I'))<<24)|(((uint8_t)('t'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('l')))),

          HB_SCRIPT_BUHID = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('h'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_HANUNOO = ((hb_tag_t)((((uint8_t)('H'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_TAGALOG = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('g'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_TAGBANWA = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('g'))<<8)|((uint8_t)('b')))),

          HB_SCRIPT_CYPRIOT = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('p'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('t')))),
          HB_SCRIPT_LIMBU = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('b')))),
          HB_SCRIPT_LINEAR_B = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('b')))),
          HB_SCRIPT_OSMANYA = ((hb_tag_t)((((uint8_t)('O'))<<24)|(((uint8_t)('s'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_SHAVIAN = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('w')))),
          HB_SCRIPT_TAI_LE = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('e')))),
          HB_SCRIPT_UGARITIC = ((hb_tag_t)((((uint8_t)('U'))<<24)|(((uint8_t)('g'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('r')))),

          HB_SCRIPT_BUGINESE = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('g'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_COPTIC = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('o'))<<16)|(((uint8_t)('p'))<<8)|((uint8_t)('t')))),
          HB_SCRIPT_GLAGOLITIC = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('l'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_KHAROSHTHI = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_NEW_TAI_LUE = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('u')))),
          HB_SCRIPT_OLD_PERSIAN = ((hb_tag_t)((((uint8_t)('X'))<<24)|(((uint8_t)('p'))<<16)|(((uint8_t)('e'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_SYLOTI_NAGRI = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_TIFINAGH = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('f'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('g')))),

          HB_SCRIPT_BALINESE = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_CUNEIFORM = ((hb_tag_t)((((uint8_t)('X'))<<24)|(((uint8_t)('s'))<<16)|(((uint8_t)('u'))<<8)|((uint8_t)('x')))),
          HB_SCRIPT_NKO = ((hb_tag_t)((((uint8_t)('N'))<<24)|(((uint8_t)('k'))<<16)|(((uint8_t)('o'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_PHAGS_PA = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_PHOENICIAN = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('x')))),

          HB_SCRIPT_CARIAN = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_CHAM = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('m')))),
          HB_SCRIPT_KAYAH_LI = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_LEPCHA = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('p'))<<8)|((uint8_t)('c')))),
          HB_SCRIPT_LYCIAN = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('c'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_LYDIAN = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('y'))<<16)|(((uint8_t)('d'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_OL_CHIKI = ((hb_tag_t)((((uint8_t)('O'))<<24)|(((uint8_t)('l'))<<16)|(((uint8_t)('c'))<<8)|((uint8_t)('k')))),
          HB_SCRIPT_REJANG = ((hb_tag_t)((((uint8_t)('R'))<<24)|(((uint8_t)('j'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_SAURASHTRA = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('u'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_SUNDANESE = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_VAI = ((hb_tag_t)((((uint8_t)('V'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('i'))<<8)|((uint8_t)('i')))),

          HB_SCRIPT_AVESTAN = ((hb_tag_t)((((uint8_t)('A'))<<24)|(((uint8_t)('v'))<<16)|(((uint8_t)('s'))<<8)|((uint8_t)('t')))),
          HB_SCRIPT_BAMUM = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('u')))),
          HB_SCRIPT_EGYPTIAN_HIEROGLYPHS = ((hb_tag_t)((((uint8_t)('E'))<<24)|(((uint8_t)('g'))<<16)|(((uint8_t)('y'))<<8)|((uint8_t)('p')))),
          HB_SCRIPT_IMPERIAL_ARAMAIC = ((hb_tag_t)((((uint8_t)('A'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_INSCRIPTIONAL_PAHLAVI = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_INSCRIPTIONAL_PARTHIAN = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('t'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_JAVANESE = ((hb_tag_t)((((uint8_t)('J'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('v'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_KAITHI = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('t'))<<16)|(((uint8_t)('h'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_LISU = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('s'))<<8)|((uint8_t)('u')))),
          HB_SCRIPT_MEETEI_MAYEK = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('t'))<<16)|(((uint8_t)('e'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_OLD_SOUTH_ARABIAN = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('b')))),
          HB_SCRIPT_OLD_TURKIC = ((hb_tag_t)((((uint8_t)('O'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('k'))<<8)|((uint8_t)('h')))),
          HB_SCRIPT_SAMARITAN = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('m'))<<8)|((uint8_t)('r')))),
          HB_SCRIPT_TAI_THAM = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_TAI_VIET = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('v'))<<8)|((uint8_t)('t')))),

          HB_SCRIPT_BATAK = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('t'))<<8)|((uint8_t)('k')))),
          HB_SCRIPT_BRAHMI = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('h')))),
          HB_SCRIPT_MANDAIC = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('d')))),

          HB_SCRIPT_CHAKMA = ((hb_tag_t)((((uint8_t)('C'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('k'))<<8)|((uint8_t)('m')))),
          HB_SCRIPT_MEROITIC_CURSIVE = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('c')))),
          HB_SCRIPT_MEROITIC_HIEROGLYPHS = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_MIAO = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('l'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_SHARADA = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_SORA_SOMPENG = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('o'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_TAKRI = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('k'))<<8)|((uint8_t)('r')))),

          HB_SCRIPT_BASSA_VAH = ((hb_tag_t)((((uint8_t)('B'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('s'))<<8)|((uint8_t)('s')))),
          HB_SCRIPT_CAUCASIAN_ALBANIAN = ((hb_tag_t)((((uint8_t)('A'))<<24)|(((uint8_t)('g'))<<16)|(((uint8_t)('h'))<<8)|((uint8_t)('b')))),
          HB_SCRIPT_DUPLOYAN = ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('p'))<<8)|((uint8_t)('l')))),
          HB_SCRIPT_ELBASAN = ((hb_tag_t)((((uint8_t)('E'))<<24)|(((uint8_t)('l'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_GRANTHA = ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('n')))),
          HB_SCRIPT_KHOJKI = ((hb_tag_t)((((uint8_t)('K'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('o'))<<8)|((uint8_t)('j')))),
          HB_SCRIPT_KHUDAWADI = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_LINEAR_A = ((hb_tag_t)((((uint8_t)('L'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('a')))),
          HB_SCRIPT_MAHAJANI = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('h'))<<8)|((uint8_t)('j')))),
          HB_SCRIPT_MANICHAEAN = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_MENDE_KIKAKUI = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_MODI = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('o'))<<16)|(((uint8_t)('d'))<<8)|((uint8_t)('i')))),
          HB_SCRIPT_MRO = ((hb_tag_t)((((uint8_t)('M'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('o'))<<8)|((uint8_t)('o')))),
          HB_SCRIPT_NABATAEAN = ((hb_tag_t)((((uint8_t)('N'))<<24)|(((uint8_t)('b'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('t')))),
          HB_SCRIPT_OLD_NORTH_ARABIAN = ((hb_tag_t)((((uint8_t)('N'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('b')))),
          HB_SCRIPT_OLD_PERMIC = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('e'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('m')))),
          HB_SCRIPT_PAHAWH_HMONG = ((hb_tag_t)((((uint8_t)('H'))<<24)|(((uint8_t)('m'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('g')))),
          HB_SCRIPT_PALMYRENE = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('m')))),
          HB_SCRIPT_PAU_CIN_HAU = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('u'))<<8)|((uint8_t)('c')))),
          HB_SCRIPT_PSALTER_PAHLAVI = ((hb_tag_t)((((uint8_t)('P'))<<24)|(((uint8_t)('h'))<<16)|(((uint8_t)('l'))<<8)|((uint8_t)('p')))),
          HB_SCRIPT_SIDDHAM = ((hb_tag_t)((((uint8_t)('S'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('d'))<<8)|((uint8_t)('d')))),
          HB_SCRIPT_TIRHUTA = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('h')))),
          HB_SCRIPT_WARANG_CITI = ((hb_tag_t)((((uint8_t)('W'))<<24)|(((uint8_t)('a'))<<16)|(((uint8_t)('r'))<<8)|((uint8_t)('a')))),


  HB_SCRIPT_INVALID = ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))),
# 309 "../../../libs/harfbuzz-ng/src/hb-common.h"
  _HB_SCRIPT_MAX_VALUE = ((hb_tag_t)((((uint8_t)(0xff))<<24)|(((uint8_t)(0xff))<<16)|(((uint8_t)(0xff))<<8)|((uint8_t)(0xff)))),
  _HB_SCRIPT_MAX_VALUE_SIGNED = ((hb_tag_t)((((uint8_t)(0x7f))<<24)|(((uint8_t)(0xff))<<16)|(((uint8_t)(0xff))<<8)|((uint8_t)(0xff))))

} hb_script_t;




hb_script_t
hb_script_from_iso15924_tag (hb_tag_t tag);



hb_script_t
hb_script_from_string (const char *s, int len);

hb_tag_t
hb_script_to_iso15924_tag (hb_script_t script);

hb_direction_t
hb_script_get_horizontal_direction (hb_script_t script);




typedef struct hb_user_data_key_t {

  char unused;
} hb_user_data_key_t;

typedef void (*hb_destroy_func_t) (void *user_data);



# 35 "../../../libs/harfbuzz-ng/src/hb-blob.h" 2


# 58 "../../../libs/harfbuzz-ng/src/hb-blob.h"
typedef enum {
  HB_MEMORY_MODE_DUPLICATE,
  HB_MEMORY_MODE_READONLY,
  HB_MEMORY_MODE_WRITABLE,
  HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
} hb_memory_mode_t;

typedef struct hb_blob_t hb_blob_t;

hb_blob_t *
hb_blob_create (const char *data,
  unsigned int length,
  hb_memory_mode_t mode,
  void *user_data,
  hb_destroy_func_t destroy);







hb_blob_t *
hb_blob_create_sub_blob (hb_blob_t *parent,
    unsigned int offset,
    unsigned int length);

hb_blob_t *
hb_blob_get_empty (void);

hb_blob_t *
hb_blob_reference (hb_blob_t *blob);

void
hb_blob_destroy (hb_blob_t *blob);

hb_bool_t
hb_blob_set_user_data (hb_blob_t *blob,
         hb_user_data_key_t *key,
         void * data,
         hb_destroy_func_t destroy,
         hb_bool_t replace);


void *
hb_blob_get_user_data (hb_blob_t *blob,
         hb_user_data_key_t *key);


void
hb_blob_make_immutable (hb_blob_t *blob);

hb_bool_t
hb_blob_is_immutable (hb_blob_t *blob);


unsigned int
hb_blob_get_length (hb_blob_t *blob);

const char *
hb_blob_get_data (hb_blob_t *blob, unsigned int *length);

char *
hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length);



# 32 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-buffer.h" 1
# 37 "../../../libs/harfbuzz-ng/src/hb-buffer.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 38 "../../../libs/harfbuzz-ng/src/hb-buffer.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-unicode.h" 1
# 38 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 39 "../../../libs/harfbuzz-ng/src/hb-unicode.h" 2







typedef enum
{
  HB_UNICODE_GENERAL_CATEGORY_CONTROL,
  HB_UNICODE_GENERAL_CATEGORY_FORMAT,
  HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED,
  HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE,
  HB_UNICODE_GENERAL_CATEGORY_SURROGATE,
  HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER,
  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER,
  HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER,
  HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER,
  HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER,
  HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK,
  HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK,
  HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK,
  HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER,
  HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER,
  HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER,
  HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION,
  HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL,
  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL,
  HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL,
  HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL,
  HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR,
  HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR,
  HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR
} hb_unicode_general_category_t;
# 87 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
typedef enum
{
  HB_UNICODE_COMBINING_CLASS_NOT_REORDERED = 0,
  HB_UNICODE_COMBINING_CLASS_OVERLAY = 1,
  HB_UNICODE_COMBINING_CLASS_NUKTA = 7,
  HB_UNICODE_COMBINING_CLASS_KANA_VOICING = 8,
  HB_UNICODE_COMBINING_CLASS_VIRAMA = 9,


  HB_UNICODE_COMBINING_CLASS_CCC10 = 10,
  HB_UNICODE_COMBINING_CLASS_CCC11 = 11,
  HB_UNICODE_COMBINING_CLASS_CCC12 = 12,
  HB_UNICODE_COMBINING_CLASS_CCC13 = 13,
  HB_UNICODE_COMBINING_CLASS_CCC14 = 14,
  HB_UNICODE_COMBINING_CLASS_CCC15 = 15,
  HB_UNICODE_COMBINING_CLASS_CCC16 = 16,
  HB_UNICODE_COMBINING_CLASS_CCC17 = 17,
  HB_UNICODE_COMBINING_CLASS_CCC18 = 18,
  HB_UNICODE_COMBINING_CLASS_CCC19 = 19,
  HB_UNICODE_COMBINING_CLASS_CCC20 = 20,
  HB_UNICODE_COMBINING_CLASS_CCC21 = 21,
  HB_UNICODE_COMBINING_CLASS_CCC22 = 22,
  HB_UNICODE_COMBINING_CLASS_CCC23 = 23,
  HB_UNICODE_COMBINING_CLASS_CCC24 = 24,
  HB_UNICODE_COMBINING_CLASS_CCC25 = 25,
  HB_UNICODE_COMBINING_CLASS_CCC26 = 26,


  HB_UNICODE_COMBINING_CLASS_CCC27 = 27,
  HB_UNICODE_COMBINING_CLASS_CCC28 = 28,
  HB_UNICODE_COMBINING_CLASS_CCC29 = 29,
  HB_UNICODE_COMBINING_CLASS_CCC30 = 30,
  HB_UNICODE_COMBINING_CLASS_CCC31 = 31,
  HB_UNICODE_COMBINING_CLASS_CCC32 = 32,
  HB_UNICODE_COMBINING_CLASS_CCC33 = 33,
  HB_UNICODE_COMBINING_CLASS_CCC34 = 34,
  HB_UNICODE_COMBINING_CLASS_CCC35 = 35,


  HB_UNICODE_COMBINING_CLASS_CCC36 = 36,


  HB_UNICODE_COMBINING_CLASS_CCC84 = 84,
  HB_UNICODE_COMBINING_CLASS_CCC91 = 91,


  HB_UNICODE_COMBINING_CLASS_CCC103 = 103,
  HB_UNICODE_COMBINING_CLASS_CCC107 = 107,


  HB_UNICODE_COMBINING_CLASS_CCC118 = 118,
  HB_UNICODE_COMBINING_CLASS_CCC122 = 122,


  HB_UNICODE_COMBINING_CLASS_CCC129 = 129,
  HB_UNICODE_COMBINING_CLASS_CCC130 = 130,
  HB_UNICODE_COMBINING_CLASS_CCC133 = 132,


  HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT = 200,
  HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW = 202,
  HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE = 214,
  HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT = 216,
  HB_UNICODE_COMBINING_CLASS_BELOW_LEFT = 218,
  HB_UNICODE_COMBINING_CLASS_BELOW = 220,
  HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT = 222,
  HB_UNICODE_COMBINING_CLASS_LEFT = 224,
  HB_UNICODE_COMBINING_CLASS_RIGHT = 226,
  HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT = 228,
  HB_UNICODE_COMBINING_CLASS_ABOVE = 230,
  HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT = 232,
  HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW = 233,
  HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE = 234,

  HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT = 240,

  HB_UNICODE_COMBINING_CLASS_INVALID = 255
} hb_unicode_combining_class_t;






typedef struct hb_unicode_funcs_t hb_unicode_funcs_t;





hb_unicode_funcs_t *
hb_unicode_funcs_get_default (void);


hb_unicode_funcs_t *
hb_unicode_funcs_create (hb_unicode_funcs_t *parent);

hb_unicode_funcs_t *
hb_unicode_funcs_get_empty (void);

hb_unicode_funcs_t *
hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs);

void
hb_unicode_funcs_destroy (hb_unicode_funcs_t *ufuncs);

hb_bool_t
hb_unicode_funcs_set_user_data (hb_unicode_funcs_t *ufuncs,
           hb_user_data_key_t *key,
           void * data,
           hb_destroy_func_t destroy,
    hb_bool_t replace);


void *
hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,
           hb_user_data_key_t *key);


void
hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs);

hb_bool_t
hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs);

hb_unicode_funcs_t *
hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs);
# 222 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
typedef hb_unicode_combining_class_t (*hb_unicode_combining_class_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t unicode,
           void *user_data);
typedef unsigned int (*hb_unicode_eastasian_width_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t unicode,
           void *user_data);
typedef hb_unicode_general_category_t (*hb_unicode_general_category_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t unicode,
           void *user_data);
typedef hb_codepoint_t (*hb_unicode_mirroring_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t unicode,
           void *user_data);
typedef hb_script_t (*hb_unicode_script_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t unicode,
           void *user_data);

typedef hb_bool_t (*hb_unicode_compose_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t a,
           hb_codepoint_t b,
           hb_codepoint_t *ab,
           void *user_data);
typedef hb_bool_t (*hb_unicode_decompose_func_t) (hb_unicode_funcs_t *ufuncs,
           hb_codepoint_t ab,
           hb_codepoint_t *a,
           hb_codepoint_t *b,
           void *user_data);
# 267 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
typedef unsigned int (*hb_unicode_decompose_compatibility_func_t) (hb_unicode_funcs_t *ufuncs,
            hb_codepoint_t u,
            hb_codepoint_t *decomposed,
            void *user_data);
# 288 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_combining_class_func (hb_unicode_funcs_t *ufuncs,
        hb_unicode_combining_class_func_t func,
        void *user_data, hb_destroy_func_t destroy);
# 304 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_eastasian_width_func (hb_unicode_funcs_t *ufuncs,
        hb_unicode_eastasian_width_func_t func,
        void *user_data, hb_destroy_func_t destroy);
# 320 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_general_category_func (hb_unicode_funcs_t *ufuncs,
         hb_unicode_general_category_func_t func,
         void *user_data, hb_destroy_func_t destroy);
# 336 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_mirroring_func (hb_unicode_funcs_t *ufuncs,
         hb_unicode_mirroring_func_t func,
         void *user_data, hb_destroy_func_t destroy);
# 352 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_script_func (hb_unicode_funcs_t *ufuncs,
      hb_unicode_script_func_t func,
      void *user_data, hb_destroy_func_t destroy);
# 368 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_compose_func (hb_unicode_funcs_t *ufuncs,
       hb_unicode_compose_func_t func,
       void *user_data, hb_destroy_func_t destroy);
# 384 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_decompose_func (hb_unicode_funcs_t *ufuncs,
         hb_unicode_decompose_func_t func,
         void *user_data, hb_destroy_func_t destroy);
# 400 "../../../libs/harfbuzz-ng/src/hb-unicode.h"
void
hb_unicode_funcs_set_decompose_compatibility_func (hb_unicode_funcs_t *ufuncs,
         hb_unicode_decompose_compatibility_func_t func,
         void *user_data, hb_destroy_func_t destroy);



hb_unicode_combining_class_t
hb_unicode_combining_class (hb_unicode_funcs_t *ufuncs,
       hb_codepoint_t unicode);

unsigned int
hb_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs,
       hb_codepoint_t unicode);

hb_unicode_general_category_t
hb_unicode_general_category (hb_unicode_funcs_t *ufuncs,
        hb_codepoint_t unicode);

hb_codepoint_t
hb_unicode_mirroring (hb_unicode_funcs_t *ufuncs,
        hb_codepoint_t unicode);

hb_script_t
hb_unicode_script (hb_unicode_funcs_t *ufuncs,
     hb_codepoint_t unicode);

hb_bool_t
hb_unicode_compose (hb_unicode_funcs_t *ufuncs,
      hb_codepoint_t a,
      hb_codepoint_t b,
      hb_codepoint_t *ab);
hb_bool_t
hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
        hb_codepoint_t ab,
        hb_codepoint_t *a,
        hb_codepoint_t *b);

unsigned int
hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,
        hb_codepoint_t u,
        hb_codepoint_t *decomposed);


# 39 "../../../libs/harfbuzz-ng/src/hb-buffer.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-font.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-font.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-font.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-face.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-face.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-face.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-blob.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-face.h" 2








typedef struct hb_face_t hb_face_t;

hb_face_t *
hb_face_create (hb_blob_t *blob,
  unsigned int index);

typedef hb_blob_t * (*hb_reference_table_func_t) (hb_face_t *face, hb_tag_t tag, void *user_data);


hb_face_t *
hb_face_create_for_tables (hb_reference_table_func_t reference_table_func,
      void *user_data,
      hb_destroy_func_t destroy);

hb_face_t *
hb_face_get_empty (void);

hb_face_t *
hb_face_reference (hb_face_t *face);

void
hb_face_destroy (hb_face_t *face);

hb_bool_t
hb_face_set_user_data (hb_face_t *face,
         hb_user_data_key_t *key,
         void * data,
         hb_destroy_func_t destroy,
         hb_bool_t replace);


void *
hb_face_get_user_data (hb_face_t *face,
         hb_user_data_key_t *key);

void
hb_face_make_immutable (hb_face_t *face);

hb_bool_t
hb_face_is_immutable (hb_face_t *face);


hb_blob_t *
hb_face_reference_table (hb_face_t *face,
    hb_tag_t tag);

hb_blob_t *
hb_face_reference_blob (hb_face_t *face);

void
hb_face_set_index (hb_face_t *face,
     unsigned int index);

unsigned int
hb_face_get_index (hb_face_t *face);

void
hb_face_set_upem (hb_face_t *face,
    unsigned int upem);

unsigned int
hb_face_get_upem (hb_face_t *face);

void
hb_face_set_glyph_count (hb_face_t *face,
    unsigned int glyph_count);

unsigned int
hb_face_get_glyph_count (hb_face_t *face);



# 36 "../../../libs/harfbuzz-ng/src/hb-font.h" 2




typedef struct hb_font_t hb_font_t;






typedef struct hb_font_funcs_t hb_font_funcs_t;

hb_font_funcs_t *
hb_font_funcs_create (void);

hb_font_funcs_t *
hb_font_funcs_get_empty (void);

hb_font_funcs_t *
hb_font_funcs_reference (hb_font_funcs_t *ffuncs);

void
hb_font_funcs_destroy (hb_font_funcs_t *ffuncs);

hb_bool_t
hb_font_funcs_set_user_data (hb_font_funcs_t *ffuncs,
        hb_user_data_key_t *key,
        void * data,
        hb_destroy_func_t destroy,
        hb_bool_t replace);


void *
hb_font_funcs_get_user_data (hb_font_funcs_t *ffuncs,
        hb_user_data_key_t *key);


void
hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs);

hb_bool_t
hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs);




typedef struct hb_glyph_extents_t
{
  hb_position_t x_bearing;
  hb_position_t y_bearing;
  hb_position_t width;
  hb_position_t height;
} hb_glyph_extents_t;




typedef hb_bool_t (*hb_font_get_glyph_func_t) (hb_font_t *font, void *font_data,
            hb_codepoint_t unicode, hb_codepoint_t variation_selector,
            hb_codepoint_t *glyph,
            void *user_data);


typedef hb_position_t (*hb_font_get_glyph_advance_func_t) (hb_font_t *font, void *font_data,
          hb_codepoint_t glyph,
          void *user_data);
typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_h_advance_func_t;
typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_v_advance_func_t;

typedef hb_bool_t (*hb_font_get_glyph_origin_func_t) (hb_font_t *font, void *font_data,
            hb_codepoint_t glyph,
            hb_position_t *x, hb_position_t *y,
            void *user_data);
typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_h_origin_func_t;
typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_v_origin_func_t;

typedef hb_position_t (*hb_font_get_glyph_kerning_func_t) (hb_font_t *font, void *font_data,
          hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
          void *user_data);
typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_h_kerning_func_t;
typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_v_kerning_func_t;


typedef hb_bool_t (*hb_font_get_glyph_extents_func_t) (hb_font_t *font, void *font_data,
             hb_codepoint_t glyph,
             hb_glyph_extents_t *extents,
             void *user_data);
typedef hb_bool_t (*hb_font_get_glyph_contour_point_func_t) (hb_font_t *font, void *font_data,
            hb_codepoint_t glyph, unsigned int point_index,
            hb_position_t *x, hb_position_t *y,
            void *user_data);


typedef hb_bool_t (*hb_font_get_glyph_name_func_t) (hb_font_t *font, void *font_data,
          hb_codepoint_t glyph,
          char *name, unsigned int size,
          void *user_data);
typedef hb_bool_t (*hb_font_get_glyph_from_name_func_t) (hb_font_t *font, void *font_data,
        const char *name, int len,
        hb_codepoint_t *glyph,
        void *user_data);
# 153 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_func (hb_font_funcs_t *ffuncs,
         hb_font_get_glyph_func_t func,
         void *user_data, hb_destroy_func_t destroy);
# 169 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_h_advance_func (hb_font_funcs_t *ffuncs,
     hb_font_get_glyph_h_advance_func_t func,
     void *user_data, hb_destroy_func_t destroy);
# 185 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_v_advance_func (hb_font_funcs_t *ffuncs,
     hb_font_get_glyph_v_advance_func_t func,
     void *user_data, hb_destroy_func_t destroy);
# 201 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_h_origin_func (hb_font_funcs_t *ffuncs,
           hb_font_get_glyph_h_origin_func_t func,
           void *user_data, hb_destroy_func_t destroy);
# 217 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_v_origin_func (hb_font_funcs_t *ffuncs,
           hb_font_get_glyph_v_origin_func_t func,
           void *user_data, hb_destroy_func_t destroy);
# 233 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_h_kerning_func (hb_font_funcs_t *ffuncs,
     hb_font_get_glyph_h_kerning_func_t func,
     void *user_data, hb_destroy_func_t destroy);
# 249 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_v_kerning_func (hb_font_funcs_t *ffuncs,
     hb_font_get_glyph_v_kerning_func_t func,
     void *user_data, hb_destroy_func_t destroy);
# 265 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_extents_func (hb_font_funcs_t *ffuncs,
          hb_font_get_glyph_extents_func_t func,
          void *user_data, hb_destroy_func_t destroy);
# 281 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_contour_point_func (hb_font_funcs_t *ffuncs,
         hb_font_get_glyph_contour_point_func_t func,
         void *user_data, hb_destroy_func_t destroy);
# 297 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_name_func (hb_font_funcs_t *ffuncs,
       hb_font_get_glyph_name_func_t func,
       void *user_data, hb_destroy_func_t destroy);
# 313 "../../../libs/harfbuzz-ng/src/hb-font.h"
void
hb_font_funcs_set_glyph_from_name_func (hb_font_funcs_t *ffuncs,
     hb_font_get_glyph_from_name_func_t func,
     void *user_data, hb_destroy_func_t destroy);




hb_bool_t
hb_font_get_glyph (hb_font_t *font,
     hb_codepoint_t unicode, hb_codepoint_t variation_selector,
     hb_codepoint_t *glyph);

hb_position_t
hb_font_get_glyph_h_advance (hb_font_t *font,
        hb_codepoint_t glyph);
hb_position_t
hb_font_get_glyph_v_advance (hb_font_t *font,
        hb_codepoint_t glyph);

hb_bool_t
hb_font_get_glyph_h_origin (hb_font_t *font,
       hb_codepoint_t glyph,
       hb_position_t *x, hb_position_t *y);
hb_bool_t
hb_font_get_glyph_v_origin (hb_font_t *font,
       hb_codepoint_t glyph,
       hb_position_t *x, hb_position_t *y);

hb_position_t
hb_font_get_glyph_h_kerning (hb_font_t *font,
        hb_codepoint_t left_glyph, hb_codepoint_t right_glyph);
hb_position_t
hb_font_get_glyph_v_kerning (hb_font_t *font,
        hb_codepoint_t top_glyph, hb_codepoint_t bottom_glyph);

hb_bool_t
hb_font_get_glyph_extents (hb_font_t *font,
      hb_codepoint_t glyph,
      hb_glyph_extents_t *extents);

hb_bool_t
hb_font_get_glyph_contour_point (hb_font_t *font,
     hb_codepoint_t glyph, unsigned int point_index,
     hb_position_t *x, hb_position_t *y);

hb_bool_t
hb_font_get_glyph_name (hb_font_t *font,
   hb_codepoint_t glyph,
   char *name, unsigned int size);
hb_bool_t
hb_font_get_glyph_from_name (hb_font_t *font,
        const char *name, int len,
        hb_codepoint_t *glyph);




void
hb_font_get_glyph_advance_for_direction (hb_font_t *font,
      hb_codepoint_t glyph,
      hb_direction_t direction,
      hb_position_t *x, hb_position_t *y);
void
hb_font_get_glyph_origin_for_direction (hb_font_t *font,
     hb_codepoint_t glyph,
     hb_direction_t direction,
     hb_position_t *x, hb_position_t *y);
void
hb_font_add_glyph_origin_for_direction (hb_font_t *font,
     hb_codepoint_t glyph,
     hb_direction_t direction,
     hb_position_t *x, hb_position_t *y);
void
hb_font_subtract_glyph_origin_for_direction (hb_font_t *font,
          hb_codepoint_t glyph,
          hb_direction_t direction,
          hb_position_t *x, hb_position_t *y);

void
hb_font_get_glyph_kerning_for_direction (hb_font_t *font,
      hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,
      hb_direction_t direction,
      hb_position_t *x, hb_position_t *y);

hb_bool_t
hb_font_get_glyph_extents_for_origin (hb_font_t *font,
          hb_codepoint_t glyph,
          hb_direction_t direction,
          hb_glyph_extents_t *extents);

hb_bool_t
hb_font_get_glyph_contour_point_for_origin (hb_font_t *font,
         hb_codepoint_t glyph, unsigned int point_index,
         hb_direction_t direction,
         hb_position_t *x, hb_position_t *y);


void
hb_font_glyph_to_string (hb_font_t *font,
    hb_codepoint_t glyph,
    char *s, unsigned int size);

hb_bool_t
hb_font_glyph_from_string (hb_font_t *font,
      const char *s, int len,
      hb_codepoint_t *glyph);
# 428 "../../../libs/harfbuzz-ng/src/hb-font.h"
hb_font_t *
hb_font_create (hb_face_t *face);

hb_font_t *
hb_font_create_sub_font (hb_font_t *parent);

hb_font_t *
hb_font_get_empty (void);

hb_font_t *
hb_font_reference (hb_font_t *font);

void
hb_font_destroy (hb_font_t *font);

hb_bool_t
hb_font_set_user_data (hb_font_t *font,
         hb_user_data_key_t *key,
         void * data,
         hb_destroy_func_t destroy,
         hb_bool_t replace);


void *
hb_font_get_user_data (hb_font_t *font,
         hb_user_data_key_t *key);

void
hb_font_make_immutable (hb_font_t *font);

hb_bool_t
hb_font_is_immutable (hb_font_t *font);

hb_font_t *
hb_font_get_parent (hb_font_t *font);

hb_face_t *
hb_font_get_face (hb_font_t *font);


void
hb_font_set_funcs (hb_font_t *font,
     hb_font_funcs_t *klass,
     void *font_data,
     hb_destroy_func_t destroy);


void
hb_font_set_funcs_data (hb_font_t *font,
          void *font_data,
          hb_destroy_func_t destroy);


void
hb_font_set_scale (hb_font_t *font,
     int x_scale,
     int y_scale);

void
hb_font_get_scale (hb_font_t *font,
     int *x_scale,
     int *y_scale);




void
hb_font_set_ppem (hb_font_t *font,
    unsigned int x_ppem,
    unsigned int y_ppem);

void
hb_font_get_ppem (hb_font_t *font,
    unsigned int *x_ppem,
    unsigned int *y_ppem);



# 40 "../../../libs/harfbuzz-ng/src/hb-buffer.h" 2




typedef struct hb_glyph_info_t {
  hb_codepoint_t codepoint;
  hb_mask_t mask;
  uint32_t cluster;


  hb_var_int_t var1;
  hb_var_int_t var2;
} hb_glyph_info_t;

typedef struct hb_glyph_position_t {
  hb_position_t x_advance;
  hb_position_t y_advance;
  hb_position_t x_offset;
  hb_position_t y_offset;


  hb_var_int_t var;
} hb_glyph_position_t;


typedef struct hb_segment_properties_t {
  hb_direction_t direction;
  hb_script_t script;
  hb_language_t language;

  void *reserved1;
  void *reserved2;
} hb_segment_properties_t;







hb_bool_t
hb_segment_properties_equal (const hb_segment_properties_t *a,
        const hb_segment_properties_t *b);

unsigned int
hb_segment_properties_hash (const hb_segment_properties_t *p);







typedef struct hb_buffer_t hb_buffer_t;

hb_buffer_t *
hb_buffer_create (void);

hb_buffer_t *
hb_buffer_get_empty (void);

hb_buffer_t *
hb_buffer_reference (hb_buffer_t *buffer);

void
hb_buffer_destroy (hb_buffer_t *buffer);

hb_bool_t
hb_buffer_set_user_data (hb_buffer_t *buffer,
    hb_user_data_key_t *key,
    void * data,
    hb_destroy_func_t destroy,
    hb_bool_t replace);

void *
hb_buffer_get_user_data (hb_buffer_t *buffer,
    hb_user_data_key_t *key);


typedef enum {
  HB_BUFFER_CONTENT_TYPE_INVALID = 0,
  HB_BUFFER_CONTENT_TYPE_UNICODE,
  HB_BUFFER_CONTENT_TYPE_GLYPHS
} hb_buffer_content_type_t;

void
hb_buffer_set_content_type (hb_buffer_t *buffer,
       hb_buffer_content_type_t content_type);

hb_buffer_content_type_t
hb_buffer_get_content_type (hb_buffer_t *buffer);


void
hb_buffer_set_unicode_funcs (hb_buffer_t *buffer,
        hb_unicode_funcs_t *unicode_funcs);

hb_unicode_funcs_t *
hb_buffer_get_unicode_funcs (hb_buffer_t *buffer);

void
hb_buffer_set_direction (hb_buffer_t *buffer,
    hb_direction_t direction);

hb_direction_t
hb_buffer_get_direction (hb_buffer_t *buffer);

void
hb_buffer_set_script (hb_buffer_t *buffer,
        hb_script_t script);

hb_script_t
hb_buffer_get_script (hb_buffer_t *buffer);

void
hb_buffer_set_language (hb_buffer_t *buffer,
   hb_language_t language);


hb_language_t
hb_buffer_get_language (hb_buffer_t *buffer);

void
hb_buffer_set_segment_properties (hb_buffer_t *buffer,
      const hb_segment_properties_t *props);

void
hb_buffer_get_segment_properties (hb_buffer_t *buffer,
      hb_segment_properties_t *props);

void
hb_buffer_guess_segment_properties (hb_buffer_t *buffer);


typedef enum {
  HB_BUFFER_FLAG_DEFAULT = 0x00000000u,
  HB_BUFFER_FLAG_BOT = 0x00000001u,
  HB_BUFFER_FLAG_EOT = 0x00000002u,
  HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES = 0x00000004u
} hb_buffer_flags_t;

void
hb_buffer_set_flags (hb_buffer_t *buffer,
       hb_buffer_flags_t flags);

hb_buffer_flags_t
hb_buffer_get_flags (hb_buffer_t *buffer);







void
hb_buffer_set_replacement_codepoint (hb_buffer_t *buffer,
         hb_codepoint_t replacement);

hb_codepoint_t
hb_buffer_get_replacement_codepoint (hb_buffer_t *buffer);




void
hb_buffer_reset (hb_buffer_t *buffer);


void
hb_buffer_clear_contents (hb_buffer_t *buffer);


hb_bool_t
hb_buffer_pre_allocate (hb_buffer_t *buffer,
          unsigned int size);



hb_bool_t
hb_buffer_allocation_successful (hb_buffer_t *buffer);

void
hb_buffer_reverse (hb_buffer_t *buffer);

void
hb_buffer_reverse_clusters (hb_buffer_t *buffer);




void
hb_buffer_add (hb_buffer_t *buffer,
        hb_codepoint_t codepoint,
        unsigned int cluster);

void
hb_buffer_add_utf8 (hb_buffer_t *buffer,
      const char *text,
      int text_length,
      unsigned int item_offset,
      int item_length);

void
hb_buffer_add_utf16 (hb_buffer_t *buffer,
       const uint16_t *text,
       int text_length,
       unsigned int item_offset,
       int item_length);

void
hb_buffer_add_utf32 (hb_buffer_t *buffer,
       const uint32_t *text,
       int text_length,
       unsigned int item_offset,
       int item_length);


void
hb_buffer_add_codepoints (hb_buffer_t *buffer,
     const hb_codepoint_t *text,
     int text_length,
     unsigned int item_offset,
     int item_length);



hb_bool_t
hb_buffer_set_length (hb_buffer_t *buffer,
        unsigned int length);


unsigned int
hb_buffer_get_length (hb_buffer_t *buffer);




hb_glyph_info_t *
hb_buffer_get_glyph_infos (hb_buffer_t *buffer,
                           unsigned int *length);


hb_glyph_position_t *
hb_buffer_get_glyph_positions (hb_buffer_t *buffer,
                               unsigned int *length);





void
hb_buffer_normalize_glyphs (hb_buffer_t *buffer);






typedef enum {
  HB_BUFFER_SERIALIZE_FLAG_DEFAULT = 0x00000000u,
  HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS = 0x00000001u,
  HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS = 0x00000002u,
  HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES = 0x00000004u
} hb_buffer_serialize_flags_t;

typedef enum {
  HB_BUFFER_SERIALIZE_FORMAT_TEXT = ((hb_tag_t)((((uint8_t)('T'))<<24)|(((uint8_t)('E'))<<16)|(((uint8_t)('X'))<<8)|((uint8_t)('T')))),
  HB_BUFFER_SERIALIZE_FORMAT_JSON = ((hb_tag_t)((((uint8_t)('J'))<<24)|(((uint8_t)('S'))<<16)|(((uint8_t)('O'))<<8)|((uint8_t)('N')))),
  HB_BUFFER_SERIALIZE_FORMAT_INVALID = ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0))))
} hb_buffer_serialize_format_t;


hb_buffer_serialize_format_t
hb_buffer_serialize_format_from_string (const char *str, int len);

const char *
hb_buffer_serialize_format_to_string (hb_buffer_serialize_format_t format);

const char **
hb_buffer_serialize_list_formats (void);


unsigned int
hb_buffer_serialize_glyphs (hb_buffer_t *buffer,
       unsigned int start,
       unsigned int end,
       char *buf,
       unsigned int buf_size,
       unsigned int *buf_consumed,
       hb_font_t *font,
       hb_buffer_serialize_format_t format,
       hb_buffer_serialize_flags_t flags);

hb_bool_t
hb_buffer_deserialize_glyphs (hb_buffer_t *buffer,
         const char *buf,
         int buf_len,
         const char **end_ptr,
         hb_font_t *font,
         hb_buffer_serialize_format_t format);



# 33 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-deprecated.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-deprecated.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-deprecated.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-unicode.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-deprecated.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-font.h" 1
# 37 "../../../libs/harfbuzz-ng/src/hb-deprecated.h" 2


# 49 "../../../libs/harfbuzz-ng/src/hb-deprecated.h"

# 35 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-face.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-font.h" 1
# 37 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-set.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-set.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-set.h" 2






typedef struct hb_set_t hb_set_t;


hb_set_t *
hb_set_create (void);

hb_set_t *
hb_set_get_empty (void);

hb_set_t *
hb_set_reference (hb_set_t *set);

void
hb_set_destroy (hb_set_t *set);

hb_bool_t
hb_set_set_user_data (hb_set_t *set,
        hb_user_data_key_t *key,
        void * data,
        hb_destroy_func_t destroy,
        hb_bool_t replace);

void *
hb_set_get_user_data (hb_set_t *set,
        hb_user_data_key_t *key);



hb_bool_t
hb_set_allocation_successful (const hb_set_t *set);

void
hb_set_clear (hb_set_t *set);

hb_bool_t
hb_set_is_empty (const hb_set_t *set);

hb_bool_t
hb_set_has (const hb_set_t *set,
     hb_codepoint_t codepoint);



void
hb_set_add (hb_set_t *set,
     hb_codepoint_t codepoint);

void
hb_set_add_range (hb_set_t *set,
    hb_codepoint_t first,
    hb_codepoint_t last);

void
hb_set_del (hb_set_t *set,
     hb_codepoint_t codepoint);

void
hb_set_del_range (hb_set_t *set,
    hb_codepoint_t first,
    hb_codepoint_t last);

hb_bool_t
hb_set_is_equal (const hb_set_t *set,
   const hb_set_t *other);

void
hb_set_set (hb_set_t *set,
     const hb_set_t *other);

void
hb_set_union (hb_set_t *set,
       const hb_set_t *other);

void
hb_set_intersect (hb_set_t *set,
    const hb_set_t *other);

void
hb_set_subtract (hb_set_t *set,
   const hb_set_t *other);

void
hb_set_symmetric_difference (hb_set_t *set,
        const hb_set_t *other);

void
hb_set_invert (hb_set_t *set);

unsigned int
hb_set_get_population (const hb_set_t *set);


hb_codepoint_t
hb_set_get_min (const hb_set_t *set);


hb_codepoint_t
hb_set_get_max (const hb_set_t *set);


hb_bool_t
hb_set_next (const hb_set_t *set,
      hb_codepoint_t *codepoint);


hb_bool_t
hb_set_next_range (const hb_set_t *set,
     hb_codepoint_t *first,
     hb_codepoint_t *last);



# 38 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-shape.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-shape.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 37 "../../../libs/harfbuzz-ng/src/hb-shape.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-buffer.h" 1
# 38 "../../../libs/harfbuzz-ng/src/hb-shape.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-font.h" 1
# 39 "../../../libs/harfbuzz-ng/src/hb-shape.h" 2




typedef struct hb_feature_t {
  hb_tag_t tag;
  uint32_t value;
  unsigned int start;
  unsigned int end;
} hb_feature_t;


hb_bool_t
hb_feature_from_string (const char *str, int len,
   hb_feature_t *feature);



void
hb_feature_to_string (hb_feature_t *feature,
        char *buf, unsigned int size);


void
hb_shape (hb_font_t *font,
   hb_buffer_t *buffer,
   const hb_feature_t *features,
   unsigned int num_features);

hb_bool_t
hb_shape_full (hb_font_t *font,
        hb_buffer_t *buffer,
        const hb_feature_t *features,
        unsigned int num_features,
        const char * const *shaper_list);

const char **
hb_shape_list_shapers (void);



# 39 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-shape-plan.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-shape-plan.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-shape-plan.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-font.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-shape-plan.h" 2



typedef struct hb_shape_plan_t hb_shape_plan_t;

hb_shape_plan_t *
hb_shape_plan_create (hb_face_t *face,
        const hb_segment_properties_t *props,
        const hb_feature_t *user_features,
        unsigned int num_user_features,
        const char * const *shaper_list);

hb_shape_plan_t *
hb_shape_plan_create_cached (hb_face_t *face,
        const hb_segment_properties_t *props,
        const hb_feature_t *user_features,
        unsigned int num_user_features,
        const char * const *shaper_list);

hb_shape_plan_t *
hb_shape_plan_get_empty (void);

hb_shape_plan_t *
hb_shape_plan_reference (hb_shape_plan_t *shape_plan);

void
hb_shape_plan_destroy (hb_shape_plan_t *shape_plan);

hb_bool_t
hb_shape_plan_set_user_data (hb_shape_plan_t *shape_plan,
        hb_user_data_key_t *key,
        void * data,
        hb_destroy_func_t destroy,
        hb_bool_t replace);

void *
hb_shape_plan_get_user_data (hb_shape_plan_t *shape_plan,
        hb_user_data_key_t *key);


hb_bool_t
hb_shape_plan_execute (hb_shape_plan_t *shape_plan,
         hb_font_t *font,
         hb_buffer_t *buffer,
         const hb_feature_t *features,
         unsigned int num_features);

const char *
hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan);



# 40 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-unicode.h" 1
# 41 "../../../libs/harfbuzz-ng/src/hb.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-version.h" 1
# 34 "../../../libs/harfbuzz-ng/src/hb-version.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-common.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-version.h" 2


# 50 "../../../libs/harfbuzz-ng/src/hb-version.h"
void
hb_version (unsigned int *major,
     unsigned int *minor,
     unsigned int *micro);

const char *
hb_version_string (void);

hb_bool_t
hb_version_atleast (unsigned int major,
      unsigned int minor,
      unsigned int micro);



# 42 "../../../libs/harfbuzz-ng/src/hb.h" 2



# 30 "../../../libs/freetype/src/autofit/hbshim.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-ot.h" 1
# 31 "../../../libs/harfbuzz-ng/src/hb-ot.h"
# 1 "../../../libs/harfbuzz-ng/src/hb.h" 1
# 32 "../../../libs/harfbuzz-ng/src/hb-ot.h" 2

# 1 "../../../libs/harfbuzz-ng/src/hb-ot-font.h" 1
# 32 "../../../libs/harfbuzz-ng/src/hb-ot-font.h"



void
hb_ot_font_set_funcs (hb_font_t *font);



# 34 "../../../libs/harfbuzz-ng/src/hb-ot.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h"
# 1 "../../../libs/harfbuzz-ng/src/hb-ot-tag.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-ot-tag.h"






void
hb_ot_tags_from_script (hb_script_t script,
   hb_tag_t *script_tag_1,
   hb_tag_t *script_tag_2);

hb_script_t
hb_ot_tag_to_script (hb_tag_t tag);

hb_tag_t
hb_ot_tag_from_language (hb_language_t language);

hb_language_t
hb_ot_tag_to_language (hb_tag_t tag);



# 37 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h" 2


# 51 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h"
hb_bool_t
hb_ot_layout_has_glyph_classes (hb_face_t *face);

typedef enum {
  HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED = 0,
  HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH = 1,
  HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE = 2,
  HB_OT_LAYOUT_GLYPH_CLASS_MARK = 3,
  HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT = 4
} hb_ot_layout_glyph_class_t;

hb_ot_layout_glyph_class_t
hb_ot_layout_get_glyph_class (hb_face_t *face,
         hb_codepoint_t glyph);

void
hb_ot_layout_get_glyphs_in_class (hb_face_t *face,
      hb_ot_layout_glyph_class_t klass,
      hb_set_t *glyphs );




unsigned int
hb_ot_layout_get_attach_points (hb_face_t *face,
    hb_codepoint_t glyph,
    unsigned int start_offset,
    unsigned int *point_count ,
    unsigned int *point_array );


unsigned int
hb_ot_layout_get_ligature_carets (hb_font_t *font,
      hb_direction_t direction,
      hb_codepoint_t glyph,
      unsigned int start_offset,
      unsigned int *caret_count ,
      hb_position_t *caret_array );
# 99 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h"
unsigned int
hb_ot_layout_table_get_script_tags (hb_face_t *face,
        hb_tag_t table_tag,
        unsigned int start_offset,
        unsigned int *script_count ,
        hb_tag_t *script_tags );

hb_bool_t
hb_ot_layout_table_find_script (hb_face_t *face,
    hb_tag_t table_tag,
    hb_tag_t script_tag,
    unsigned int *script_index);


hb_bool_t
hb_ot_layout_table_choose_script (hb_face_t *face,
      hb_tag_t table_tag,
      const hb_tag_t *script_tags,
      unsigned int *script_index,
      hb_tag_t *chosen_script);

unsigned int
hb_ot_layout_table_get_feature_tags (hb_face_t *face,
         hb_tag_t table_tag,
         unsigned int start_offset,
         unsigned int *feature_count ,
         hb_tag_t *feature_tags );

unsigned int
hb_ot_layout_script_get_language_tags (hb_face_t *face,
           hb_tag_t table_tag,
           unsigned int script_index,
           unsigned int start_offset,
           unsigned int *language_count ,
           hb_tag_t *language_tags );

hb_bool_t
hb_ot_layout_script_find_language (hb_face_t *face,
       hb_tag_t table_tag,
       unsigned int script_index,
       hb_tag_t language_tag,
       unsigned int *language_index);

hb_bool_t
hb_ot_layout_language_get_required_feature_index (hb_face_t *face,
        hb_tag_t table_tag,
        unsigned int script_index,
        unsigned int language_index,
        unsigned int *feature_index);

hb_bool_t
hb_ot_layout_language_get_required_feature (hb_face_t *face,
         hb_tag_t table_tag,
         unsigned int script_index,
         unsigned int language_index,
         unsigned int *feature_index,
         hb_tag_t *feature_tag);

unsigned int
hb_ot_layout_language_get_feature_indexes (hb_face_t *face,
        hb_tag_t table_tag,
        unsigned int script_index,
        unsigned int language_index,
        unsigned int start_offset,
        unsigned int *feature_count ,
        unsigned int *feature_indexes );

unsigned int
hb_ot_layout_language_get_feature_tags (hb_face_t *face,
     hb_tag_t table_tag,
     unsigned int script_index,
     unsigned int language_index,
     unsigned int start_offset,
     unsigned int *feature_count ,
     hb_tag_t *feature_tags );

hb_bool_t
hb_ot_layout_language_find_feature (hb_face_t *face,
        hb_tag_t table_tag,
        unsigned int script_index,
        unsigned int language_index,
        hb_tag_t feature_tag,
        unsigned int *feature_index);

unsigned int
hb_ot_layout_feature_get_lookups (hb_face_t *face,
      hb_tag_t table_tag,
      unsigned int feature_index,
      unsigned int start_offset,
      unsigned int *lookup_count ,
      unsigned int *lookup_indexes );

unsigned int
hb_ot_layout_table_get_lookup_count (hb_face_t *face,
         hb_tag_t table_tag);


void
hb_ot_layout_collect_lookups (hb_face_t *face,
         hb_tag_t table_tag,
         const hb_tag_t *scripts,
         const hb_tag_t *languages,
         const hb_tag_t *features,
         hb_set_t *lookup_indexes );

void
hb_ot_layout_lookup_collect_glyphs (hb_face_t *face,
        hb_tag_t table_tag,
        unsigned int lookup_index,
        hb_set_t *glyphs_before,
        hb_set_t *glyphs_input,
        hb_set_t *glyphs_after,
        hb_set_t *glyphs_output );
# 244 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h"
hb_bool_t
hb_ot_layout_has_substitution (hb_face_t *face);

hb_bool_t
hb_ot_layout_lookup_would_substitute (hb_face_t *face,
          unsigned int lookup_index,
          const hb_codepoint_t *glyphs,
          unsigned int glyphs_length,
          hb_bool_t zero_context);

void
hb_ot_layout_lookup_substitute_closure (hb_face_t *face,
            unsigned int lookup_index,
            hb_set_t *glyphs
                                     );
# 277 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h"
hb_bool_t
hb_ot_layout_has_positioning (hb_face_t *face);
# 291 "../../../libs/harfbuzz-ng/src/hb-ot-layout.h"
hb_bool_t
hb_ot_layout_get_size_params (hb_face_t *face,
         unsigned int *design_size,
         unsigned int *subfamily_id,
         unsigned int *subfamily_name_id,
         unsigned int *range_start,
         unsigned int *range_end );



# 35 "../../../libs/harfbuzz-ng/src/hb-ot.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-ot-tag.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-ot.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-ot-shape.h" 1
# 36 "../../../libs/harfbuzz-ng/src/hb-ot-shape.h"



void
hb_ot_shape_glyphs_closure (hb_font_t *font,
       hb_buffer_t *buffer,
       const hb_feature_t *features,
       unsigned int num_features,
       hb_set_t *glyphs);

void
hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
      hb_tag_t table_tag,
      hb_set_t *lookup_indexes );


# 37 "../../../libs/harfbuzz-ng/src/hb-ot.h" 2




# 31 "../../../libs/freetype/src/autofit/hbshim.h" 2
# 1 "../../../libs/harfbuzz-ng/src/hb-ft.h" 1
# 35 "../../../libs/harfbuzz-ng/src/hb-ft.h"

# 60 "../../../libs/harfbuzz-ng/src/hb-ft.h"
hb_face_t *
hb_ft_face_create (FT_Face ft_face,
     hb_destroy_func_t destroy);
# 72 "../../../libs/harfbuzz-ng/src/hb-ft.h"
hb_face_t *
hb_ft_face_create_cached (FT_Face ft_face);
# 82 "../../../libs/harfbuzz-ng/src/hb-ft.h"
hb_face_t *
hb_ft_face_create_referenced (FT_Face ft_face);
# 99 "../../../libs/harfbuzz-ng/src/hb-ft.h"
hb_font_t *
hb_ft_font_create (FT_Face ft_face,
     hb_destroy_func_t destroy);



hb_font_t *
hb_ft_font_create_referenced (FT_Face ft_face);



void
hb_ft_font_set_funcs (hb_font_t *font);

FT_Face
hb_ft_font_get_face (hb_font_t *font);



# 32 "../../../libs/freetype/src/autofit/hbshim.h" 2






  FT_Error
  af_get_coverage( AF_FaceGlobals globals,
                   AF_StyleClass style_class,
                   FT_UShort* gstyles );

  FT_Error
  af_get_char_index( AF_StyleMetrics metrics,
                     FT_ULong charcode,
                     FT_ULong *codepoint,
                     FT_Long *y_offset );




# 27 "../../../libs/freetype/src/autofit/afglobal.h" 2





  extern const AF_WritingSystemClass
  af_writing_system_classes[];






# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  extern const AF_ScriptClassRec af_arab_script_class;




  extern const AF_ScriptClassRec af_cyrl_script_class;




  extern const AF_ScriptClassRec af_deva_script_class;




  extern const AF_ScriptClassRec af_grek_script_class;




  extern const AF_ScriptClassRec af_hebr_script_class;





  extern const AF_ScriptClassRec af_lao_script_class;




  extern const AF_ScriptClassRec af_latn_script_class;




  extern const AF_ScriptClassRec af_latb_script_class;




  extern const AF_ScriptClassRec af_latp_script_class;




  extern const AF_ScriptClassRec af_none_script_class;





  extern const AF_ScriptClassRec af_telu_script_class;




  extern const AF_ScriptClassRec af_thai_script_class;






  extern const AF_ScriptClassRec af_beng_script_class;




  extern const AF_ScriptClassRec af_gujr_script_class;




  extern const AF_ScriptClassRec af_guru_script_class;




  extern const AF_ScriptClassRec af_knda_script_class;




  extern const AF_ScriptClassRec af_limb_script_class;




  extern const AF_ScriptClassRec af_mlym_script_class;




  extern const AF_ScriptClassRec af_orya_script_class;




  extern const AF_ScriptClassRec af_sinh_script_class;




  extern const AF_ScriptClassRec af_sund_script_class;




  extern const AF_ScriptClassRec af_sylo_script_class;




  extern const AF_ScriptClassRec af_taml_script_class;




  extern const AF_ScriptClassRec af_tibt_script_class;
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  extern const AF_ScriptClassRec af_hani_script_class;
# 41 "../../../libs/freetype/src/autofit/afglobal.h" 2

  extern const AF_ScriptClass
  af_script_classes[];






# 1 "../../../libs/freetype/src/autofit/afstyles.h" 1
# 86 "../../../libs/freetype/src/autofit/afstyles.h"
  extern const AF_StyleClassRec af_arab_dflt_style_class;






  extern const AF_StyleClassRec af_cyrl_c2cp_style_class; extern const AF_StyleClassRec af_cyrl_c2sc_style_class; extern const AF_StyleClassRec af_cyrl_ordn_style_class; extern const AF_StyleClassRec af_cyrl_pcap_style_class; extern const AF_StyleClassRec af_cyrl_sinf_style_class; extern const AF_StyleClassRec af_cyrl_smcp_style_class; extern const AF_StyleClassRec af_cyrl_subs_style_class; extern const AF_StyleClassRec af_cyrl_sups_style_class; extern const AF_StyleClassRec af_cyrl_titl_style_class; extern const AF_StyleClassRec af_cyrl_dflt_style_class;

  extern const AF_StyleClassRec af_deva_dflt_style_class;






  extern const AF_StyleClassRec af_grek_c2cp_style_class; extern const AF_StyleClassRec af_grek_c2sc_style_class; extern const AF_StyleClassRec af_grek_ordn_style_class; extern const AF_StyleClassRec af_grek_pcap_style_class; extern const AF_StyleClassRec af_grek_sinf_style_class; extern const AF_StyleClassRec af_grek_smcp_style_class; extern const AF_StyleClassRec af_grek_subs_style_class; extern const AF_StyleClassRec af_grek_sups_style_class; extern const AF_StyleClassRec af_grek_titl_style_class; extern const AF_StyleClassRec af_grek_dflt_style_class;

  extern const AF_StyleClassRec af_hebr_dflt_style_class;






  extern const AF_StyleClassRec af_lao_dflt_style_class;






  extern const AF_StyleClassRec af_latn_c2cp_style_class; extern const AF_StyleClassRec af_latn_c2sc_style_class; extern const AF_StyleClassRec af_latn_ordn_style_class; extern const AF_StyleClassRec af_latn_pcap_style_class; extern const AF_StyleClassRec af_latn_sinf_style_class; extern const AF_StyleClassRec af_latn_smcp_style_class; extern const AF_StyleClassRec af_latn_subs_style_class; extern const AF_StyleClassRec af_latn_sups_style_class; extern const AF_StyleClassRec af_latn_titl_style_class; extern const AF_StyleClassRec af_latn_dflt_style_class;

  extern const AF_StyleClassRec af_latb_dflt_style_class;






  extern const AF_StyleClassRec af_latp_dflt_style_class;
# 143 "../../../libs/freetype/src/autofit/afstyles.h"
  extern const AF_StyleClassRec af_none_dflt_style_class;






  extern const AF_StyleClassRec af_telu_dflt_style_class;






  extern const AF_StyleClassRec af_thai_dflt_style_class;
# 176 "../../../libs/freetype/src/autofit/afstyles.h"
  extern const AF_StyleClassRec af_beng_dflt_style_class;
  extern const AF_StyleClassRec af_gujr_dflt_style_class;
  extern const AF_StyleClassRec af_guru_dflt_style_class;
  extern const AF_StyleClassRec af_knda_dflt_style_class;
  extern const AF_StyleClassRec af_limb_dflt_style_class;
  extern const AF_StyleClassRec af_mlym_dflt_style_class;
  extern const AF_StyleClassRec af_orya_dflt_style_class;
  extern const AF_StyleClassRec af_sinh_dflt_style_class;
  extern const AF_StyleClassRec af_sund_dflt_style_class;
  extern const AF_StyleClassRec af_sylo_dflt_style_class;
  extern const AF_StyleClassRec af_taml_dflt_style_class;
  extern const AF_StyleClassRec af_tibt_dflt_style_class;





  extern const AF_StyleClassRec af_hani_dflt_style_class;
# 51 "../../../libs/freetype/src/autofit/afglobal.h" 2

  extern const AF_StyleClass
  af_style_classes[];
# 105 "../../../libs/freetype/src/autofit/afglobal.h"
  typedef struct AF_FaceGlobalsRec_
  {
    FT_Face face;
    FT_Long glyph_count;
    FT_UShort* glyph_styles;


    hb_font_t* hb_font;



    FT_UInt increase_x_height;

    AF_StyleMetrics metrics[AF_STYLE_MAX];



    FT_UShort stem_darkening_for_ppem;


    FT_Pos standard_vertical_width;


    FT_Pos standard_horizontal_width;

    FT_Pos darken_x;

    FT_Pos darken_y;


    FT_Fixed scale_down_factor;
    AF_Module module;

  } AF_FaceGlobalsRec;







  static FT_Error
  af_face_globals_new( FT_Face face,
                       AF_FaceGlobals *aglobals,
                       AF_Module module );

  static FT_Error
  af_face_globals_get_metrics( AF_FaceGlobals globals,
                               FT_UInt gindex,
                               FT_UInt options,
                               AF_StyleMetrics *ametrics );

  static void
  af_face_globals_free( AF_FaceGlobals globals );

  static FT_Bool
  af_face_globals_is_digit( AF_FaceGlobals globals,
                            FT_UInt gindex );





# 24 "../../../libs/freetype/src/autofit/afpic.c" 2
# 1 "../../../libs/freetype/src/autofit/aferrors.h" 1
# 37 "../../../libs/freetype/src/autofit/aferrors.h"
# 1 "../../../libs/freetype/include/freetype/fterrors.h" 1
# 173 "../../../libs/freetype/include/freetype/fterrors.h"
  enum {




# 1 "../../../libs/freetype/include/freetype/fterrdef.h" 1
# 59 "../../../libs/freetype/include/freetype/fterrdef.h"
  AF_Err_Ok = 0x00,


  AF_Err_Cannot_Open_Resource = 0x01 + 0,

  AF_Err_Unknown_File_Format = 0x02 + 0,

  AF_Err_Invalid_File_Format = 0x03 + 0,

  AF_Err_Invalid_Version = 0x04 + 0,

  AF_Err_Lower_Module_Version = 0x05 + 0,

  AF_Err_Invalid_Argument = 0x06 + 0,

  AF_Err_Unimplemented_Feature = 0x07 + 0,

  AF_Err_Invalid_Table = 0x08 + 0,

  AF_Err_Invalid_Offset = 0x09 + 0,

  AF_Err_Array_Too_Large = 0x0A + 0,

  AF_Err_Missing_Module = 0x0B + 0,

  AF_Err_Missing_Property = 0x0C + 0,




  AF_Err_Invalid_Glyph_Index = 0x10 + 0,

  AF_Err_Invalid_Character_Code = 0x11 + 0,

  AF_Err_Invalid_Glyph_Format = 0x12 + 0,

  AF_Err_Cannot_Render_Glyph = 0x13 + 0,

  AF_Err_Invalid_Outline = 0x14 + 0,

  AF_Err_Invalid_Composite = 0x15 + 0,

  AF_Err_Too_Many_Hints = 0x16 + 0,

  AF_Err_Invalid_Pixel_Size = 0x17 + 0,




  AF_Err_Invalid_Handle = 0x20 + 0,

  AF_Err_Invalid_Library_Handle = 0x21 + 0,

  AF_Err_Invalid_Driver_Handle = 0x22 + 0,

  AF_Err_Invalid_Face_Handle = 0x23 + 0,

  AF_Err_Invalid_Size_Handle = 0x24 + 0,

  AF_Err_Invalid_Slot_Handle = 0x25 + 0,

  AF_Err_Invalid_CharMap_Handle = 0x26 + 0,

  AF_Err_Invalid_Cache_Handle = 0x27 + 0,

  AF_Err_Invalid_Stream_Handle = 0x28 + 0,




  AF_Err_Too_Many_Drivers = 0x30 + 0,

  AF_Err_Too_Many_Extensions = 0x31 + 0,




  AF_Err_Out_Of_Memory = 0x40 + 0,

  AF_Err_Unlisted_Object = 0x41 + 0,




  AF_Err_Cannot_Open_Stream = 0x51 + 0,

  AF_Err_Invalid_Stream_Seek = 0x52 + 0,

  AF_Err_Invalid_Stream_Skip = 0x53 + 0,

  AF_Err_Invalid_Stream_Read = 0x54 + 0,

  AF_Err_Invalid_Stream_Operation = 0x55 + 0,

  AF_Err_Invalid_Frame_Operation = 0x56 + 0,

  AF_Err_Nested_Frame_Access = 0x57 + 0,

  AF_Err_Invalid_Frame_Read = 0x58 + 0,




  AF_Err_Raster_Uninitialized = 0x60 + 0,

  AF_Err_Raster_Corrupted = 0x61 + 0,

  AF_Err_Raster_Overflow = 0x62 + 0,

  AF_Err_Raster_Negative_Height = 0x63 + 0,




  AF_Err_Too_Many_Caches = 0x70 + 0,




  AF_Err_Invalid_Opcode = 0x80 + 0,

  AF_Err_Too_Few_Arguments = 0x81 + 0,

  AF_Err_Stack_Overflow = 0x82 + 0,

  AF_Err_Code_Overflow = 0x83 + 0,

  AF_Err_Bad_Argument = 0x84 + 0,

  AF_Err_Divide_By_Zero = 0x85 + 0,

  AF_Err_Invalid_Reference = 0x86 + 0,

  AF_Err_Debug_OpCode = 0x87 + 0,

  AF_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  AF_Err_Nested_DEFS = 0x89 + 0,

  AF_Err_Invalid_CodeRange = 0x8A + 0,

  AF_Err_Execution_Too_Long = 0x8B + 0,

  AF_Err_Too_Many_Function_Defs = 0x8C + 0,

  AF_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  AF_Err_Table_Missing = 0x8E + 0,

  AF_Err_Horiz_Header_Missing = 0x8F + 0,

  AF_Err_Locations_Missing = 0x90 + 0,

  AF_Err_Name_Table_Missing = 0x91 + 0,

  AF_Err_CMap_Table_Missing = 0x92 + 0,

  AF_Err_Hmtx_Table_Missing = 0x93 + 0,

  AF_Err_Post_Table_Missing = 0x94 + 0,

  AF_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  AF_Err_Invalid_CharMap_Format = 0x96 + 0,

  AF_Err_Invalid_PPem = 0x97 + 0,

  AF_Err_Invalid_Vert_Metrics = 0x98 + 0,

  AF_Err_Could_Not_Find_Context = 0x99 + 0,

  AF_Err_Invalid_Post_Table_Format = 0x9A + 0,

  AF_Err_Invalid_Post_Table = 0x9B + 0,




  AF_Err_Syntax_Error = 0xA0 + 0,

  AF_Err_Stack_Underflow = 0xA1 + 0,

  AF_Err_Ignore = 0xA2 + 0,

  AF_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  AF_Err_Glyph_Too_Big = 0xA4 + 0,




  AF_Err_Missing_Startfont_Field = 0xB0 + 0,

  AF_Err_Missing_Font_Field = 0xB1 + 0,

  AF_Err_Missing_Size_Field = 0xB2 + 0,

  AF_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  AF_Err_Missing_Chars_Field = 0xB4 + 0,

  AF_Err_Missing_Startchar_Field = 0xB5 + 0,

  AF_Err_Missing_Encoding_Field = 0xB6 + 0,

  AF_Err_Missing_Bbx_Field = 0xB7 + 0,

  AF_Err_Bbx_Too_Big = 0xB8 + 0,

  AF_Err_Corrupted_Font_Header = 0xB9 + 0,

  AF_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 179 "../../../libs/freetype/include/freetype/fterrors.h" 2



  AF_Err_Max };
# 38 "../../../libs/freetype/src/autofit/aferrors.h" 2
# 25 "../../../libs/freetype/src/autofit/afpic.c" 2
# 22 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afangles.c" 1
# 186 "../../../libs/freetype/src/autofit/afangles.c"
  static void
  af_sort_pos( FT_UInt count,
               FT_Pos* table )
  {
    FT_UInt i, j;
    FT_Pos swap;


    for ( i = 1; i < count; i++ )
    {
      for ( j = i; j > 0; j-- )
      {
        if ( table[j] >= table[j - 1] )
          break;

        swap = table[j];
        table[j] = table[j - 1];
        table[j - 1] = swap;
      }
    }
  }


  static void
  af_sort_and_quantize_widths( FT_UInt* count,
                               AF_Width table,
                               FT_Pos threshold )
  {
    FT_UInt i, j;
    FT_UInt cur_idx;
    FT_Pos cur_val;
    FT_Pos sum;
    AF_WidthRec swap;


    if ( *count == 1 )
      return;


    for ( i = 1; i < *count; i++ )
    {
      for ( j = i; j > 0; j-- )
      {
        if ( table[j].org >= table[j - 1].org )
          break;

        swap = table[j];
        table[j] = table[j - 1];
        table[j - 1] = swap;
      }
    }

    cur_idx = 0;
    cur_val = table[cur_idx].org;





    for ( i = 1; i < *count; i++ )
    {
      if ( table[i].org - cur_val > threshold ||
           i == *count - 1 )
      {
        sum = 0;


        if ( table[i].org - cur_val <= threshold &&
             i == *count - 1 )
          i++;

        for ( j = cur_idx; j < i; j++ )
        {
          sum += table[j].org;
          table[j].org = 0;
        }
        table[cur_idx].org = sum / (FT_Pos)j;

        if ( i < *count - 1 )
        {
          cur_idx = i + 1;
          cur_val = table[cur_idx].org;
        }
      }
    }

    cur_idx = 1;


    for ( i = 1; i < *count; i++ )
    {
      if ( table[i].org )
        table[cur_idx++] = table[i];
    }

    *count = cur_idx;
  }
# 23 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afblue.c" 1
# 25 "../../../libs/freetype/src/autofit/afblue.c"
  const char
  af_blue_strings[] =
  {

    '\xD8', '\xA7', '\xD8', '\xA5', '\xD9', '\x84', '\xD9', '\x83', '\xD8', '\xB7', '\xD8', '\xB8',
    '\0',
    '\xD8', '\xAA', '\xD8', '\xAB', '\xD8', '\xB7', '\xD8', '\xB8', '\xD9', '\x83',
    '\0',
    '\xD9', '\x80',
    '\0',
    '\xD0', '\x91', '\xD0', '\x92', '\xD0', '\x95', '\xD0', '\x9F', '\xD0', '\x97', '\xD0', '\x9E', '\xD0', '\xA1', '\xD0', '\xAD',
    '\0',
    '\xD0', '\x91', '\xD0', '\x92', '\xD0', '\x95', '\xD0', '\xA8', '\xD0', '\x97', '\xD0', '\x9E', '\xD0', '\xA1', '\xD0', '\xAD',
    '\0',
    '\xD1', '\x85', '\xD0', '\xBF', '\xD0', '\xBD', '\xD1', '\x88', '\xD0', '\xB5', '\xD0', '\xB7', '\xD0', '\xBE', '\xD1', '\x81',
    '\0',
    '\xD1', '\x80', '\xD1', '\x83', '\xD1', '\x84',
    '\0',
    '\xE0', '\xA4', '\x95', '\xE0', '\xA4', '\xAE', '\xE0', '\xA4', '\x85', '\xE0', '\xA4', '\x86', '\xE0', '\xA4', '\xA5', '\xE0', '\xA4', '\xA7', '\xE0', '\xA4', '\xAD', '\xE0', '\xA4', '\xB6',
    '\0',
    '\xE0', '\xA4', '\x88', '\xE0', '\xA4', '\x90', '\xE0', '\xA4', '\x93', '\xE0', '\xA4', '\x94', '\xE0', '\xA4', '\xBF', '\xE0', '\xA5', '\x80', '\xE0', '\xA5', '\x8B', '\xE0', '\xA5', '\x8C',
    '\0',
    '\xE0', '\xA4', '\x95', '\xE0', '\xA4', '\xAE', '\xE0', '\xA4', '\x85', '\xE0', '\xA4', '\x86', '\xE0', '\xA4', '\xA5', '\xE0', '\xA4', '\xA7', '\xE0', '\xA4', '\xAD', '\xE0', '\xA4', '\xB6',
    '\0',
    '\xE0', '\xA5', '\x81', '\xE0', '\xA5', '\x83',
    '\0',
    '\xCE', '\x93', '\xCE', '\x92', '\xCE', '\x95', '\xCE', '\x96', '\xCE', '\x98', '\xCE', '\x9F', '\xCE', '\xA9',
    '\0',
    '\xCE', '\x92', '\xCE', '\x94', '\xCE', '\x96', '\xCE', '\x9E', '\xCE', '\x98', '\xCE', '\x9F',
    '\0',
    '\xCE', '\xB2', '\xCE', '\xB8', '\xCE', '\xB4', '\xCE', '\xB6', '\xCE', '\xBB', '\xCE', '\xBE',
    '\0',
    '\xCE', '\xB1', '\xCE', '\xB5', '\xCE', '\xB9', '\xCE', '\xBF', '\xCF', '\x80', '\xCF', '\x83', '\xCF', '\x84', '\xCF', '\x89',
    '\0',
    '\xCE', '\xB2', '\xCE', '\xB3', '\xCE', '\xB7', '\xCE', '\xBC', '\xCF', '\x81', '\xCF', '\x86', '\xCF', '\x87', '\xCF', '\x88',
    '\0',
    '\xD7', '\x91', '\xD7', '\x93', '\xD7', '\x94', '\xD7', '\x97', '\xD7', '\x9A', '\xD7', '\x9B', '\xD7', '\x9D', '\xD7', '\xA1',
    '\0',
    '\xD7', '\x91', '\xD7', '\x98', '\xD7', '\x9B', '\xD7', '\x9D', '\xD7', '\xA1', '\xD7', '\xA6',
    '\0',
    '\xD7', '\xA7', '\xD7', '\x9A', '\xD7', '\x9F', '\xD7', '\xA3', '\xD7', '\xA5',
    '\0',
    '\xE0', '\xBA', '\xB2', '\xE0', '\xBA', '\x94', '\xE0', '\xBA', '\xAD', '\xE0', '\xBA', '\xA1', '\xE0', '\xBA', '\xA5', '\xE0', '\xBA', '\xA7', '\xE0', '\xBA', '\xA3', '\xE0', '\xBA', '\x87',
    '\0',
    '\xE0', '\xBA', '\xB2', '\xE0', '\xBA', '\xAD', '\xE0', '\xBA', '\x9A', '\xE0', '\xBA', '\x8D', '\xE0', '\xBA', '\xA3', '\xE0', '\xBA', '\xAE', '\xE0', '\xBA', '\xA7', '\xE0', '\xBA', '\xA2',
    '\0',
    '\xE0', '\xBA', '\x9B', '\xE0', '\xBA', '\xA2', '\xE0', '\xBA', '\x9F', '\xE0', '\xBA', '\x9D',
    '\0',
    '\xE0', '\xBB', '\x82', '\xE0', '\xBB', '\x84', '\xE0', '\xBB', '\x83',
    '\0',
    '\xE0', '\xBA', '\x87', '\xE0', '\xBA', '\x8A', '\xE0', '\xBA', '\x96', '\xE0', '\xBA', '\xBD', '\xE0', '\xBB', '\x86', '\xE0', '\xBA', '\xAF',
    '\0',
    'T', 'H', 'E', 'Z', 'O', 'C', 'Q', 'S',
    '\0',
    'H', 'E', 'Z', 'L', 'O', 'C', 'U', 'S',
    '\0',
    'f', 'i', 'j', 'k', 'd', 'b', 'h',
    '\0',
    'x', 'z', 'r', 'o', 'e', 's', 'c',
    '\0',
    'p', 'q', 'g', 'j', 'y',
    '\0',
    '\xE2', '\x82', '\x80', '\xE2', '\x82', '\x83', '\xE2', '\x82', '\x85', '\xE2', '\x82', '\x87', '\xE2', '\x82', '\x88',
    '\0',
    '\xE2', '\x82', '\x80', '\xE2', '\x82', '\x81', '\xE2', '\x82', '\x82', '\xE2', '\x82', '\x83', '\xE2', '\x82', '\x88',
    '\0',
    '\xE1', '\xB5', '\xA2', '\xE2', '\xB1', '\xBC', '\xE2', '\x82', '\x95', '\xE2', '\x82', '\x96', '\xE2', '\x82', '\x97',
    '\0',
    '\xE2', '\x82', '\x90', '\xE2', '\x82', '\x91', '\xE2', '\x82', '\x92', '\xE2', '\x82', '\x93', '\xE2', '\x82', '\x99', '\xE2', '\x82', '\x9B', '\xE1', '\xB5', '\xA5', '\xE1', '\xB5', '\xA4', '\xE1', '\xB5', '\xA3',
    '\0',
    '\xE1', '\xB5', '\xA6', '\xE1', '\xB5', '\xA7', '\xE1', '\xB5', '\xA8', '\xE1', '\xB5', '\xA9', '\xE2', '\x82', '\x9A',
    '\0',
    '\xE2', '\x81', '\xB0', '\xC2', '\xB3', '\xE2', '\x81', '\xB5', '\xE2', '\x81', '\xB7', '\xE1', '\xB5', '\x80', '\xE1', '\xB4', '\xB4', '\xE1', '\xB4', '\xB1', '\xE1', '\xB4', '\xBC',
    '\0',
    '\xE2', '\x81', '\xB0', '\xC2', '\xB9', '\xC2', '\xB2', '\xC2', '\xB3', '\xE1', '\xB4', '\xB1', '\xE1', '\xB4', '\xB8', '\xE1', '\xB4', '\xBC', '\xE1', '\xB5', '\x81',
    '\0',
    '\xE1', '\xB5', '\x87', '\xE1', '\xB5', '\x88', '\xE1', '\xB5', '\x8F', '\xCA', '\xB0', '\xCA', '\xB2', '\xE1', '\xB6', '\xA0', '\xE2', '\x81', '\xB1',
    '\0',
    '\xE1', '\xB5', '\x89', '\xE1', '\xB5', '\x92', '\xCA', '\xB3', '\xCB', '\xA2', '\xCB', '\xA3', '\xE1', '\xB6', '\x9C', '\xE1', '\xB6', '\xBB',
    '\0',
    '\xE1', '\xB5', '\x96', '\xCA', '\xB8', '\xE1', '\xB5', '\x8D',
    '\0',
    '\xE0', '\xB0', '\x87', '\xE0', '\xB0', '\x8C', '\xE0', '\xB0', '\x99', '\xE0', '\xB0', '\x9E', '\xE0', '\xB0', '\xA3', '\xE0', '\xB0', '\xB1', '\xE0', '\xB1', '\xAF',
    '\0',
    '\xE0', '\xB0', '\x85', '\xE0', '\xB0', '\x95', '\xE0', '\xB0', '\x9A', '\xE0', '\xB0', '\xB0', '\xE0', '\xB0', '\xBD', '\xE0', '\xB1', '\xA8', '\xE0', '\xB1', '\xAC',
    '\0',
    '\xE0', '\xB8', '\x9A', '\xE0', '\xB9', '\x80', '\xE0', '\xB9', '\x81', '\xE0', '\xB8', '\xAD', '\xE0', '\xB8', '\x81', '\xE0', '\xB8', '\xB2',
    '\0',
    '\xE0', '\xB8', '\x9A', '\xE0', '\xB8', '\x9B', '\xE0', '\xB8', '\xA9', '\xE0', '\xB8', '\xAF', '\xE0', '\xB8', '\xAD', '\xE0', '\xB8', '\xA2', '\xE0', '\xB8', '\xAE',
    '\0',
    '\xE0', '\xB8', '\x9B', '\xE0', '\xB8', '\x9D', '\xE0', '\xB8', '\x9F',
    '\0',
    '\xE0', '\xB9', '\x82', '\xE0', '\xB9', '\x83', '\xE0', '\xB9', '\x84',
    '\0',
    '\xE0', '\xB8', '\x8E', '\xE0', '\xB8', '\x8F', '\xE0', '\xB8', '\xA4', '\xE0', '\xB8', '\xA6',
    '\0',
    '\xE0', '\xB8', '\x8D', '\xE0', '\xB8', '\x90',
    '\0',
    '\xE0', '\xB9', '\x90', '\xE0', '\xB9', '\x91', '\xE0', '\xB9', '\x93',

    '\0',
    '\xE4', '\xBB', '\x96', '\xE4', '\xBB', '\xAC', '\xE4', '\xBD', '\xA0', '\xE4', '\xBE', '\x86', '\xE5', '\x80', '\x91', '\xE5', '\x88', '\xB0', '\xE5', '\x92', '\x8C', '\xE5', '\x9C', '\xB0',
    '\xE5', '\xAF', '\xB9', '\xE5', '\xB0', '\x8D', '\xE5', '\xB0', '\xB1', '\xE5', '\xB8', '\xAD', '\xE6', '\x88', '\x91', '\xE6', '\x97', '\xB6', '\xE6', '\x99', '\x82', '\xE6', '\x9C', '\x83',
    '\xE6', '\x9D', '\xA5', '\xE7', '\x82', '\xBA', '\xE8', '\x83', '\xBD', '\xE8', '\x88', '\xB0', '\xE8', '\xAA', '\xAA', '\xE8', '\xAF', '\xB4', '\xE8', '\xBF', '\x99', '\xE9', '\x80', '\x99',
    '\xE9', '\xBD', '\x8A', '|',
    '\xE5', '\x86', '\x9B', '\xE5', '\x90', '\x8C', '\xE5', '\xB7', '\xB2', '\xE6', '\x84', '\xBF', '\xE6', '\x97', '\xA2', '\xE6', '\x98', '\x9F', '\xE6', '\x98', '\xAF', '\xE6', '\x99', '\xAF',
    '\xE6', '\xB0', '\x91', '\xE7', '\x85', '\xA7', '\xE7', '\x8E', '\xB0', '\xE7', '\x8F', '\xBE', '\xE7', '\x90', '\x86', '\xE7', '\x94', '\xA8', '\xE7', '\xBD', '\xAE', '\xE8', '\xA6', '\x81',
    '\xE8', '\xBB', '\x8D', '\xE9', '\x82', '\xA3', '\xE9', '\x85', '\x8D', '\xE9', '\x87', '\x8C', '\xE9', '\x96', '\x8B', '\xE9', '\x9B', '\xB7', '\xE9', '\x9C', '\xB2', '\xE9', '\x9D', '\xA2',
    '\xE9', '\xA1', '\xBE',
    '\0',
    '\xE4', '\xB8', '\xAA', '\xE4', '\xB8', '\xBA', '\xE4', '\xBA', '\xBA', '\xE4', '\xBB', '\x96', '\xE4', '\xBB', '\xA5', '\xE4', '\xBB', '\xAC', '\xE4', '\xBD', '\xA0', '\xE4', '\xBE', '\x86',
    '\xE5', '\x80', '\x8B', '\xE5', '\x80', '\x91', '\xE5', '\x88', '\xB0', '\xE5', '\x92', '\x8C', '\xE5', '\xA4', '\xA7', '\xE5', '\xAF', '\xB9', '\xE5', '\xB0', '\x8D', '\xE5', '\xB0', '\xB1',
    '\xE6', '\x88', '\x91', '\xE6', '\x97', '\xB6', '\xE6', '\x99', '\x82', '\xE6', '\x9C', '\x89', '\xE6', '\x9D', '\xA5', '\xE7', '\x82', '\xBA', '\xE8', '\xA6', '\x81', '\xE8', '\xAA', '\xAA',
    '\xE8', '\xAF', '\xB4', '|',
    '\xE4', '\xB8', '\xBB', '\xE4', '\xBA', '\x9B', '\xE5', '\x9B', '\xA0', '\xE5', '\xAE', '\x83', '\xE6', '\x83', '\xB3', '\xE6', '\x84', '\x8F', '\xE7', '\x90', '\x86', '\xE7', '\x94', '\x9F',
    '\xE7', '\x95', '\xB6', '\xE7', '\x9C', '\x8B', '\xE7', '\x9D', '\x80', '\xE7', '\xBD', '\xAE', '\xE8', '\x80', '\x85', '\xE8', '\x87', '\xAA', '\xE8', '\x91', '\x97', '\xE8', '\xA3', '\xA1',
    '\xE8', '\xBF', '\x87', '\xE8', '\xBF', '\x98', '\xE8', '\xBF', '\x9B', '\xE9', '\x80', '\xB2', '\xE9', '\x81', '\x8E', '\xE9', '\x81', '\x93', '\xE9', '\x82', '\x84', '\xE9', '\x87', '\x8C',
    '\xE9', '\x9D', '\xA2',
# 164 "../../../libs/freetype/src/autofit/afblue.c"
    '\0',

  };



  const AF_Blue_StringRec
  af_blue_stringsets[] =
  {

    { AF_BLUE_STRING_ARABIC_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_ARABIC_BOTTOM, 0 },
    { AF_BLUE_STRING_ARABIC_JOIN, ( 1U << 1 ) },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_CYRILLIC_CAPITAL_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_CYRILLIC_CAPITAL_BOTTOM, 0 },
    { AF_BLUE_STRING_CYRILLIC_SMALL, ( 1U << 0 ) |
                                               ( 1U << 2 ) },
    { AF_BLUE_STRING_CYRILLIC_SMALL, 0 },
    { AF_BLUE_STRING_CYRILLIC_SMALL_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_DEVANAGARI_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_DEVANAGARI_HEAD, ( 1U << 0 ) },
    { AF_BLUE_STRING_DEVANAGARI_BASE, ( 1U << 0 ) |
                                        ( 1U << 1 ) |
                                        ( 1U << 2 ) },
    { AF_BLUE_STRING_DEVANAGARI_BASE, 0 },
    { AF_BLUE_STRING_DEVANAGARI_BOTTOM, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_GREEK_CAPITAL_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM, 0 },
    { AF_BLUE_STRING_GREEK_SMALL_BETA_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_GREEK_SMALL, ( 1U << 0 ) |
                                            ( 1U << 2 ) },
    { AF_BLUE_STRING_GREEK_SMALL, 0 },
    { AF_BLUE_STRING_GREEK_SMALL_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_HEBREW_TOP, ( 1U << 0 ) |
                                       ( 1U << 3 ) },
    { AF_BLUE_STRING_HEBREW_BOTTOM, 0 },
    { AF_BLUE_STRING_HEBREW_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_LAO_TOP, ( 1U << 0 ) |
                                          ( 1U << 2 ) },
    { AF_BLUE_STRING_LAO_BOTTOM, 0 },
    { AF_BLUE_STRING_LAO_ASCENDER, ( 1U << 0 ) },
    { AF_BLUE_STRING_LAO_LARGE_ASCENDER, ( 1U << 0 ) },
    { AF_BLUE_STRING_LAO_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_LATIN_CAPITAL_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_LATIN_CAPITAL_BOTTOM, 0 },
    { AF_BLUE_STRING_LATIN_SMALL_F_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_LATIN_SMALL, ( 1U << 0 ) |
                                            ( 1U << 2 ) },
    { AF_BLUE_STRING_LATIN_SMALL, 0 },
    { AF_BLUE_STRING_LATIN_SMALL_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_LATIN_SUBS_CAPITAL_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_LATIN_SUBS_CAPITAL_BOTTOM, 0 },
    { AF_BLUE_STRING_LATIN_SUBS_SMALL_F_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_LATIN_SUBS_SMALL, ( 1U << 0 ) |
                                                 ( 1U << 2 ) },
    { AF_BLUE_STRING_LATIN_SUBS_SMALL, 0 },
    { AF_BLUE_STRING_LATIN_SUBS_SMALL_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_LATIN_SUPS_CAPITAL_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_LATIN_SUPS_CAPITAL_BOTTOM, 0 },
    { AF_BLUE_STRING_LATIN_SUPS_SMALL_F_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_LATIN_SUPS_SMALL, ( 1U << 0 ) |
                                                 ( 1U << 2 ) },
    { AF_BLUE_STRING_LATIN_SUPS_SMALL, 0 },
    { AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_TELUGU_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_TELUGU_BOTTOM, 0 },
    { AF_BLUE_STRING_MAX, 0 },
    { AF_BLUE_STRING_THAI_TOP, ( 1U << 0 ) |
                                           ( 1U << 2 ) },
    { AF_BLUE_STRING_THAI_BOTTOM, 0 },
    { AF_BLUE_STRING_THAI_ASCENDER, ( 1U << 0 ) },
    { AF_BLUE_STRING_THAI_LARGE_ASCENDER, ( 1U << 0 ) },
    { AF_BLUE_STRING_THAI_DESCENDER, 0 },
    { AF_BLUE_STRING_THAI_LARGE_DESCENDER, 0 },
    { AF_BLUE_STRING_THAI_DIGIT_TOP, 0 },
    { AF_BLUE_STRING_MAX, 0 },

    { AF_BLUE_STRING_CJK_TOP, ( 1U << 0 ) },
    { AF_BLUE_STRING_CJK_BOTTOM, 0 },





    { AF_BLUE_STRING_MAX, 0 },


  };
# 24 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afglobal.c" 1
# 20 "../../../libs/freetype/src/autofit/afglobal.c"
# 1 "../../../libs/freetype/src/autofit/afranges.h" 1
# 26 "../../../libs/freetype/src/autofit/afranges.h"






# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  extern const AF_Script_UniRangeRec af_arab_uniranges[];




  extern const AF_Script_UniRangeRec af_cyrl_uniranges[];




  extern const AF_Script_UniRangeRec af_deva_uniranges[];




  extern const AF_Script_UniRangeRec af_grek_uniranges[];




  extern const AF_Script_UniRangeRec af_hebr_uniranges[];





  extern const AF_Script_UniRangeRec af_lao_uniranges[];




  extern const AF_Script_UniRangeRec af_latn_uniranges[];




  extern const AF_Script_UniRangeRec af_latb_uniranges[];




  extern const AF_Script_UniRangeRec af_latp_uniranges[];




  extern const AF_Script_UniRangeRec af_none_uniranges[];





  extern const AF_Script_UniRangeRec af_telu_uniranges[];




  extern const AF_Script_UniRangeRec af_thai_uniranges[];






  extern const AF_Script_UniRangeRec af_beng_uniranges[];




  extern const AF_Script_UniRangeRec af_gujr_uniranges[];




  extern const AF_Script_UniRangeRec af_guru_uniranges[];




  extern const AF_Script_UniRangeRec af_knda_uniranges[];




  extern const AF_Script_UniRangeRec af_limb_uniranges[];




  extern const AF_Script_UniRangeRec af_mlym_uniranges[];




  extern const AF_Script_UniRangeRec af_orya_uniranges[];




  extern const AF_Script_UniRangeRec af_sinh_uniranges[];




  extern const AF_Script_UniRangeRec af_sund_uniranges[];




  extern const AF_Script_UniRangeRec af_sylo_uniranges[];




  extern const AF_Script_UniRangeRec af_taml_uniranges[];




  extern const AF_Script_UniRangeRec af_tibt_uniranges[];
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  extern const AF_Script_UniRangeRec af_hani_uniranges[];
# 33 "../../../libs/freetype/src/autofit/afranges.h" 2





# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  extern const AF_Script_UniRangeRec af_arab_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_cyrl_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_deva_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_grek_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_hebr_nonbase_uniranges[];





  extern const AF_Script_UniRangeRec af_lao_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_latn_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_latb_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_latp_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_none_nonbase_uniranges[];





  extern const AF_Script_UniRangeRec af_telu_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_thai_nonbase_uniranges[];






  extern const AF_Script_UniRangeRec af_beng_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_gujr_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_guru_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_knda_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_limb_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_mlym_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_orya_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_sinh_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_sund_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_sylo_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_taml_nonbase_uniranges[];




  extern const AF_Script_UniRangeRec af_tibt_nonbase_uniranges[];
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  extern const AF_Script_UniRangeRec af_hani_nonbase_uniranges[];
# 39 "../../../libs/freetype/src/autofit/afranges.h" 2




# 21 "../../../libs/freetype/src/autofit/afglobal.c" 2
# 38 "../../../libs/freetype/src/autofit/afglobal.c"
# 1 "../../../libs/freetype/src/autofit/afwrtsys.h" 1
# 25 "../../../libs/freetype/src/autofit/afwrtsys.h"
# 1 "../../../libs/freetype/src/autofit/afdummy.h" 1
# 26 "../../../libs/freetype/src/autofit/afdummy.h"




  extern const AF_WritingSystemClassRec af_dummy_writing_system_class;




# 26 "../../../libs/freetype/src/autofit/afwrtsys.h" 2
# 1 "../../../libs/freetype/src/autofit/aflatin.h" 1
# 23 "../../../libs/freetype/src/autofit/aflatin.h"
# 1 "../../../libs/freetype/src/autofit/afhints.h" 1
# 26 "../../../libs/freetype/src/autofit/afhints.h"







  typedef enum AF_Dimension_
  {
    AF_DIMENSION_HORZ = 0,

    AF_DIMENSION_VERT = 1,


    AF_DIMENSION_MAX

  } AF_Dimension;




  typedef enum AF_Direction_
  {
    AF_DIR_NONE = 4,
    AF_DIR_RIGHT = 1,
    AF_DIR_LEFT = -1,
    AF_DIR_UP = 2,
    AF_DIR_DOWN = -2

  } AF_Direction;
# 233 "../../../libs/freetype/src/autofit/afhints.h"
  typedef struct AF_PointRec_* AF_Point;
  typedef struct AF_SegmentRec_* AF_Segment;
  typedef struct AF_EdgeRec_* AF_Edge;


  typedef struct AF_PointRec_
  {
    FT_UShort flags;
    FT_Char in_dir;
    FT_Char out_dir;

    FT_Pos ox, oy;
    FT_Short fx, fy;
    FT_Pos x, y;
    FT_Pos u, v;

    AF_Point next;
    AF_Point prev;

  } AF_PointRec;


  typedef struct AF_SegmentRec_
  {
    FT_Byte flags;
    FT_Char dir;
    FT_Short pos;
    FT_Short min_coord;
    FT_Short max_coord;
    FT_Short height;

    AF_Edge edge;
    AF_Segment edge_next;

    AF_Segment link;
    AF_Segment serif;
    FT_Pos num_linked;
    FT_Pos score;
    FT_Pos len;

    AF_Point first;
    AF_Point last;

  } AF_SegmentRec;


  typedef struct AF_EdgeRec_
  {
    FT_Short fpos;
    FT_Pos opos;
    FT_Pos pos;

    FT_Byte flags;
    FT_Char dir;
    FT_Fixed scale;

    AF_Width blue_edge;
    AF_Edge link;
    AF_Edge serif;
    FT_Short num_linked;
    FT_Int score;

    AF_Segment first;
    AF_Segment last;

  } AF_EdgeRec;




  typedef struct AF_AxisHintsRec_
  {
    FT_Int num_segments;
    FT_Int max_segments;
    AF_Segment segments;




    FT_Int num_edges;
    FT_Int max_edges;
    AF_Edge edges;

    AF_Direction major_dir;


    struct
    {
      AF_SegmentRec segments[18];
      AF_EdgeRec edges[12];
    } embedded;


  } AF_AxisHintsRec, *AF_AxisHints;





  typedef struct AF_GlyphHintsRec_
  {
    FT_Memory memory;

    FT_Fixed x_scale;
    FT_Pos x_delta;

    FT_Fixed y_scale;
    FT_Pos y_delta;

    FT_Int max_points;
    FT_Int num_points;
    AF_Point points;

    FT_Int max_contours;
    FT_Int num_contours;
    AF_Point* contours;

    AF_AxisHintsRec axis[AF_DIMENSION_MAX];

    FT_UInt32 scaler_flags;
    FT_UInt32 other_flags;

    AF_StyleMetrics metrics;

    FT_Pos xmin_delta;
    FT_Pos xmax_delta;



    struct
    {
      AF_Point contours[8];
      AF_PointRec points[96];
    } embedded;

  } AF_GlyphHintsRec;
# 408 "../../../libs/freetype/src/autofit/afhints.h"
  static AF_Direction
  af_direction_compute( FT_Pos dx,
                        FT_Pos dy );


  static FT_Error
  af_axis_hints_new_segment( AF_AxisHints axis,
                             FT_Memory memory,
                             AF_Segment *asegment );

  static FT_Error
  af_axis_hints_new_edge( AF_AxisHints axis,
                          FT_Int fpos,
                          AF_Direction dir,
                          FT_Memory memory,
                          AF_Edge *edge );

  static void
  af_glyph_hints_init( AF_GlyphHints hints,
                       FT_Memory memory );

  static void
  af_glyph_hints_rescale( AF_GlyphHints hints,
                          AF_StyleMetrics metrics );

  static FT_Error
  af_glyph_hints_reload( AF_GlyphHints hints,
                         FT_Outline* outline );

  static void
  af_glyph_hints_save( AF_GlyphHints hints,
                       FT_Outline* outline );

  static void
  af_glyph_hints_align_edge_points( AF_GlyphHints hints,
                                    AF_Dimension dim );

  static void
  af_glyph_hints_align_strong_points( AF_GlyphHints hints,
                                      AF_Dimension dim );

  static void
  af_glyph_hints_align_weak_points( AF_GlyphHints hints,
                                    AF_Dimension dim );
# 461 "../../../libs/freetype/src/autofit/afhints.h"
  static void
  af_glyph_hints_done( AF_GlyphHints hints );
# 473 "../../../libs/freetype/src/autofit/afhints.h"

# 24 "../../../libs/freetype/src/autofit/aflatin.h" 2






  extern const AF_WritingSystemClassRec af_latin_writing_system_class;
# 73 "../../../libs/freetype/src/autofit/aflatin.h"
  typedef struct AF_LatinBlueRec_
  {
    AF_WidthRec ref;
    AF_WidthRec shoot;
    FT_Pos ascender;
    FT_Pos descender;
    FT_UInt flags;

  } AF_LatinBlueRec, *AF_LatinBlue;


  typedef struct AF_LatinAxisRec_
  {
    FT_Fixed scale;
    FT_Pos delta;

    FT_UInt width_count;
    AF_WidthRec widths[16];
    FT_Pos edge_distance_threshold;
    FT_Pos standard_width;
    FT_Bool extra_light;


    FT_UInt blue_count;
    AF_LatinBlueRec blues[AF_BLUE_STRINGSET_MAX];

    FT_Fixed org_scale;
    FT_Pos org_delta;

  } AF_LatinAxisRec, *AF_LatinAxis;


  typedef struct AF_LatinMetricsRec_
  {
    AF_StyleMetricsRec root;
    FT_UInt units_per_em;
    AF_LatinAxisRec axis[AF_DIMENSION_MAX];

  } AF_LatinMetricsRec, *AF_LatinMetrics;


  static FT_Error
  af_latin_metrics_init( AF_LatinMetrics metrics,
                         FT_Face face );

  static void
  af_latin_metrics_scale( AF_LatinMetrics metrics,
                          AF_Scaler scaler );

  static void
  af_latin_metrics_init_widths( AF_LatinMetrics metrics,
                                FT_Face face );

  static void
  af_latin_metrics_check_digits( AF_LatinMetrics metrics,
                                 FT_Face face );
# 163 "../../../libs/freetype/src/autofit/aflatin.h"
  static FT_Error
  af_latin_hints_compute_segments( AF_GlyphHints hints,
                                   AF_Dimension dim );

  static void
  af_latin_hints_link_segments( AF_GlyphHints hints,
                                FT_UInt width_count,
                                AF_WidthRec* widths,
                                AF_Dimension dim );

  static FT_Error
  af_latin_hints_compute_edges( AF_GlyphHints hints,
                                AF_Dimension dim );

  static FT_Error
  af_latin_hints_detect_features( AF_GlyphHints hints,
                                  FT_UInt width_count,
                                  AF_WidthRec* widths,
                                  AF_Dimension dim );




# 27 "../../../libs/freetype/src/autofit/afwrtsys.h" 2
# 1 "../../../libs/freetype/src/autofit/afcjk.h" 1
# 26 "../../../libs/freetype/src/autofit/afcjk.h"





  extern const AF_WritingSystemClassRec af_cjk_writing_system_class;
# 64 "../../../libs/freetype/src/autofit/afcjk.h"
  typedef struct AF_CJKBlueRec_
  {
    AF_WidthRec ref;
    AF_WidthRec shoot;
    FT_UInt flags;

  } AF_CJKBlueRec, *AF_CJKBlue;


  typedef struct AF_CJKAxisRec_
  {
    FT_Fixed scale;
    FT_Pos delta;

    FT_UInt width_count;
    AF_WidthRec widths[16];
    FT_Pos edge_distance_threshold;
    FT_Pos standard_width;
    FT_Bool extra_light;


    FT_Bool control_overshoot;
    FT_UInt blue_count;
    AF_CJKBlueRec blues[AF_BLUE_STRINGSET_MAX];

    FT_Fixed org_scale;
    FT_Pos org_delta;

  } AF_CJKAxisRec, *AF_CJKAxis;


  typedef struct AF_CJKMetricsRec_
  {
    AF_StyleMetricsRec root;
    FT_UInt units_per_em;
    AF_CJKAxisRec axis[AF_DIMENSION_MAX];

  } AF_CJKMetricsRec, *AF_CJKMetrics;



  static FT_Error
  af_cjk_metrics_init( AF_CJKMetrics metrics,
                       FT_Face face );

  static void
  af_cjk_metrics_scale( AF_CJKMetrics metrics,
                        AF_Scaler scaler );

  static FT_Error
  af_cjk_hints_init( AF_GlyphHints hints,
                     AF_CJKMetrics metrics );

  static FT_Error
  af_cjk_hints_apply( FT_UInt glyph_index,
                      AF_GlyphHints hints,
                      FT_Outline* outline,
                      AF_CJKMetrics metrics );


  static void
  af_cjk_metrics_check_digits( AF_CJKMetrics metrics,
                               FT_Face face );

  static void
  af_cjk_metrics_init_widths( AF_CJKMetrics metrics,
                              FT_Face face );






# 28 "../../../libs/freetype/src/autofit/afwrtsys.h" 2
# 1 "../../../libs/freetype/src/autofit/afindic.h" 1
# 26 "../../../libs/freetype/src/autofit/afindic.h"





  extern const AF_WritingSystemClassRec af_indic_writing_system_class;





# 29 "../../../libs/freetype/src/autofit/afwrtsys.h" 2
# 43 "../../../libs/freetype/src/autofit/afwrtsys.h"
 
 
 
 
# 39 "../../../libs/freetype/src/autofit/afglobal.c" 2
# 53 "../../../libs/freetype/src/autofit/afglobal.c"
# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  const AF_ScriptClassRec af_arab_script_class = { AF_SCRIPT_ARAB, af_arab_uniranges, af_arab_nonbase_uniranges, 0x644, 0x62D, 0x640 };




  const AF_ScriptClassRec af_cyrl_script_class = { AF_SCRIPT_CYRL, af_cyrl_uniranges, af_cyrl_nonbase_uniranges, 0x43E, 0x41E, 0x0 };




  const AF_ScriptClassRec af_deva_script_class = { AF_SCRIPT_DEVA, af_deva_uniranges, af_deva_nonbase_uniranges, 0x920, 0x935, 0x91F };




  const AF_ScriptClassRec af_grek_script_class = { AF_SCRIPT_GREK, af_grek_uniranges, af_grek_nonbase_uniranges, 0x3BF, 0x39F, 0x0 };




  const AF_ScriptClassRec af_hebr_script_class = { AF_SCRIPT_HEBR, af_hebr_uniranges, af_hebr_nonbase_uniranges, 0x5DD, 0x0, 0x0 };





  const AF_ScriptClassRec af_lao_script_class = { AF_SCRIPT_LAO, af_lao_uniranges, af_lao_nonbase_uniranges, 0xED0, 0x0, 0x0 };




  const AF_ScriptClassRec af_latn_script_class = { AF_SCRIPT_LATN, af_latn_uniranges, af_latn_nonbase_uniranges, 'o', 'O', '0' };




  const AF_ScriptClassRec af_latb_script_class = { AF_SCRIPT_LATB, af_latb_uniranges, af_latb_nonbase_uniranges, 0x2092, 0x2080, 0x0 };




  const AF_ScriptClassRec af_latp_script_class = { AF_SCRIPT_LATP, af_latp_uniranges, af_latp_nonbase_uniranges, 0x1D52, 0x1D3C, 0x2070 };




  const AF_ScriptClassRec af_none_script_class = { AF_SCRIPT_NONE, af_none_uniranges, af_none_nonbase_uniranges, 0x0, 0x0, 0x0 };





  const AF_ScriptClassRec af_telu_script_class = { AF_SCRIPT_TELU, af_telu_uniranges, af_telu_nonbase_uniranges, 0xC66, 0xC67, 0x0 };




  const AF_ScriptClassRec af_thai_script_class = { AF_SCRIPT_THAI, af_thai_uniranges, af_thai_nonbase_uniranges, 0xE32, 0xE45, 0xE50 };






  const AF_ScriptClassRec af_beng_script_class = { AF_SCRIPT_BENG, af_beng_uniranges, af_beng_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_gujr_script_class = { AF_SCRIPT_GUJR, af_gujr_uniranges, af_gujr_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_guru_script_class = { AF_SCRIPT_GURU, af_guru_uniranges, af_guru_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_knda_script_class = { AF_SCRIPT_KNDA, af_knda_uniranges, af_knda_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_limb_script_class = { AF_SCRIPT_LIMB, af_limb_uniranges, af_limb_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_mlym_script_class = { AF_SCRIPT_MLYM, af_mlym_uniranges, af_mlym_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_orya_script_class = { AF_SCRIPT_ORYA, af_orya_uniranges, af_orya_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_sinh_script_class = { AF_SCRIPT_SINH, af_sinh_uniranges, af_sinh_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_sund_script_class = { AF_SCRIPT_SUND, af_sund_uniranges, af_sund_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_sylo_script_class = { AF_SCRIPT_SYLO, af_sylo_uniranges, af_sylo_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_taml_script_class = { AF_SCRIPT_TAML, af_taml_uniranges, af_taml_nonbase_uniranges, 'o', 0x0, 0x0 };




  const AF_ScriptClassRec af_tibt_script_class = { AF_SCRIPT_TIBT, af_tibt_uniranges, af_tibt_nonbase_uniranges, 'o', 0x0, 0x0 };
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  const AF_ScriptClassRec af_hani_script_class = { AF_SCRIPT_HANI, af_hani_uniranges, af_hani_nonbase_uniranges, 0x7530, 0x56D7, 0x0 };
# 54 "../../../libs/freetype/src/autofit/afglobal.c" 2
# 66 "../../../libs/freetype/src/autofit/afglobal.c"
# 1 "../../../libs/freetype/src/autofit/afstyles.h" 1
# 86 "../../../libs/freetype/src/autofit/afstyles.h"
  const AF_StyleClassRec af_arab_dflt_style_class = { AF_STYLE_ARAB_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_ARAB, AF_BLUE_STRINGSET_ARAB, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_cyrl_c2cp_style_class = { AF_STYLE_CYRL_C2CP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_PETITE_CAPITALS_FROM_CAPITALS }; const AF_StyleClassRec af_cyrl_c2sc_style_class = { AF_STYLE_CYRL_C2SC, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_SMALL_CAPITALS_FROM_CAPITALS }; const AF_StyleClassRec af_cyrl_ordn_style_class = { AF_STYLE_CYRL_ORDN, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_ORDINALS }; const AF_StyleClassRec af_cyrl_pcap_style_class = { AF_STYLE_CYRL_PCAP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_PETITE_CAPITALS }; const AF_StyleClassRec af_cyrl_sinf_style_class = { AF_STYLE_CYRL_SINF, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_SCIENTIFIC_INFERIORS }; const AF_StyleClassRec af_cyrl_smcp_style_class = { AF_STYLE_CYRL_SMCP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_SMALL_CAPITALS }; const AF_StyleClassRec af_cyrl_subs_style_class = { AF_STYLE_CYRL_SUBS, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_SUBSCRIPT }; const AF_StyleClassRec af_cyrl_sups_style_class = { AF_STYLE_CYRL_SUPS, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_SUPERSCRIPT }; const AF_StyleClassRec af_cyrl_titl_style_class = { AF_STYLE_CYRL_TITL, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_TITLING }; const AF_StyleClassRec af_cyrl_dflt_style_class = { AF_STYLE_CYRL_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_CYRL, AF_BLUE_STRINGSET_CYRL, AF_COVERAGE_DEFAULT };

  const AF_StyleClassRec af_deva_dflt_style_class = { AF_STYLE_DEVA_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_DEVA, AF_BLUE_STRINGSET_DEVA, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_grek_c2cp_style_class = { AF_STYLE_GREK_C2CP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_PETITE_CAPITALS_FROM_CAPITALS }; const AF_StyleClassRec af_grek_c2sc_style_class = { AF_STYLE_GREK_C2SC, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_SMALL_CAPITALS_FROM_CAPITALS }; const AF_StyleClassRec af_grek_ordn_style_class = { AF_STYLE_GREK_ORDN, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_ORDINALS }; const AF_StyleClassRec af_grek_pcap_style_class = { AF_STYLE_GREK_PCAP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_PETITE_CAPITALS }; const AF_StyleClassRec af_grek_sinf_style_class = { AF_STYLE_GREK_SINF, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_SCIENTIFIC_INFERIORS }; const AF_StyleClassRec af_grek_smcp_style_class = { AF_STYLE_GREK_SMCP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_SMALL_CAPITALS }; const AF_StyleClassRec af_grek_subs_style_class = { AF_STYLE_GREK_SUBS, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_SUBSCRIPT }; const AF_StyleClassRec af_grek_sups_style_class = { AF_STYLE_GREK_SUPS, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_SUPERSCRIPT }; const AF_StyleClassRec af_grek_titl_style_class = { AF_STYLE_GREK_TITL, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_TITLING }; const AF_StyleClassRec af_grek_dflt_style_class = { AF_STYLE_GREK_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_GREK, AF_BLUE_STRINGSET_GREK, AF_COVERAGE_DEFAULT };

  const AF_StyleClassRec af_hebr_dflt_style_class = { AF_STYLE_HEBR_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_HEBR, AF_BLUE_STRINGSET_HEBR, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_lao_dflt_style_class = { AF_STYLE_LAO_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LAO, AF_BLUE_STRINGSET_LAO, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_latn_c2cp_style_class = { AF_STYLE_LATN_C2CP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_PETITE_CAPITALS_FROM_CAPITALS }; const AF_StyleClassRec af_latn_c2sc_style_class = { AF_STYLE_LATN_C2SC, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_SMALL_CAPITALS_FROM_CAPITALS }; const AF_StyleClassRec af_latn_ordn_style_class = { AF_STYLE_LATN_ORDN, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_ORDINALS }; const AF_StyleClassRec af_latn_pcap_style_class = { AF_STYLE_LATN_PCAP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_PETITE_CAPITALS }; const AF_StyleClassRec af_latn_sinf_style_class = { AF_STYLE_LATN_SINF, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_SCIENTIFIC_INFERIORS }; const AF_StyleClassRec af_latn_smcp_style_class = { AF_STYLE_LATN_SMCP, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_SMALL_CAPITALS }; const AF_StyleClassRec af_latn_subs_style_class = { AF_STYLE_LATN_SUBS, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_SUBSCRIPT }; const AF_StyleClassRec af_latn_sups_style_class = { AF_STYLE_LATN_SUPS, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_SUPERSCRIPT }; const AF_StyleClassRec af_latn_titl_style_class = { AF_STYLE_LATN_TITL, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_TITLING }; const AF_StyleClassRec af_latn_dflt_style_class = { AF_STYLE_LATN_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATN, AF_BLUE_STRINGSET_LATN, AF_COVERAGE_DEFAULT };

  const AF_StyleClassRec af_latb_dflt_style_class = { AF_STYLE_LATB_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATB, AF_BLUE_STRINGSET_LATB, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_latp_dflt_style_class = { AF_STYLE_LATP_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_LATP, AF_BLUE_STRINGSET_LATP, AF_COVERAGE_DEFAULT };
# 143 "../../../libs/freetype/src/autofit/afstyles.h"
  const AF_StyleClassRec af_none_dflt_style_class = { AF_STYLE_NONE_DFLT, AF_WRITING_SYSTEM_DUMMY, AF_SCRIPT_NONE, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_telu_dflt_style_class = { AF_STYLE_TELU_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_TELU, AF_BLUE_STRINGSET_TELU, AF_COVERAGE_DEFAULT };






  const AF_StyleClassRec af_thai_dflt_style_class = { AF_STYLE_THAI_DFLT, AF_WRITING_SYSTEM_LATIN, AF_SCRIPT_THAI, AF_BLUE_STRINGSET_THAI, AF_COVERAGE_DEFAULT };
# 176 "../../../libs/freetype/src/autofit/afstyles.h"
  const AF_StyleClassRec af_beng_dflt_style_class = { AF_STYLE_BENG_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_BENG, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_gujr_dflt_style_class = { AF_STYLE_GUJR_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_GUJR, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_guru_dflt_style_class = { AF_STYLE_GURU_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_GURU, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_knda_dflt_style_class = { AF_STYLE_KNDA_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_KNDA, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_limb_dflt_style_class = { AF_STYLE_LIMB_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_LIMB, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_mlym_dflt_style_class = { AF_STYLE_MLYM_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_MLYM, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_orya_dflt_style_class = { AF_STYLE_ORYA_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_ORYA, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_sinh_dflt_style_class = { AF_STYLE_SINH_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_SINH, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_sund_dflt_style_class = { AF_STYLE_SUND_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_SUND, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_sylo_dflt_style_class = { AF_STYLE_SYLO_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_SYLO, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_taml_dflt_style_class = { AF_STYLE_TAML_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_TAML, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };
  const AF_StyleClassRec af_tibt_dflt_style_class = { AF_STYLE_TIBT_DFLT, AF_WRITING_SYSTEM_INDIC, AF_SCRIPT_TIBT, (AF_Blue_Stringset)0, AF_COVERAGE_DEFAULT };





  const AF_StyleClassRec af_hani_dflt_style_class = { AF_STYLE_HANI_DFLT, AF_WRITING_SYSTEM_CJK, AF_SCRIPT_HANI, AF_BLUE_STRINGSET_HANI, AF_COVERAGE_DEFAULT };
# 67 "../../../libs/freetype/src/autofit/afglobal.c" 2
# 75 "../../../libs/freetype/src/autofit/afglobal.c"
  const AF_WritingSystemClass
  af_writing_system_classes[] =
  {

# 1 "../../../libs/freetype/src/autofit/afwrtsys.h" 1
# 43 "../../../libs/freetype/src/autofit/afwrtsys.h"
  &af_dummy_writing_system_class,
  &af_latin_writing_system_class,
  &af_cjk_writing_system_class,
  &af_indic_writing_system_class,
# 80 "../../../libs/freetype/src/autofit/afglobal.c" 2

    ((void *)0)
  };






  const AF_ScriptClass
  af_script_classes[] =
  {

# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  &af_arab_script_class,




  &af_cyrl_script_class,




  &af_deva_script_class,




  &af_grek_script_class,




  &af_hebr_script_class,





  &af_lao_script_class,




  &af_latn_script_class,




  &af_latb_script_class,




  &af_latp_script_class,




  &af_none_script_class,





  &af_telu_script_class,




  &af_thai_script_class,






  &af_beng_script_class,




  &af_gujr_script_class,




  &af_guru_script_class,




  &af_knda_script_class,




  &af_limb_script_class,




  &af_mlym_script_class,




  &af_orya_script_class,




  &af_sinh_script_class,




  &af_sund_script_class,




  &af_sylo_script_class,




  &af_taml_script_class,




  &af_tibt_script_class,
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  &af_hani_script_class,
# 94 "../../../libs/freetype/src/autofit/afglobal.c" 2

    ((void *)0)
  };






  const AF_StyleClass
  af_style_classes[] =
  {

# 1 "../../../libs/freetype/src/autofit/afstyles.h" 1
# 86 "../../../libs/freetype/src/autofit/afstyles.h"
  &af_arab_dflt_style_class,






  &af_cyrl_c2cp_style_class, &af_cyrl_c2sc_style_class, &af_cyrl_ordn_style_class, &af_cyrl_pcap_style_class, &af_cyrl_sinf_style_class, &af_cyrl_smcp_style_class, &af_cyrl_subs_style_class, &af_cyrl_sups_style_class, &af_cyrl_titl_style_class, &af_cyrl_dflt_style_class,

  &af_deva_dflt_style_class,






  &af_grek_c2cp_style_class, &af_grek_c2sc_style_class, &af_grek_ordn_style_class, &af_grek_pcap_style_class, &af_grek_sinf_style_class, &af_grek_smcp_style_class, &af_grek_subs_style_class, &af_grek_sups_style_class, &af_grek_titl_style_class, &af_grek_dflt_style_class,

  &af_hebr_dflt_style_class,






  &af_lao_dflt_style_class,






  &af_latn_c2cp_style_class, &af_latn_c2sc_style_class, &af_latn_ordn_style_class, &af_latn_pcap_style_class, &af_latn_sinf_style_class, &af_latn_smcp_style_class, &af_latn_subs_style_class, &af_latn_sups_style_class, &af_latn_titl_style_class, &af_latn_dflt_style_class,

  &af_latb_dflt_style_class,






  &af_latp_dflt_style_class,
# 143 "../../../libs/freetype/src/autofit/afstyles.h"
  &af_none_dflt_style_class,






  &af_telu_dflt_style_class,






  &af_thai_dflt_style_class,
# 176 "../../../libs/freetype/src/autofit/afstyles.h"
  &af_beng_dflt_style_class,
  &af_gujr_dflt_style_class,
  &af_guru_dflt_style_class,
  &af_knda_dflt_style_class,
  &af_limb_dflt_style_class,
  &af_mlym_dflt_style_class,
  &af_orya_dflt_style_class,
  &af_sinh_dflt_style_class,
  &af_sund_dflt_style_class,
  &af_sylo_dflt_style_class,
  &af_taml_dflt_style_class,
  &af_tibt_dflt_style_class,





  &af_hani_dflt_style_class,
# 108 "../../../libs/freetype/src/autofit/afglobal.c" 2

    ((void *)0)
  };
# 133 "../../../libs/freetype/src/autofit/afglobal.c"
  static FT_Error
  af_face_globals_compute_style_coverage( AF_FaceGlobals globals )
  {
    FT_Error error;
    FT_Face face = globals->face;
    FT_CharMap old_charmap = face->charmap;
    FT_UShort* gstyles = globals->glyph_styles;
    FT_UInt ss;
    FT_UInt i;
    FT_UInt dflt = ~0U;



    for ( i = 0; i < (FT_UInt)globals->glyph_count; i++ )
      gstyles[i] = 0x3FFF;

    error = FT_Select_Charmap( face, FT_ENCODING_UNICODE );
    if ( error )
    {




      error = FT_Err_Ok;
      goto Exit;
    }


    for ( ss = 0; af_style_classes[ss]; ss++ )
    {
      AF_StyleClass style_class =
                            af_style_classes[ss];
      AF_ScriptClass script_class =
                            af_script_classes[style_class->script];
      AF_Script_UniRange range;


      if ( script_class->script_uni_ranges == ((void *)0) )
        continue;





      if ( style_class->coverage == AF_COVERAGE_DEFAULT )
      {
        if ( (FT_UInt)style_class->script ==
             globals->module->default_script )
          dflt = ss;

        for ( range = script_class->script_uni_ranges;
              range->first != 0;
              range++ )
        {
          FT_ULong charcode = range->first;
          FT_UInt gindex;


          gindex = FT_Get_Char_Index( face, charcode );

          if ( gindex != 0 &&
               gindex < (FT_ULong)globals->glyph_count &&
               ( gstyles[gindex] & 0x3FFF ) == 0x3FFF )
            gstyles[gindex] = (FT_UShort)ss;

          for (;;)
          {
            charcode = FT_Get_Next_Char( face, charcode, &gindex );

            if ( gindex == 0 || charcode > range->last )
              break;

            if ( gindex < (FT_ULong)globals->glyph_count &&
                 ( gstyles[gindex] & 0x3FFF ) == 0x3FFF )
              gstyles[gindex] = (FT_UShort)ss;
          }
        }


        for ( range = script_class->script_uni_nonbase_ranges;
              range->first != 0;
              range++ )
        {
          FT_ULong charcode = range->first;
          FT_UInt gindex;


          gindex = FT_Get_Char_Index( face, charcode );

          if ( gindex != 0 &&
               gindex < (FT_ULong)globals->glyph_count &&
               ( gstyles[gindex] & 0x3FFF ) == (FT_UShort)ss )
            gstyles[gindex] |= 0x4000U;

          for (;;)
          {
            charcode = FT_Get_Next_Char( face, charcode, &gindex );

            if ( gindex == 0 || charcode > range->last )
              break;

            if ( gindex < (FT_ULong)globals->glyph_count &&
                 ( gstyles[gindex] & 0x3FFF ) == (FT_UShort)ss )
              gstyles[gindex] |= 0x4000U;
          }
        }
      }
      else
      {

        af_get_coverage( globals, style_class, gstyles );
      }
    }


    af_get_coverage( globals, af_style_classes[dflt], gstyles );


    for ( ss = 0; af_style_classes[ss]; ss++ )
    {
      AF_StyleClass style_class = af_style_classes[ss];


      if ( ss != dflt && style_class->coverage == AF_COVERAGE_DEFAULT )
        af_get_coverage( globals, style_class, gstyles );
    }


    for ( i = 0x30; i <= 0x39; i++ )
    {
      FT_UInt gindex = FT_Get_Char_Index( face, i );


      if ( gindex != 0 && gindex < (FT_ULong)globals->glyph_count )
        gstyles[gindex] |= 0x8000U;
    }

  Exit:




    if ( globals->module->fallback_style != 0x3FFF )
    {
      FT_Long nn;


      for ( nn = 0; nn < globals->glyph_count; nn++ )
      {
        if ( ( gstyles[nn] & 0x3FFF ) == 0x3FFF )
        {
          gstyles[nn] &= ~0x3FFF;
          gstyles[nn] |= globals->module->fallback_style;
        }
      }
    }
# 329 "../../../libs/freetype/src/autofit/afglobal.c"
    FT_Set_Charmap( face, old_charmap );
    return error;
  }


  static FT_Error
  af_face_globals_new( FT_Face face,
                       AF_FaceGlobals *aglobals,
                       AF_Module module )
  {
    FT_Error error;
    FT_Memory memory;
    AF_FaceGlobals globals = ((void *)0);


    memory = face->memory;



    if ( ( ((globals) = (ft_mem_alloc( memory, (FT_Long)(sizeof ( *globals ) + (FT_ULong)face->num_glyphs * sizeof ( FT_UShort )), &error ))), error != 0 )

                                                                         )
      goto Exit;

    globals->face = face;
    globals->glyph_count = face->num_glyphs;

    globals->glyph_styles = (FT_UShort*)( globals + 1 );
    globals->module = module;
    globals->stem_darkening_for_ppem = 0;
    globals->darken_x = 0;
    globals->darken_y = 0;
    globals->standard_vertical_width = 0;
    globals->standard_horizontal_width = 0;
    globals->scale_down_factor = 0;


    globals->hb_font = hb_ft_font_create( face, ((void *)0) );


    error = af_face_globals_compute_style_coverage( globals );
    if ( error )
    {
      af_face_globals_free( globals );
      globals = ((void *)0);
    }
    else
      globals->increase_x_height = 0;

  Exit:
    *aglobals = globals;
    return error;
  }


  static void
  af_face_globals_free( AF_FaceGlobals globals )
  {
    if ( globals )
    {
      FT_Memory memory = globals->face->memory;
      FT_UInt nn;


      for ( nn = 0; nn < AF_STYLE_MAX; nn++ )
      {
        if ( globals->metrics[nn] )
        {
          AF_StyleClass style_class =
            af_style_classes[nn];
          AF_WritingSystemClass writing_system_class =
            af_writing_system_classes[style_class->writing_system];


          if ( writing_system_class->style_metrics_done )
            writing_system_class->style_metrics_done( globals->metrics[nn] );

          do { ft_mem_free( memory, (globals->metrics[nn]) ); (globals->metrics[nn]) = ((void *)0); } while ( 0 );
        }
      }


      hb_font_destroy( globals->hb_font );
      globals->hb_font = ((void *)0);


      globals->glyph_count = 0;
      globals->stem_darkening_for_ppem = 0;
      globals->darken_x = 0;
      globals->darken_y = 0;
      globals->standard_vertical_width = 0;
      globals->standard_horizontal_width = 0;
      globals->scale_down_factor = 0;

      globals->glyph_styles = ((void *)0);
      globals->face = ((void *)0);

      do { ft_mem_free( memory, (globals) ); (globals) = ((void *)0); } while ( 0 );
    }
  }


  static FT_Error
  af_face_globals_get_metrics( AF_FaceGlobals globals,
                               FT_UInt gindex,
                               FT_UInt options,
                               AF_StyleMetrics *ametrics )
  {
    AF_StyleMetrics metrics = ((void *)0);

    AF_Style style = (AF_Style)options;
    AF_WritingSystemClass writing_system_class;
    AF_StyleClass style_class;

    FT_Error error = FT_Err_Ok;


    if ( gindex >= (FT_ULong)globals->glyph_count )
    {
      error = AF_Err_Invalid_Argument;
      goto Exit;
    }



    if ( style == AF_STYLE_NONE_DFLT || style + 1 >= AF_STYLE_MAX )
      style = (AF_Style)( globals->glyph_styles[gindex] &
                          0x3FFF );

    style_class = af_style_classes[style];
    writing_system_class = af_writing_system_classes
                             [style_class->writing_system];

    metrics = globals->metrics[style];
    if ( metrics == ((void *)0) )
    {

      FT_Memory memory = globals->face->memory;


      if ( ( ((metrics) = (ft_mem_alloc( memory, (FT_Long)(writing_system_class->style_metrics_size), &error ))), error != 0 ) )
        goto Exit;

      metrics->style_class = style_class;
      metrics->globals = globals;

      if ( writing_system_class->style_metrics_init )
      {
        error = writing_system_class->style_metrics_init( metrics,
                                                          globals->face );
        if ( error )
        {
          if ( writing_system_class->style_metrics_done )
            writing_system_class->style_metrics_done( metrics );

          do { ft_mem_free( memory, (metrics) ); (metrics) = ((void *)0); } while ( 0 );
          goto Exit;
        }
      }

      globals->metrics[style] = metrics;
    }

  Exit:
    *ametrics = metrics;

    return error;
  }


  static FT_Bool
  af_face_globals_is_digit( AF_FaceGlobals globals,
                            FT_UInt gindex )
  {
    if ( gindex < (FT_ULong)globals->glyph_count )
      return (FT_Bool)( globals->glyph_styles[gindex] & 0x8000U );

    return (FT_Bool)0;
  }
# 25 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afhints.c" 1
# 21 "../../../libs/freetype/src/autofit/afhints.c"
# 1 "../../../libs/freetype/include/freetype/internal/ftcalc.h" 1
# 27 "../../../libs/freetype/include/freetype/internal/ftcalc.h"

# 79 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  static __inline__ FT_Int32
  FT_MulFix_arm( FT_Int32 a,
                 FT_Int32 b )
  {
    FT_Int32 t, t2;


    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"
      "mov    %0, %2, asr #31\n\t"



      "add    %0, %0, #0x8000\n\t"

      "adds   %1, %1, %0\n\t"
      "adc    %2, %2, #0\n\t"
      "mov    %0, %1, lsr #16\n\t"
      "orr    %0, %0, %2, lsl #16\n\t"
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );
    return a;
  }
# 272 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Long
  FT_MulDiv_No_Round( FT_Long a,
                      FT_Long b,
                      FT_Long c );
# 286 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern void
  FT_Matrix_Multiply_Scaled( const FT_Matrix* a,
                             FT_Matrix *b,
                             FT_Long scaling );






  extern void
  FT_Vector_Transform_Scaled( FT_Vector* vector,
                              const FT_Matrix* matrix,
                              FT_Long scaling );
# 310 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_UInt32
  FT_Vector_NormLen( FT_Vector* vector );
# 320 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Int
  ft_corner_orientation( FT_Pos in_x,
                         FT_Pos in_y,
                         FT_Pos out_x,
                         FT_Pos out_y );







  extern FT_Int
  ft_corner_is_flat( FT_Pos in_x,
                     FT_Pos in_y,
                     FT_Pos out_x,
                     FT_Pos out_y );
# 372 "../../../libs/freetype/include/freetype/internal/ftcalc.h"
  extern FT_Fixed
  FT_Hypot( FT_Fixed x,
            FT_Fixed y );
# 413 "../../../libs/freetype/include/freetype/internal/ftcalc.h"

# 22 "../../../libs/freetype/src/autofit/afhints.c" 2
# 37 "../../../libs/freetype/src/autofit/afhints.c"
  static FT_Error
  af_axis_hints_new_segment( AF_AxisHints axis,
                             FT_Memory memory,
                             AF_Segment *asegment )
  {
    FT_Error error = FT_Err_Ok;
    AF_Segment segment = ((void *)0);


    if ( axis->num_segments < 18 )
    {
      if ( axis->segments == ((void *)0) )
      {
        axis->segments = axis->embedded.segments;
        axis->max_segments = 18;
      }
    }
    else if ( axis->num_segments >= axis->max_segments )
    {
      FT_Int old_max = axis->max_segments;
      FT_Int new_max = old_max;
      FT_Int big_max = (FT_Int)( 2147483647 / sizeof ( *segment ) );


      if ( old_max >= big_max )
      {
        error = AF_Err_Out_Of_Memory;
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( axis->segments == axis->embedded.segments )
      {
        if ( ( ((axis->segments) = (ft_mem_realloc( memory, sizeof ( *(axis->segments) ), 0, (FT_Long)(new_max), ((void *)0), &error ))), error != 0 ) )
          goto Exit;
        memcpy( axis->segments, axis->embedded.segments,
                   sizeof ( axis->embedded.segments ) );
      }
      else
      {
        if ( ( ((axis->segments) = (ft_mem_realloc( memory, sizeof ( *(axis->segments) ), (FT_Long)(old_max), (FT_Long)(new_max), (axis->segments), &error ))), error != 0 ) )
          goto Exit;
      }

      axis->max_segments = new_max;
    }

    segment = axis->segments + axis->num_segments++;

  Exit:
    *asegment = segment;
    return error;
  }





  static FT_Error
  af_axis_hints_new_edge( AF_AxisHints axis,
                          FT_Int fpos,
                          AF_Direction dir,
                          FT_Memory memory,
                          AF_Edge *anedge )
  {
    FT_Error error = FT_Err_Ok;
    AF_Edge edge = ((void *)0);
    AF_Edge edges;


    if ( axis->num_edges < 12 )
    {
      if ( axis->edges == ((void *)0) )
      {
        axis->edges = axis->embedded.edges;
        axis->max_edges = 12;
      }
    }
    else if ( axis->num_edges >= axis->max_edges )
    {
      FT_Int old_max = axis->max_edges;
      FT_Int new_max = old_max;
      FT_Int big_max = (FT_Int)( 2147483647 / sizeof ( *edge ) );


      if ( old_max >= big_max )
      {
        error = AF_Err_Out_Of_Memory;
        goto Exit;
      }

      new_max += ( new_max >> 2 ) + 4;
      if ( new_max < old_max || new_max > big_max )
        new_max = big_max;

      if ( axis->edges == axis->embedded.edges )
      {
        if ( ( ((axis->edges) = (ft_mem_realloc( memory, sizeof ( *(axis->edges) ), 0, (FT_Long)(new_max), ((void *)0), &error ))), error != 0 ) )
          goto Exit;
        memcpy( axis->edges, axis->embedded.edges,
                   sizeof ( axis->embedded.edges ) );
      }
      else
      {
        if ( ( ((axis->edges) = (ft_mem_realloc( memory, sizeof ( *(axis->edges) ), (FT_Long)(old_max), (FT_Long)(new_max), (axis->edges), &error ))), error != 0 ) )
          goto Exit;
      }

      axis->max_edges = new_max;
    }

    edges = axis->edges;
    edge = edges + axis->num_edges;

    while ( edge > edges )
    {
      if ( edge[-1].fpos < fpos )
        break;



      if ( edge[-1].fpos == fpos && dir == axis->major_dir )
        break;

      edge[0] = edge[-1];
      edge--;
    }

    axis->num_edges++;

  Exit:
    *anedge = edge;
    return error;
  }
# 578 "../../../libs/freetype/src/autofit/afhints.c"
  static AF_Direction
  af_direction_compute( FT_Pos dx,
                        FT_Pos dy )
  {
    FT_Pos ll, ss;
    AF_Direction dir;


    if ( dy >= dx )
    {
      if ( dy >= -dx )
      {
        dir = AF_DIR_UP;
        ll = dy;
        ss = dx;
      }
      else
      {
        dir = AF_DIR_LEFT;
        ll = -dx;
        ss = dy;
      }
    }
    else
    {
      if ( dy >= -dx )
      {
        dir = AF_DIR_RIGHT;
        ll = dx;
        ss = dy;
      }
      else
      {
        dir = AF_DIR_DOWN;
        ll = -dy;
        ss = dx;
      }
    }




    if ( ll <= 14 * ( (ss) < 0 ? -(ss) : (ss) ) )
      dir = AF_DIR_NONE;

    return dir;
  }


  static void
  af_glyph_hints_init( AF_GlyphHints hints,
                       FT_Memory memory )
  {

    memset( hints, 0, (FT_Offset)(sizeof ( *hints ) - sizeof ( hints->embedded )) );
    hints->memory = memory;
  }


  static void
  af_glyph_hints_done( AF_GlyphHints hints )
  {
    FT_Memory memory;
    int dim;


    if ( !( hints && hints->memory ) )
      return;

    memory = hints->memory;





    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
    {
      AF_AxisHints axis = &hints->axis[dim];


      axis->num_segments = 0;
      axis->max_segments = 0;
      if ( axis->segments != axis->embedded.segments )
        do { ft_mem_free( memory, (axis->segments) ); (axis->segments) = ((void *)0); } while ( 0 );

      axis->num_edges = 0;
      axis->max_edges = 0;
      if ( axis->edges != axis->embedded.edges )
        do { ft_mem_free( memory, (axis->edges) ); (axis->edges) = ((void *)0); } while ( 0 );
    }

    if ( hints->contours != hints->embedded.contours )
      do { ft_mem_free( memory, (hints->contours) ); (hints->contours) = ((void *)0); } while ( 0 );
    hints->max_contours = 0;
    hints->num_contours = 0;

    if ( hints->points != hints->embedded.points )
      do { ft_mem_free( memory, (hints->points) ); (hints->points) = ((void *)0); } while ( 0 );
    hints->max_points = 0;
    hints->num_points = 0;

    hints->memory = ((void *)0);
  }




  static void
  af_glyph_hints_rescale( AF_GlyphHints hints,
                          AF_StyleMetrics metrics )
  {
    hints->metrics = metrics;
    hints->scaler_flags = metrics->scaler.flags;
  }





  static FT_Error
  af_glyph_hints_reload( AF_GlyphHints hints,
                         FT_Outline* outline )
  {
    FT_Error error = FT_Err_Ok;
    AF_Point points;
    FT_UInt old_max, new_max;
    FT_Fixed x_scale = hints->x_scale;
    FT_Fixed y_scale = hints->y_scale;
    FT_Pos x_delta = hints->x_delta;
    FT_Pos y_delta = hints->y_delta;
    FT_Memory memory = hints->memory;


    hints->num_points = 0;
    hints->num_contours = 0;

    hints->axis[0].num_segments = 0;
    hints->axis[0].num_edges = 0;
    hints->axis[1].num_segments = 0;
    hints->axis[1].num_edges = 0;


    new_max = (FT_UInt)outline->n_contours;
    old_max = (FT_UInt)hints->max_contours;

    if ( new_max <= 8 )
    {
      if ( hints->contours == ((void *)0) )
      {
        hints->contours = hints->embedded.contours;
        hints->max_contours = 8;
      }
    }
    else if ( new_max > old_max )
    {
      if ( hints->contours == hints->embedded.contours )
        hints->contours = ((void *)0);

      new_max = ( new_max + 3 ) & ~3U;

      if ( ( ((hints->contours) = (ft_mem_realloc( memory, sizeof ( *(hints->contours) ), (FT_Long)(old_max), (FT_Long)(new_max), (hints->contours), &error ))), error != 0 ) )
        goto Exit;

      hints->max_contours = (FT_Int)new_max;
    }






    new_max = (FT_UInt)( outline->n_points + 2 );
    old_max = (FT_UInt)hints->max_points;

    if ( new_max <= 96 )
    {
      if ( hints->points == ((void *)0) )
      {
        hints->points = hints->embedded.points;
        hints->max_points = 96;
      }
    }
    else if ( new_max > old_max )
    {
      if ( hints->points == hints->embedded.points )
        hints->points = ((void *)0);

      new_max = ( new_max + 2 + 7 ) & ~7U;

      if ( ( ((hints->points) = (ft_mem_realloc( memory, sizeof ( *(hints->points) ), (FT_Long)(old_max), (FT_Long)(new_max), (hints->points), &error ))), error != 0 ) )
        goto Exit;

      hints->max_points = (FT_Int)new_max;
    }

    hints->num_points = outline->n_points;
    hints->num_contours = outline->n_contours;





    hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;
    hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;

    if ( FT_Outline_Get_Orientation( outline ) == FT_ORIENTATION_POSTSCRIPT )
    {
      hints->axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;
      hints->axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;
    }

    hints->x_scale = x_scale;
    hints->y_scale = y_scale;
    hints->x_delta = x_delta;
    hints->y_delta = y_delta;

    hints->xmin_delta = 0;
    hints->xmax_delta = 0;

    points = hints->points;
    if ( hints->num_points == 0 )
      goto Exit;

    {
      AF_Point point;
      AF_Point point_limit = points + hints->num_points;



      {
        FT_Vector* vec = outline->points;
        char* tag = outline->tags;
        AF_Point end = points + outline->contours[0];
        AF_Point prev = end;
        FT_Int contour_index = 0;


        for ( point = points; point < point_limit; point++, vec++, tag++ )
        {
          point->in_dir = (FT_Char)AF_DIR_NONE;
          point->out_dir = (FT_Char)AF_DIR_NONE;

          point->fx = (FT_Short)vec->x;
          point->fy = (FT_Short)vec->y;
          point->ox = point->x = FT_MulFix_arm( (FT_Int32)(vec->x), (FT_Int32)(x_scale) ) + x_delta;
          point->oy = point->y = FT_MulFix_arm( (FT_Int32)(vec->y), (FT_Int32)(y_scale) ) + y_delta;

          switch ( ( *tag & 3 ) )
          {
          case 0:
            point->flags = ( 1U << 0 );
            break;
          case 2:
            point->flags = ( 1U << 1 );
            break;
          default:
            point->flags = 0;
          }

          point->prev = prev;
          prev->next = point;
          prev = point;

          if ( point == end )
          {
            if ( ++contour_index < outline->n_contours )
            {
              end = points + outline->contours[contour_index];
              prev = end;
            }
          }
        }
      }


      {
        AF_Point* contour = hints->contours;
        AF_Point* contour_limit = contour + hints->num_contours;
        short* end = outline->contours;
        short idx = 0;


        for ( ; contour < contour_limit; contour++, end++ )
        {
          contour[0] = points + idx;
          idx = (short)( end[0] + 1 );
        }
      }

      {
# 880 "../../../libs/freetype/src/autofit/afhints.c"
        FT_UInt units_per_em = hints->metrics->scaler.face->units_per_EM;
        FT_Int near_limit = 20 * units_per_em / 2048;
        FT_Int near_limit2 = 2 * near_limit - 1;

        AF_Point* contour;
        AF_Point* contour_limit = hints->contours + hints->num_contours;


        for ( contour = hints->contours; contour < contour_limit; contour++ )
        {
          AF_Point first = *contour;
          AF_Point next, prev, curr;

          FT_Pos out_x, out_y;






          point = first;
          prev = first->prev;

          while ( prev != first )
          {
            out_x = point->fx - prev->fx;
            out_y = point->fy - prev->fy;
# 916 "../../../libs/freetype/src/autofit/afhints.c"
            if ( ( (out_x) < 0 ? -(out_x) : (out_x) ) + ( (out_y) < 0 ? -(out_y) : (out_y) ) >= near_limit2 )
              break;

            point = prev;
            prev = prev->prev;
          }


          first = point;




          curr = first;
# 939 "../../../libs/freetype/src/autofit/afhints.c"
          curr->u = (FT_Pos)( first - curr );
          first->v = -curr->u;

          out_x = 0;
          out_y = 0;

          next = first;
          do
          {
            AF_Direction out_dir;


            point = next;
            next = point->next;

            out_x += next->fx - point->fx;
            out_y += next->fy - point->fy;

            if ( ( (out_x) < 0 ? -(out_x) : (out_x) ) + ( (out_y) < 0 ? -(out_y) : (out_y) ) < near_limit )
            {
              next->flags |= ( 1U << 4 );
              continue;
            }

            curr->u = (FT_Pos)( next - curr );
            next->v = -curr->u;

            out_dir = af_direction_compute( out_x, out_y );



            curr->out_dir = (FT_Char)out_dir;
            for ( curr = curr->next; curr != next; curr = curr->next )
            {
              curr->in_dir = (FT_Char)out_dir;
              curr->out_dir = (FT_Char)out_dir;
            }
            next->in_dir = (FT_Char)out_dir;

            curr->u = (FT_Pos)( first - curr );
            first->v = -curr->u;

            out_x = 0;
            out_y = 0;

          } while ( next != first );
        }
# 996 "../../../libs/freetype/src/autofit/afhints.c"
        for ( point = points; point < point_limit; point++ )
        {
          if ( point->flags & ( 1U << 4 ) )
            continue;

          if ( point->in_dir == AF_DIR_NONE &&
               point->out_dir == AF_DIR_NONE )
          {


            FT_Pos in_x, in_y;
            FT_Pos out_x, out_y;

            AF_Point next_u = point + point->u;
            AF_Point prev_v = point + point->v;


            in_x = point->fx - prev_v->fx;
            in_y = point->fy - prev_v->fy;

            out_x = next_u->fx - point->fx;
            out_y = next_u->fy - point->fy;

            if ( ( in_x ^ out_x ) >= 0 && ( in_y ^ out_y ) >= 0 )
            {



              point->flags |= ( 1U << 4 );

              prev_v->u = (FT_Pos)( next_u - prev_v );
              next_u->v = -prev_v->u;
            }
          }
        }







        for ( point = points; point < point_limit; point++ )
        {
          if ( point->flags & ( 1U << 4 ) )
            continue;

          if ( point->flags & ( ( 1U << 0 ) | ( 1U << 1 ) ) )
          {

          Is_Weak_Point:
            point->flags |= ( 1U << 4 );
          }
          else if ( point->out_dir == point->in_dir )
          {
            if ( point->out_dir != AF_DIR_NONE )
            {


              goto Is_Weak_Point;
            }

            {
              AF_Point next_u = point + point->u;
              AF_Point prev_v = point + point->v;


              if ( ft_corner_is_flat( point->fx - prev_v->fx,
                                      point->fy - prev_v->fy,
                                      next_u->fx - point->fx,
                                      next_u->fy - point->fy ) )
              {




                prev_v->u = (FT_Pos)( next_u - prev_v );
                next_u->v = -prev_v->u;

                goto Is_Weak_Point;
              }
            }
          }
          else if ( point->in_dir == -point->out_dir )
          {

            goto Is_Weak_Point;
          }
        }
      }
    }

  Exit:
    return error;
  }




  static void
  af_glyph_hints_save( AF_GlyphHints hints,
                       FT_Outline* outline )
  {
    AF_Point point = hints->points;
    AF_Point limit = point + hints->num_points;
    FT_Vector* vec = outline->points;
    char* tag = outline->tags;


    for ( ; point < limit; point++, vec++, tag++ )
    {
      vec->x = point->x;
      vec->y = point->y;

      if ( point->flags & ( 1U << 0 ) )
        tag[0] = 0;
      else if ( point->flags & ( 1U << 1 ) )
        tag[0] = 2;
      else
        tag[0] = 1;
    }
  }
# 1130 "../../../libs/freetype/src/autofit/afhints.c"
  static void
  af_glyph_hints_align_edge_points( AF_GlyphHints hints,
                                    AF_Dimension dim )
  {
    AF_AxisHints axis = & hints->axis[dim];
    AF_Segment segments = axis->segments;
    AF_Segment segment_limit = segments + axis->num_segments;
    AF_Segment seg;


    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( seg = segments; seg < segment_limit; seg++ )
      {
        AF_Edge edge = seg->edge;
        AF_Point point, first, last;


        if ( edge == ((void *)0) )
          continue;

        first = seg->first;
        last = seg->last;
        point = first;
        for (;;)
        {
          point->x = edge->pos;
          point->flags |= ( 1U << 2 );

          if ( point == last )
            break;

          point = point->next;
        }
      }
    }
    else
    {
      for ( seg = segments; seg < segment_limit; seg++ )
      {
        AF_Edge edge = seg->edge;
        AF_Point point, first, last;


        if ( edge == ((void *)0) )
          continue;

        first = seg->first;
        last = seg->last;
        point = first;
        for (;;)
        {
          point->y = edge->pos;
          point->flags |= ( 1U << 3 );

          if ( point == last )
            break;

          point = point->next;
        }
      }
    }
  }
# 1205 "../../../libs/freetype/src/autofit/afhints.c"
  static void
  af_glyph_hints_align_strong_points( AF_GlyphHints hints,
                                      AF_Dimension dim )
  {
    AF_Point points = hints->points;
    AF_Point point_limit = points + hints->num_points;
    AF_AxisHints axis = &hints->axis[dim];
    AF_Edge edges = axis->edges;
    AF_Edge edge_limit = edges + axis->num_edges;
    FT_UInt touch_flag;


    if ( dim == AF_DIMENSION_HORZ )
      touch_flag = ( 1U << 2 );
    else
      touch_flag = ( 1U << 3 );

    if ( edges < edge_limit )
    {
      AF_Point point;
      AF_Edge edge;


      for ( point = points; point < point_limit; point++ )
      {
        FT_Pos u, ou, fu;
        FT_Pos delta;


        if ( point->flags & touch_flag )
          continue;




        if ( ( point->flags & ( 1U << 4 ) ) )
          continue;

        if ( dim == AF_DIMENSION_VERT )
        {
          u = point->fy;
          ou = point->oy;
        }
        else
        {
          u = point->fx;
          ou = point->ox;
        }

        fu = u;


        edge = edges;
        delta = edge->fpos - u;
        if ( delta >= 0 )
        {
          u = edge->pos - ( edge->opos - ou );
          goto Store_Point;
        }


        edge = edge_limit - 1;
        delta = u - edge->fpos;
        if ( delta >= 0 )
        {
          u = edge->pos + ( ou - edge->opos );
          goto Store_Point;
        }

        {
          FT_PtrDist min, max, mid;
          FT_Pos fpos;



          min = 0;
          max = edge_limit - edges;



          if ( max <= 8 )
          {
            FT_PtrDist nn;


            for ( nn = 0; nn < max; nn++ )
              if ( edges[nn].fpos >= u )
                break;

            if ( edges[nn].fpos == u )
            {
              u = edges[nn].pos;
              goto Store_Point;
            }
            min = nn;
          }
          else

          while ( min < max )
          {
            mid = ( max + min ) >> 1;
            edge = edges + mid;
            fpos = edge->fpos;

            if ( u < fpos )
              max = mid;
            else if ( u > fpos )
              min = mid + 1;
            else
            {

              u = edge->pos;
              goto Store_Point;
            }
          }


          {
            AF_Edge before = edges + min - 1;
            AF_Edge after = edges + min + 0;



            if ( before->scale == 0 )
              before->scale = FT_DivFix( after->pos - before->pos,
                                         after->fpos - before->fpos );

            u = before->pos + FT_MulFix_arm( (FT_Int32)(fu - before->fpos), (FT_Int32)(before->scale) )
                                                        ;
          }
        }

      Store_Point:

        if ( dim == AF_DIMENSION_HORZ )
          point->x = u;
        else
          point->y = u;

        point->flags |= touch_flag;
      }
    }
  }
# 1361 "../../../libs/freetype/src/autofit/afhints.c"
  static void
  af_iup_shift( AF_Point p1,
                AF_Point p2,
                AF_Point ref )
  {
    AF_Point p;
    FT_Pos delta = ref->u - ref->v;


    if ( delta == 0 )
      return;

    for ( p = p1; p < ref; p++ )
      p->u = p->v + delta;

    for ( p = ref + 1; p <= p2; p++ )
      p->u = p->v + delta;
  }
# 1388 "../../../libs/freetype/src/autofit/afhints.c"
  static void
  af_iup_interp( AF_Point p1,
                 AF_Point p2,
                 AF_Point ref1,
                 AF_Point ref2 )
  {
    AF_Point p;
    FT_Pos u, v1, v2, u1, u2, d1, d2;


    if ( p1 > p2 )
      return;

    if ( ref1->v > ref2->v )
    {
      p = ref1;
      ref1 = ref2;
      ref2 = p;
    }

    v1 = ref1->v;
    v2 = ref2->v;
    u1 = ref1->u;
    u2 = ref2->u;
    d1 = u1 - v1;
    d2 = u2 - v2;

    if ( u1 == u2 || v1 == v2 )
    {
      for ( p = p1; p <= p2; p++ )
      {
        u = p->v;

        if ( u <= v1 )
          u += d1;
        else if ( u >= v2 )
          u += d2;
        else
          u = u1;

        p->u = u;
      }
    }
    else
    {
      FT_Fixed scale = FT_DivFix( u2 - u1, v2 - v1 );


      for ( p = p1; p <= p2; p++ )
      {
        u = p->v;

        if ( u <= v1 )
          u += d1;
        else if ( u >= v2 )
          u += d2;
        else
          u = u1 + FT_MulFix_arm( (FT_Int32)(u - v1), (FT_Int32)(scale) );

        p->u = u;
      }
    }
  }





  static void
  af_glyph_hints_align_weak_points( AF_GlyphHints hints,
                                    AF_Dimension dim )
  {
    AF_Point points = hints->points;
    AF_Point point_limit = points + hints->num_points;
    AF_Point* contour = hints->contours;
    AF_Point* contour_limit = contour + hints->num_contours;
    FT_UInt touch_flag;
    AF_Point point;
    AF_Point end_point;
    AF_Point first_point;




    if ( dim == AF_DIMENSION_HORZ )
    {
      touch_flag = ( 1U << 2 );

      for ( point = points; point < point_limit; point++ )
      {
        point->u = point->x;
        point->v = point->ox;
      }
    }
    else
    {
      touch_flag = ( 1U << 3 );

      for ( point = points; point < point_limit; point++ )
      {
        point->u = point->y;
        point->v = point->oy;
      }
    }

    for ( ; contour < contour_limit; contour++ )
    {
      AF_Point first_touched, last_touched;


      point = *contour;
      end_point = point->prev;
      first_point = point;


      for (;;)
      {
        if ( point > end_point )
          goto NextContour;

        if ( point->flags & touch_flag )
          break;

        point++;
      }

      first_touched = point;

      for (;;)
      {
        do { } while ( 0 )
                                                       ;


        while ( point < end_point &&
                ( point[1].flags & touch_flag ) != 0 )
          point++;

        last_touched = point;


        point++;
        for (;;)
        {
          if ( point > end_point )
            goto EndContour;

          if ( ( point->flags & touch_flag ) != 0 )
            break;

          point++;
        }


        af_iup_interp( last_touched + 1, point - 1,
                       last_touched, point );
      }

    EndContour:

      if ( last_touched == first_touched )
        af_iup_shift( first_point, end_point, first_touched );

      else
      {
        if ( last_touched < end_point )
          af_iup_interp( last_touched + 1, end_point,
                         last_touched, first_touched );

        if ( first_touched > points )
          af_iup_interp( first_point, first_touched - 1,
                         last_touched, first_touched );
      }

    NextContour:
      ;
    }


    if ( dim == AF_DIMENSION_HORZ )
    {
      for ( point = points; point < point_limit; point++ )
        point->x = point->u;
    }
    else
    {
      for ( point = points; point < point_limit; point++ )
        point->y = point->u;
    }
  }
# 26 "../../../libs/freetype/src/autofit/autofit.c" 2

# 1 "../../../libs/freetype/src/autofit/afranges.c" 1
# 59 "../../../libs/freetype/src/autofit/afranges.c"
  const AF_Script_UniRangeRec af_arab_uniranges[] =
  {
    { (FT_UInt32)(0x0600UL), (FT_UInt32)(0x06FFUL) },
    { (FT_UInt32)(0x0750UL), (FT_UInt32)(0x07FFUL) },
    { (FT_UInt32)(0x08A0UL), (FT_UInt32)(0x08FFUL) },
    { (FT_UInt32)(0xFB50UL), (FT_UInt32)(0xFDFFUL) },
    { (FT_UInt32)(0xFE70UL), (FT_UInt32)(0xFEFFUL) },
    { (FT_UInt32)(0x1EE00UL), (FT_UInt32)(0x1EEFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_arab_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0600UL), (FT_UInt32)(0x0605UL) },
    { (FT_UInt32)(0x0610UL), (FT_UInt32)(0x061AUL) },
    { (FT_UInt32)(0x064BUL), (FT_UInt32)(0x065FUL) },
    { (FT_UInt32)(0x0670UL), (FT_UInt32)(0x0670UL) },
    { (FT_UInt32)(0x06D6UL), (FT_UInt32)(0x06DCUL) },
    { (FT_UInt32)(0x06DFUL), (FT_UInt32)(0x06E4UL) },
    { (FT_UInt32)(0x06E7UL), (FT_UInt32)(0x06E8UL) },
    { (FT_UInt32)(0x06EAUL), (FT_UInt32)(0x06EDUL) },
    { (FT_UInt32)(0x08E3UL), (FT_UInt32)(0x08FFUL) },
    { (FT_UInt32)(0xFBB2UL), (FT_UInt32)(0xFBC1UL) },
    { (FT_UInt32)(0xFE70UL), (FT_UInt32)(0xFE70UL) },
    { (FT_UInt32)(0xFE72UL), (FT_UInt32)(0xFE72UL) },
    { (FT_UInt32)(0xFE74UL), (FT_UInt32)(0xFE74UL) },
    { (FT_UInt32)(0xFE76UL), (FT_UInt32)(0xFE76UL) },
    { (FT_UInt32)(0xFE78UL), (FT_UInt32)(0xFE78UL) },
    { (FT_UInt32)(0xFE7AUL), (FT_UInt32)(0xFE7AUL) },
    { (FT_UInt32)(0xFE7CUL), (FT_UInt32)(0xFE7CUL) },
    { (FT_UInt32)(0xFE7EUL), (FT_UInt32)(0xFE7EUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_cyrl_uniranges[] =
  {
    { (FT_UInt32)(0x0400UL), (FT_UInt32)(0x04FFUL) },
    { (FT_UInt32)(0x0500UL), (FT_UInt32)(0x052FUL) },
    { (FT_UInt32)(0x2DE0UL), (FT_UInt32)(0x2DFFUL) },
    { (FT_UInt32)(0xA640UL), (FT_UInt32)(0xA69FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_cyrl_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0483UL), (FT_UInt32)(0x0489UL) },
    { (FT_UInt32)(0x2DE0UL), (FT_UInt32)(0x2DFFUL) },
    { (FT_UInt32)(0xA66FUL), (FT_UInt32)(0xA67FUL) },
    { (FT_UInt32)(0xA69EUL), (FT_UInt32)(0xA69FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };






  const AF_Script_UniRangeRec af_deva_uniranges[] =
  {
    { (FT_UInt32)(0x0900UL), (FT_UInt32)(0x093BUL) },

    { (FT_UInt32)(0x093DUL), (FT_UInt32)(0x0950UL) },

    { (FT_UInt32)(0x0953UL), (FT_UInt32)(0x0963UL) },

    { (FT_UInt32)(0x0966UL), (FT_UInt32)(0x097FUL) },
    { (FT_UInt32)(0x20B9UL), (FT_UInt32)(0x20B9UL) },
    { (FT_UInt32)(0xA8E0UL), (FT_UInt32)(0xA8FFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_deva_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0900UL), (FT_UInt32)(0x0902UL) },
    { (FT_UInt32)(0x093AUL), (FT_UInt32)(0x093AUL) },
    { (FT_UInt32)(0x0941UL), (FT_UInt32)(0x0948UL) },
    { (FT_UInt32)(0x094DUL), (FT_UInt32)(0x094DUL) },
    { (FT_UInt32)(0x0953UL), (FT_UInt32)(0x0957UL) },
    { (FT_UInt32)(0x0962UL), (FT_UInt32)(0x0963UL) },
    { (FT_UInt32)(0xA8E0UL), (FT_UInt32)(0xA8F1UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_grek_uniranges[] =
  {
    { (FT_UInt32)(0x0370UL), (FT_UInt32)(0x03FFUL) },
    { (FT_UInt32)(0x1F00UL), (FT_UInt32)(0x1FFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_grek_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x037AUL), (FT_UInt32)(0x037AUL) },
    { (FT_UInt32)(0x0384UL), (FT_UInt32)(0x0385UL) },
    { (FT_UInt32)(0x1FBDUL), (FT_UInt32)(0x1FC1UL) },
    { (FT_UInt32)(0x1FCDUL), (FT_UInt32)(0x1FCFUL) },
    { (FT_UInt32)(0x1FDDUL), (FT_UInt32)(0x1FDFUL) },
    { (FT_UInt32)(0x1FEDUL), (FT_UInt32)(0x1FEFUL) },
    { (FT_UInt32)(0x1FFDUL), (FT_UInt32)(0x1FFEUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_hebr_uniranges[] =
  {
    { (FT_UInt32)(0x0590UL), (FT_UInt32)(0x05FFUL) },
    { (FT_UInt32)(0xFB1DUL), (FT_UInt32)(0xFB4FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_hebr_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0591UL), (FT_UInt32)(0x05BFUL) },
    { (FT_UInt32)(0x05C1UL), (FT_UInt32)(0x05C2UL) },
    { (FT_UInt32)(0x05C4UL), (FT_UInt32)(0x05C5UL) },
    { (FT_UInt32)(0x05C7UL), (FT_UInt32)(0x05C7UL) },
    { (FT_UInt32)(0xFB1EUL), (FT_UInt32)(0xFB1EUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_lao_uniranges[] =
  {
    { (FT_UInt32)(0x0E80UL), (FT_UInt32)(0x0EFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_lao_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0EB1UL), (FT_UInt32)(0x0EB1UL) },
    { (FT_UInt32)(0x0EB4UL), (FT_UInt32)(0x0EBCUL) },
    { (FT_UInt32)(0x0EC8UL), (FT_UInt32)(0x0ECDUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_latn_uniranges[] =
  {
    { (FT_UInt32)(0x0020UL), (FT_UInt32)(0x007FUL) },
    { (FT_UInt32)(0x00A0UL), (FT_UInt32)(0x00A9UL) },
    { (FT_UInt32)(0x00ABUL), (FT_UInt32)(0x00B1UL) },
    { (FT_UInt32)(0x00B4UL), (FT_UInt32)(0x00B8UL) },
    { (FT_UInt32)(0x00BBUL), (FT_UInt32)(0x00FFUL) },
    { (FT_UInt32)(0x0100UL), (FT_UInt32)(0x017FUL) },
    { (FT_UInt32)(0x0180UL), (FT_UInt32)(0x024FUL) },
    { (FT_UInt32)(0x0250UL), (FT_UInt32)(0x02AFUL) },
    { (FT_UInt32)(0x02B9UL), (FT_UInt32)(0x02DFUL) },
    { (FT_UInt32)(0x02E5UL), (FT_UInt32)(0x02FFUL) },
    { (FT_UInt32)(0x0300UL), (FT_UInt32)(0x036FUL) },
    { (FT_UInt32)(0x1AB0UL), (FT_UInt32)(0x1ABEUL) },
    { (FT_UInt32)(0x1D00UL), (FT_UInt32)(0x1D2BUL) },
    { (FT_UInt32)(0x1D6BUL), (FT_UInt32)(0x1D77UL) },
    { (FT_UInt32)(0x1D79UL), (FT_UInt32)(0x1D7FUL) },
    { (FT_UInt32)(0x1D80UL), (FT_UInt32)(0x1D9AUL) },
    { (FT_UInt32)(0x1DC0UL), (FT_UInt32)(0x1DFFUL) },
    { (FT_UInt32)(0x1E00UL), (FT_UInt32)(0x1EFFUL) },
    { (FT_UInt32)(0x2000UL), (FT_UInt32)(0x206FUL) },
    { (FT_UInt32)(0x20A0UL), (FT_UInt32)(0x20B8UL) },
    { (FT_UInt32)(0x20BAUL), (FT_UInt32)(0x20CFUL) },
    { (FT_UInt32)(0x2150UL), (FT_UInt32)(0x218FUL) },
    { (FT_UInt32)(0x2C60UL), (FT_UInt32)(0x2C7BUL) },
    { (FT_UInt32)(0x2C7EUL), (FT_UInt32)(0x2C7FUL) },
    { (FT_UInt32)(0x2E00UL), (FT_UInt32)(0x2E7FUL) },
    { (FT_UInt32)(0xA720UL), (FT_UInt32)(0xA76FUL) },
    { (FT_UInt32)(0xA771UL), (FT_UInt32)(0xA7F7UL) },
    { (FT_UInt32)(0xA7FAUL), (FT_UInt32)(0xA7FFUL) },
    { (FT_UInt32)(0xAB30UL), (FT_UInt32)(0xAB5BUL) },
    { (FT_UInt32)(0xAB60UL), (FT_UInt32)(0xAB6FUL) },
    { (FT_UInt32)(0xFB00UL), (FT_UInt32)(0xFB06UL) },
    { (FT_UInt32)(0x1D400UL), (FT_UInt32)(0x1D7FFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_latn_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x005EUL), (FT_UInt32)(0x0060UL) },
    { (FT_UInt32)(0x007EUL), (FT_UInt32)(0x007EUL) },
    { (FT_UInt32)(0x00A8UL), (FT_UInt32)(0x00A9UL) },
    { (FT_UInt32)(0x00AEUL), (FT_UInt32)(0x00B0UL) },
    { (FT_UInt32)(0x00B4UL), (FT_UInt32)(0x00B4UL) },
    { (FT_UInt32)(0x00B8UL), (FT_UInt32)(0x00B8UL) },
    { (FT_UInt32)(0x00BCUL), (FT_UInt32)(0x00BEUL) },
    { (FT_UInt32)(0x02B9UL), (FT_UInt32)(0x02DFUL) },
    { (FT_UInt32)(0x02E5UL), (FT_UInt32)(0x02FFUL) },
    { (FT_UInt32)(0x0300UL), (FT_UInt32)(0x036FUL) },
    { (FT_UInt32)(0x1AB0UL), (FT_UInt32)(0x1ABEUL) },
    { (FT_UInt32)(0x1DC0UL), (FT_UInt32)(0x1DFFUL) },
    { (FT_UInt32)(0x2017UL), (FT_UInt32)(0x2017UL) },
    { (FT_UInt32)(0x203EUL), (FT_UInt32)(0x203EUL) },
    { (FT_UInt32)(0xA788UL), (FT_UInt32)(0xA788UL) },
    { (FT_UInt32)(0xA7F8UL), (FT_UInt32)(0xA7FAUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_latb_uniranges[] =
  {
    { (FT_UInt32)(0x1D62UL), (FT_UInt32)(0x1D6AUL) },
    { (FT_UInt32)(0x2080UL), (FT_UInt32)(0x209CUL) },
    { (FT_UInt32)(0x2C7CUL), (FT_UInt32)(0x2C7CUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_latb_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_latp_uniranges[] =
  {
    { (FT_UInt32)(0x00AAUL), (FT_UInt32)(0x00AAUL) },
    { (FT_UInt32)(0x00B2UL), (FT_UInt32)(0x00B3UL) },
    { (FT_UInt32)(0x00B9UL), (FT_UInt32)(0x00BAUL) },
    { (FT_UInt32)(0x02B0UL), (FT_UInt32)(0x02B8UL) },
    { (FT_UInt32)(0x02E0UL), (FT_UInt32)(0x02E4UL) },
    { (FT_UInt32)(0x1D2CUL), (FT_UInt32)(0x1D61UL) },
    { (FT_UInt32)(0x1D78UL), (FT_UInt32)(0x1D78UL) },
    { (FT_UInt32)(0x1D9BUL), (FT_UInt32)(0x1DBFUL) },
    { (FT_UInt32)(0x2070UL), (FT_UInt32)(0x207FUL) },
    { (FT_UInt32)(0x2C7DUL), (FT_UInt32)(0x2C7DUL) },
    { (FT_UInt32)(0xA770UL), (FT_UInt32)(0xA770UL) },
    { (FT_UInt32)(0xA7F8UL), (FT_UInt32)(0xA7F9UL) },
    { (FT_UInt32)(0xAB5CUL), (FT_UInt32)(0xAB5FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_latp_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_none_uniranges[] =
  {
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_none_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_telu_uniranges[] =
  {
    { (FT_UInt32)(0x0C00UL), (FT_UInt32)(0x0C7FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_telu_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0C00UL), (FT_UInt32)(0x0C00UL) },
    { (FT_UInt32)(0x0C3EUL), (FT_UInt32)(0x0C40UL) },
    { (FT_UInt32)(0x0C46UL), (FT_UInt32)(0x0C56UL) },
    { (FT_UInt32)(0x0C62UL), (FT_UInt32)(0x0C63UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_thai_uniranges[] =
  {
    { (FT_UInt32)(0x0E00UL), (FT_UInt32)(0x0E7FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_thai_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0E31UL), (FT_UInt32)(0x0E31UL) },
    { (FT_UInt32)(0x0E34UL), (FT_UInt32)(0x0E3AUL) },
    { (FT_UInt32)(0x0E47UL), (FT_UInt32)(0x0E4EUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };




  const AF_Script_UniRangeRec af_beng_uniranges[] =
  {
    { (FT_UInt32)(0x0980UL), (FT_UInt32)(0x09FFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_beng_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0981UL), (FT_UInt32)(0x0981UL) },
    { (FT_UInt32)(0x09BCUL), (FT_UInt32)(0x09BCUL) },
    { (FT_UInt32)(0x09C1UL), (FT_UInt32)(0x09C4UL) },
    { (FT_UInt32)(0x09CDUL), (FT_UInt32)(0x09CDUL) },
    { (FT_UInt32)(0x09E2UL), (FT_UInt32)(0x09E3UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_gujr_uniranges[] =
  {
    { (FT_UInt32)(0x0A80UL), (FT_UInt32)(0x0AFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_gujr_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0A81UL), (FT_UInt32)(0x0A82UL) },
    { (FT_UInt32)(0x0ABCUL), (FT_UInt32)(0x0ABCUL) },
    { (FT_UInt32)(0x0AC1UL), (FT_UInt32)(0x0AC8UL) },
    { (FT_UInt32)(0x0ACDUL), (FT_UInt32)(0x0ACDUL) },
    { (FT_UInt32)(0x0AE2UL), (FT_UInt32)(0x0AE3UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_guru_uniranges[] =
  {
    { (FT_UInt32)(0x0A00UL), (FT_UInt32)(0x0A7FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_guru_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0A01UL), (FT_UInt32)(0x0A02UL) },
    { (FT_UInt32)(0x0A3CUL), (FT_UInt32)(0x0A3EUL) },
    { (FT_UInt32)(0x0A41UL), (FT_UInt32)(0x0A51UL) },
    { (FT_UInt32)(0x0A70UL), (FT_UInt32)(0x0A71UL) },
    { (FT_UInt32)(0x0A75UL), (FT_UInt32)(0x0A75UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_knda_uniranges[] =
  {
    { (FT_UInt32)(0x0C80UL), (FT_UInt32)(0x0CFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_knda_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0C81UL), (FT_UInt32)(0x0C81UL) },
    { (FT_UInt32)(0x0CBCUL), (FT_UInt32)(0x0CBCUL) },
    { (FT_UInt32)(0x0CBFUL), (FT_UInt32)(0x0CBFUL) },
    { (FT_UInt32)(0x0CC6UL), (FT_UInt32)(0x0CC6UL) },
    { (FT_UInt32)(0x0CCCUL), (FT_UInt32)(0x0CCDUL) },
    { (FT_UInt32)(0x0CE2UL), (FT_UInt32)(0x0CE3UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_limb_uniranges[] =
  {
    { (FT_UInt32)(0x1900UL), (FT_UInt32)(0x194FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_limb_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x1920UL), (FT_UInt32)(0x1922UL) },
    { (FT_UInt32)(0x1927UL), (FT_UInt32)(0x1934UL) },
    { (FT_UInt32)(0x1937UL), (FT_UInt32)(0x193BUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_mlym_uniranges[] =
  {
    { (FT_UInt32)(0x0D00UL), (FT_UInt32)(0x0D7FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_mlym_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0D01UL), (FT_UInt32)(0x0D01UL) },
    { (FT_UInt32)(0x0D4DUL), (FT_UInt32)(0x0D4EUL) },
    { (FT_UInt32)(0x0D62UL), (FT_UInt32)(0x0D63UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_orya_uniranges[] =
  {
    { (FT_UInt32)(0x0B00UL), (FT_UInt32)(0x0B7FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_orya_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0B01UL), (FT_UInt32)(0x0B02UL) },
    { (FT_UInt32)(0x0B3CUL), (FT_UInt32)(0x0B3CUL) },
    { (FT_UInt32)(0x0B3FUL), (FT_UInt32)(0x0B3FUL) },
    { (FT_UInt32)(0x0B41UL), (FT_UInt32)(0x0B44UL) },
    { (FT_UInt32)(0x0B4DUL), (FT_UInt32)(0x0B56UL) },
    { (FT_UInt32)(0x0B62UL), (FT_UInt32)(0x0B63UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_sinh_uniranges[] =
  {
    { (FT_UInt32)(0x0D80UL), (FT_UInt32)(0x0DFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_sinh_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0DCAUL), (FT_UInt32)(0x0DCAUL) },
    { (FT_UInt32)(0x0DD2UL), (FT_UInt32)(0x0DD6UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_sund_uniranges[] =
  {
    { (FT_UInt32)(0x1B80UL), (FT_UInt32)(0x1BBFUL) },
    { (FT_UInt32)(0x1CC0UL), (FT_UInt32)(0x1CCFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_sund_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x1B80UL), (FT_UInt32)(0x1B82UL) },
    { (FT_UInt32)(0x1BA1UL), (FT_UInt32)(0x1BADUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_sylo_uniranges[] =
  {
    { (FT_UInt32)(0xA800UL), (FT_UInt32)(0xA82FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_sylo_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0xA802UL), (FT_UInt32)(0xA802UL) },
    { (FT_UInt32)(0xA806UL), (FT_UInt32)(0xA806UL) },
    { (FT_UInt32)(0xA80BUL), (FT_UInt32)(0xA80BUL) },
    { (FT_UInt32)(0xA825UL), (FT_UInt32)(0xA826UL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_taml_uniranges[] =
  {
    { (FT_UInt32)(0x0B80UL), (FT_UInt32)(0x0BFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_taml_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0B82UL), (FT_UInt32)(0x0B82UL) },
    { (FT_UInt32)(0x0BC0UL), (FT_UInt32)(0x0BC2UL) },
    { (FT_UInt32)(0x0BCDUL), (FT_UInt32)(0x0BCDUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };


  const AF_Script_UniRangeRec af_tibt_uniranges[] =
  {
    { (FT_UInt32)(0x0F00UL), (FT_UInt32)(0x0FFFUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_tibt_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x0F18UL), (FT_UInt32)(0x0F19UL) },
    { (FT_UInt32)(0x0F35UL), (FT_UInt32)(0x0F35UL) },
    { (FT_UInt32)(0x0F37UL), (FT_UInt32)(0x0F37UL) },
    { (FT_UInt32)(0x0F39UL), (FT_UInt32)(0x0F39UL) },
    { (FT_UInt32)(0x0F3EUL), (FT_UInt32)(0x0F3FUL) },
    { (FT_UInt32)(0x0F71UL), (FT_UInt32)(0x0F7EUL) },
    { (FT_UInt32)(0x0F80UL), (FT_UInt32)(0x0F84UL) },
    { (FT_UInt32)(0x0F86UL), (FT_UInt32)(0x0F87UL) },
    { (FT_UInt32)(0x0F8DUL), (FT_UInt32)(0x0FBCUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };







  const AF_Script_UniRangeRec af_hani_uniranges[] =
  {
    { (FT_UInt32)(0x1100UL), (FT_UInt32)(0x11FFUL) },
    { (FT_UInt32)(0x2E80UL), (FT_UInt32)(0x2EFFUL) },
    { (FT_UInt32)(0x2F00UL), (FT_UInt32)(0x2FDFUL) },
    { (FT_UInt32)(0x2FF0UL), (FT_UInt32)(0x2FFFUL) },
    { (FT_UInt32)(0x3000UL), (FT_UInt32)(0x303FUL) },
    { (FT_UInt32)(0x3040UL), (FT_UInt32)(0x309FUL) },
    { (FT_UInt32)(0x30A0UL), (FT_UInt32)(0x30FFUL) },
    { (FT_UInt32)(0x3100UL), (FT_UInt32)(0x312FUL) },
    { (FT_UInt32)(0x3130UL), (FT_UInt32)(0x318FUL) },
    { (FT_UInt32)(0x3190UL), (FT_UInt32)(0x319FUL) },
    { (FT_UInt32)(0x31A0UL), (FT_UInt32)(0x31BFUL) },
    { (FT_UInt32)(0x31C0UL), (FT_UInt32)(0x31EFUL) },
    { (FT_UInt32)(0x31F0UL), (FT_UInt32)(0x31FFUL) },
    { (FT_UInt32)(0x3300UL), (FT_UInt32)(0x33FFUL) },
    { (FT_UInt32)(0x3400UL), (FT_UInt32)(0x4DBFUL) },
    { (FT_UInt32)(0x4DC0UL), (FT_UInt32)(0x4DFFUL) },
    { (FT_UInt32)(0x4E00UL), (FT_UInt32)(0x9FFFUL) },
    { (FT_UInt32)(0xA960UL), (FT_UInt32)(0xA97FUL) },
    { (FT_UInt32)(0xAC00UL), (FT_UInt32)(0xD7AFUL) },
    { (FT_UInt32)(0xD7B0UL), (FT_UInt32)(0xD7FFUL) },
    { (FT_UInt32)(0xF900UL), (FT_UInt32)(0xFAFFUL) },
    { (FT_UInt32)(0xFE10UL), (FT_UInt32)(0xFE1FUL) },
    { (FT_UInt32)(0xFE30UL), (FT_UInt32)(0xFE4FUL) },
    { (FT_UInt32)(0xFF00UL), (FT_UInt32)(0xFFEFUL) },
    { (FT_UInt32)(0x1B000UL), (FT_UInt32)(0x1B0FFUL) },
    { (FT_UInt32)(0x1D300UL), (FT_UInt32)(0x1D35FUL) },
    { (FT_UInt32)(0x20000UL), (FT_UInt32)(0x2A6DFUL) },
    { (FT_UInt32)(0x2A700UL), (FT_UInt32)(0x2B73FUL) },
    { (FT_UInt32)(0x2B740UL), (FT_UInt32)(0x2B81FUL) },
    { (FT_UInt32)(0x2F800UL), (FT_UInt32)(0x2FA1FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };

  const AF_Script_UniRangeRec af_hani_nonbase_uniranges[] =
  {
    { (FT_UInt32)(0x302AUL), (FT_UInt32)(0x302FUL) },
    { (FT_UInt32)(0x3190UL), (FT_UInt32)(0x319FUL) },
    { (FT_UInt32)(0UL), (FT_UInt32)(0UL) }
  };
# 28 "../../../libs/freetype/src/autofit/autofit.c" 2

# 1 "../../../libs/freetype/src/autofit/afdummy.c" 1
# 25 "../../../libs/freetype/src/autofit/afdummy.c"
  static FT_Error
  af_dummy_hints_init( AF_GlyphHints hints,
                       AF_StyleMetrics metrics )
  {
    af_glyph_hints_rescale( hints, metrics );

    hints->x_scale = metrics->scaler.x_scale;
    hints->y_scale = metrics->scaler.y_scale;
    hints->x_delta = metrics->scaler.x_delta;
    hints->y_delta = metrics->scaler.y_delta;

    return FT_Err_Ok;
  }


  static FT_Error
  af_dummy_hints_apply( FT_UInt glyph_index,
                        AF_GlyphHints hints,
                        FT_Outline* outline )
  {
    FT_Error error;

    ( (glyph_index) = (glyph_index) );


    error = af_glyph_hints_reload( hints, outline );
    if ( !error )
      af_glyph_hints_save( hints, outline );

    return error;
  }


  const AF_WritingSystemClassRec af_dummy_writing_system_class = { AF_WRITING_SYSTEM_DUMMY, sizeof ( AF_StyleMetricsRec ), (AF_WritingSystem_InitMetricsFunc) ((void *)0), (AF_WritingSystem_ScaleMetricsFunc)((void *)0), (AF_WritingSystem_DoneMetricsFunc) ((void *)0), (AF_WritingSystem_GetStdWidthsFunc)((void *)0), (AF_WritingSystem_InitHintsFunc) af_dummy_hints_init, (AF_WritingSystem_ApplyHintsFunc) af_dummy_hints_apply };
# 30 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/aflatin.c" 1
# 20 "../../../libs/freetype/src/autofit/aflatin.c"
# 1 "../../../libs/freetype/include/freetype/ftadvanc.h" 1
# 33 "../../../libs/freetype/include/freetype/ftadvanc.h"

# 121 "../../../libs/freetype/include/freetype/ftadvanc.h"
  extern FT_Error
  FT_Get_Advance( FT_Face face,
                  FT_UInt gindex,
                  FT_Int32 load_flags,
                  FT_Fixed *padvance );
# 172 "../../../libs/freetype/include/freetype/ftadvanc.h"
  extern FT_Error
  FT_Get_Advances( FT_Face face,
                   FT_UInt start,
                   FT_UInt count,
                   FT_Int32 load_flags,
                   FT_Fixed *padvances );





# 21 "../../../libs/freetype/src/autofit/aflatin.c" 2
# 60 "../../../libs/freetype/src/autofit/aflatin.c"
  static void
  af_latin_metrics_init_widths( AF_LatinMetrics metrics,
                                FT_Face face )
  {

    AF_GlyphHintsRec hints[1];


    do { } while ( 0 )



                                                                   ;

    af_glyph_hints_init( hints, face->memory );

    metrics->axis[AF_DIMENSION_HORZ].width_count = 0;
    metrics->axis[AF_DIMENSION_VERT].width_count = 0;

    {
      FT_Error error;
      FT_ULong glyph_index;
      FT_Long y_offset;
      int dim;
      AF_LatinMetricsRec dummy[1];
      AF_Scaler scaler = &dummy->root.scaler;





      AF_StyleClass style_class = metrics->root.style_class;
      AF_ScriptClass script_class = af_script_classes
                                       [style_class->script];

      FT_UInt32 standard_char;
# 105 "../../../libs/freetype/src/autofit/aflatin.c"
      standard_char = script_class->standard_char1;
      af_get_char_index( &metrics->root,
                         standard_char,
                         &glyph_index,
                         &y_offset );
      if ( !glyph_index )
      {
        if ( script_class->standard_char2 )
        {
          standard_char = script_class->standard_char2;
          af_get_char_index( &metrics->root,
                             standard_char,
                             &glyph_index,
                             &y_offset );
          if ( !glyph_index )
          {
            if ( script_class->standard_char3 )
            {
              standard_char = script_class->standard_char3;
              af_get_char_index( &metrics->root,
                                 standard_char,
                                 &glyph_index,
                                 &y_offset );
              if ( !glyph_index )
                goto Exit;
            }
            else
              goto Exit;
          }
        }
        else
          goto Exit;
      }

      do { } while ( 0 )
                                               ;

      error = FT_Load_Glyph( face, glyph_index, ( 1L << 0 ) );
      if ( error || face->glyph->outline.n_points <= 0 )
        goto Exit;

      memset( dummy, 0, (FT_Offset)(sizeof ( *(dummy) )) );

      dummy->units_per_em = metrics->units_per_em;

      scaler->x_scale = 0x10000L;
      scaler->y_scale = 0x10000L;
      scaler->x_delta = 0;
      scaler->y_delta = 0;

      scaler->face = face;
      scaler->render_mode = FT_RENDER_MODE_NORMAL;
      scaler->flags = 0;

      af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );

      error = af_glyph_hints_reload( hints, &face->glyph->outline );
      if ( error )
        goto Exit;

      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_LatinAxis axis = &metrics->axis[dim];
        AF_AxisHints axhints = &hints->axis[dim];
        AF_Segment seg, limit, link;
        FT_UInt num_widths = 0;


        error = af_latin_hints_compute_segments( hints,
                                                 (AF_Dimension)dim );
        if ( error )
          goto Exit;







        af_latin_hints_link_segments( hints,
                                      0,
                                      ((void *)0),
                                      (AF_Dimension)dim );

        seg = axhints->segments;
        limit = seg + axhints->num_segments;

        for ( ; seg < limit; seg++ )
        {
          link = seg->link;


          if ( link && link->link == seg && link > seg )
          {
            FT_Pos dist;


            dist = seg->pos - link->pos;
            if ( dist < 0 )
              dist = -dist;

            if ( num_widths < 16 )
              axis->widths[num_widths++].org = dist;
          }
        }



        af_sort_and_quantize_widths( &num_widths, axis->widths,
                                     dummy->units_per_em / 100 );
        axis->width_count = num_widths;
      }

    Exit:
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_LatinAxis axis = &metrics->axis[dim];
        FT_Pos stdw;


        stdw = ( axis->width_count > 0 ) ? axis->widths[0].org
                                         : ( ( (50) * (FT_Long)( (AF_LatinMetrics)(metrics) )->units_per_em ) / 2048 );


        axis->edge_distance_threshold = stdw / 5;
        axis->standard_width = stdw;
        axis->extra_light = 0;
# 249 "../../../libs/freetype/src/autofit/aflatin.c"
      }
    }

    do { } while ( 0 );

    af_glyph_hints_done( hints );
  }





  static void
  af_latin_metrics_init_blues( AF_LatinMetrics metrics,
                               FT_Face face )
  {
    FT_Pos flats [51];
    FT_Pos rounds[51];

    FT_UInt num_flats;
    FT_UInt num_rounds;

    AF_LatinBlue blue;
    FT_Error error;
    AF_LatinAxis axis = &metrics->axis[AF_DIMENSION_VERT];
    FT_Outline outline;

    AF_StyleClass sc = metrics->root.style_class;

    AF_Blue_Stringset bss = sc->blue_stringset;
    const AF_Blue_StringRec* bs = &af_blue_stringsets[bss];

    FT_Pos flat_threshold = ( metrics->units_per_em / 14 );





    do { } while ( 0 )

                       ;

    for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
    {
      const char* p = &af_blue_strings[bs->string];
      FT_Pos* blue_ref;
      FT_Pos* blue_shoot;
      FT_Pos ascender;
      FT_Pos descender;
# 347 "../../../libs/freetype/src/autofit/aflatin.c"
      num_flats = 0;
      num_rounds = 0;
      ascender = 0;
      descender = 0;

      while ( *p )
      {
        FT_ULong ch;
        FT_ULong glyph_index;
        FT_Long y_offset;
        FT_Pos best_y;
        FT_Int best_point, best_contour_first, best_contour_last;
        FT_Vector* points;
        FT_Bool round = 0;


        ch = (unsigned char)*p++; if ( ch >= 0x80 ) { FT_UInt len; if ( ch < 0xE0 ) { len = 1; ch &= 0x1F; } else if ( ch < 0xF0 ) { len = 2; ch &= 0x0F; } else { len = 3; ch &= 0x07; } for ( ; len > 0; len-- ) ch = ( ch << 6 ) | ( *p++ & 0x3F ); };


        af_get_char_index( &metrics->root, ch, &glyph_index, &y_offset );
        if ( glyph_index == 0 )
        {
          do { } while ( 0 );
          continue;
        }

        error = FT_Load_Glyph( face, glyph_index, ( 1L << 0 ) );
        outline = face->glyph->outline;

        if ( error || outline.n_points <= 2 )
        {
          do { } while ( 0 );
          continue;
        }


        points = outline.points;
        best_point = -1;
        best_y = 0;
        best_contour_first = 0;
        best_contour_last = 0;

        {
          FT_Int nn;
          FT_Int first = 0;
          FT_Int last = -1;


          for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )
          {
            FT_Int old_best_point = best_point;
            FT_Int pp;


            last = outline.contours[nn];




            if ( last <= first )
              continue;

            if ( ( (bs)->properties & ( 1U << 0 ) ) )
            {
              for ( pp = first; pp <= last; pp++ )
              {
                if ( best_point < 0 || points[pp].y > best_y )
                {
                  best_point = pp;
                  best_y = points[pp].y;
                  ascender = ( (ascender) > (best_y + y_offset) ? (ascender) : (best_y + y_offset) );
                }
                else
                  descender = ( (descender) < (points[pp].y + y_offset) ? (descender) : (points[pp].y + y_offset) );
              }
            }
            else
            {
              for ( pp = first; pp <= last; pp++ )
              {
                if ( best_point < 0 || points[pp].y < best_y )
                {
                  best_point = pp;
                  best_y = points[pp].y;
                  descender = ( (descender) < (best_y + y_offset) ? (descender) : (best_y + y_offset) );
                }
                else
                  ascender = ( (ascender) > (points[pp].y + y_offset) ? (ascender) : (points[pp].y + y_offset) );
              }
            }

            if ( best_point != old_best_point )
            {
              best_contour_first = first;
              best_contour_last = last;
            }
          }
        }




        if ( best_point >= 0 )
        {
          FT_Pos best_x = points[best_point].x;
          FT_Int prev, next;
          FT_Int best_segment_first, best_segment_last;
          FT_Int best_on_point_first, best_on_point_last;
          FT_Pos dist;


          best_segment_first = best_point;
          best_segment_last = best_point;

          if ( ( outline.tags[best_point] & 3 ) == 1 )
          {
            best_on_point_first = best_point;
            best_on_point_last = best_point;
          }
          else
          {
            best_on_point_first = -1;
            best_on_point_last = -1;
          }




          prev = best_point;
          next = prev;

          do
          {
            if ( prev > best_contour_first )
              prev--;
            else
              prev = best_contour_last;

            dist = ( (points[prev].y - best_y) < 0 ? -(points[prev].y - best_y) : (points[prev].y - best_y) );


            if ( dist > 5 )
              if ( ( (points[prev].x - best_x) < 0 ? -(points[prev].x - best_x) : (points[prev].x - best_x) ) <= 20 * dist )
                break;

            best_segment_first = prev;

            if ( ( outline.tags[prev] & 3 ) == 1 )
            {
              best_on_point_first = prev;
              if ( best_on_point_last < 0 )
                best_on_point_last = prev;
            }

          } while ( prev != best_point );

          do
          {
            if ( next < best_contour_last )
              next++;
            else
              next = best_contour_first;

            dist = ( (points[next].y - best_y) < 0 ? -(points[next].y - best_y) : (points[next].y - best_y) );
            if ( dist > 5 )
              if ( ( (points[next].x - best_x) < 0 ? -(points[next].x - best_x) : (points[next].x - best_x) ) <= 20 * dist )
                break;

            best_segment_last = next;

            if ( ( outline.tags[next] & 3 ) == 1 )
            {
              best_on_point_last = next;
              if ( best_on_point_first < 0 )
                best_on_point_first = next;
            }

          } while ( next != best_point );

          if ( ( (bs)->properties & ( 1U << 3 ) ) )
          {
# 543 "../../../libs/freetype/src/autofit/aflatin.c"
            FT_Pos length_threshold = metrics->units_per_em / 25;


            dist = ( (points[best_segment_last].x - points[best_segment_first].x) < 0 ? -(points[best_segment_last].x - points[best_segment_first].x) : (points[best_segment_last].x - points[best_segment_first].x) )
                                                           ;

            if ( dist < length_threshold &&
                 best_segment_last - best_segment_first + 2 <=
                   best_contour_last - best_contour_first )
            {

              FT_Pos height_threshold = metrics->units_per_em / 4;

              FT_Int first;
              FT_Int last;
              FT_Bool hit;





              FT_Int p_first = 0;
              FT_Int p_last = 0;

              FT_Bool left2right;



              prev = best_point;

              do
              {
                if ( prev > best_contour_first )
                  prev--;
                else
                  prev = best_contour_last;

                if ( points[prev].x != best_x )
                  break;

              } while ( prev != best_point );


              if ( prev == best_point )
                continue;

              left2right = ( (FT_Bool)( points[prev].x < points[best_point].x ) );

              first = best_segment_last;
              last = first;
              hit = 0;

              do
              {
                FT_Bool l2r;
                FT_Pos d;


                if ( !hit )
                {

                  first = last;


                  if ( ( outline.tags[first] & 3 ) ==
                         1 )
                  {
                    p_first = first;
                    p_last = first;
                  }
                  else
                  {
                    p_first = -1;
                    p_last = -1;
                  }

                  hit = 1;
                }

                if ( last < best_contour_last )
                  last++;
                else
                  last = best_contour_first;

                if ( ( (best_y - points[first].y) < 0 ? -(best_y - points[first].y) : (best_y - points[first].y) ) > height_threshold )
                {

                  hit = 0;
                  continue;
                }


                dist = ( (points[last].y - points[first].y) < 0 ? -(points[last].y - points[first].y) : (points[last].y - points[first].y) );
                if ( dist > 5 )
                  if ( ( (points[last].x - points[first].x) < 0 ? -(points[last].x - points[first].x) : (points[last].x - points[first].x) ) <=
                         20 * dist )
                  {
                    hit = 0;
                    continue;
                  }

                if ( ( outline.tags[last] & 3 ) == 1 )
                {
                  p_last = last;
                  if ( p_first < 0 )
                    p_first = last;
                }

                l2r = ( (FT_Bool)( points[first].x < points[last].x ) );
                d = ( (points[last].x - points[first].x) < 0 ? -(points[last].x - points[first].x) : (points[last].x - points[first].x) );

                if ( l2r == left2right &&
                     d >= length_threshold )
                {


                  do
                  {
                    if ( last < best_contour_last )
                      last++;
                    else
                      last = best_contour_first;

                    d = ( (points[last].y - points[first].y) < 0 ? -(points[last].y - points[first].y) : (points[last].y - points[first].y) );
                    if ( d > 5 )
                      if ( ( (points[next].x - points[first].x) < 0 ? -(points[next].x - points[first].x) : (points[next].x - points[first].x) ) <=
                             20 * dist )
                      {
                        if ( last > best_contour_first )
                          last--;
                        else
                          last = best_contour_last;
                        break;
                      }

                    p_last = last;

                    if ( ( outline.tags[last] & 3 ) ==
                           1 )
                    {
                      p_last = last;
                      if ( p_first < 0 )
                        p_first = last;
                    }

                  } while ( last != best_segment_first );

                  best_y = points[first].y;

                  best_segment_first = first;
                  best_segment_last = last;

                  best_on_point_first = p_first;
                  best_on_point_last = p_last;

                  break;
                }

              } while ( last != best_segment_first );
            }
          }





          best_y += y_offset;

          do { } while ( 0 );
# 721 "../../../libs/freetype/src/autofit/aflatin.c"
          if ( best_on_point_first >= 0 &&
               best_on_point_last >= 0 &&
               ( ( (points[best_on_point_last].x - points[best_on_point_first].x) < 0 ? -(points[best_on_point_last].x - points[best_on_point_first].x) : (points[best_on_point_last].x - points[best_on_point_first].x) )
                                                         ) >
                 flat_threshold )
            round = 0;
          else
            round = ( (FT_Bool)( ( outline.tags[best_segment_first] & 3 ) != 1 || ( outline.tags[best_segment_last] & 3 ) != 1 ) )



                                                                           ;

          if ( round && ( (bs)->properties & ( 1U << 1 ) ) )
          {

            do { } while ( 0 );
            continue;
          }

          do { } while ( 0 );
        }

        if ( round )
          rounds[num_rounds++] = best_y;
        else
          flats[num_flats++] = best_y;
      }

      if ( num_flats == 0 && num_rounds == 0 )
      {




        do { } while ( 0 );
        continue;
      }




      af_sort_pos( num_rounds, rounds );
      af_sort_pos( num_flats, flats );

      blue = &axis->blues[axis->blue_count];
      blue_ref = &blue->ref.org;
      blue_shoot = &blue->shoot.org;

      axis->blue_count++;

      if ( num_flats == 0 )
      {
        *blue_ref =
        *blue_shoot = rounds[num_rounds / 2];
      }
      else if ( num_rounds == 0 )
      {
        *blue_ref =
        *blue_shoot = flats[num_flats / 2];
      }
      else
      {
        *blue_ref = flats [num_flats / 2];
        *blue_shoot = rounds[num_rounds / 2];
      }




      if ( *blue_shoot != *blue_ref )
      {
        FT_Pos ref = *blue_ref;
        FT_Pos shoot = *blue_shoot;
        FT_Bool over_ref = ( (FT_Bool)( shoot > ref ) );


        if ( ( (bs)->properties & ( 1U << 0 ) ) ^ over_ref )
        {
          *blue_ref =
          *blue_shoot = ( shoot + ref ) / 2;

          do { } while ( 0 )
                                                ;
        }
      }

      blue->ascender = ascender;
      blue->descender = descender;

      blue->flags = 0;
      if ( ( (bs)->properties & ( 1U << 0 ) ) )
        blue->flags |= ( 1U << 1 );
      if ( ( (bs)->properties & ( 1U << 1 ) ) )
        blue->flags |= ( 1U << 2 );






      if ( ( (bs)->properties & ( 1U << 2 ) ) )
        blue->flags |= ( 1U << 3 );

      do { } while ( 0 )

                                           ;
    }

    do { } while ( 0 );

    return;
  }




  static void
  af_latin_metrics_check_digits( AF_LatinMetrics metrics,
                                 FT_Face face )
  {
    FT_UInt i;
    FT_Bool started = 0, same_width = 1;
    FT_Fixed advance, old_advance = 0;



    for ( i = 0x30; i <= 0x39; i++ )
    {
      FT_ULong glyph_index;
      FT_Long y_offset;


      af_get_char_index( &metrics->root, i, &glyph_index, &y_offset );
      if ( glyph_index == 0 )
        continue;

      if ( FT_Get_Advance( face, glyph_index,
                           ( 1L << 0 ) |
                           ( 1L << 1 ) |
                           ( 1L << 11 ),
                           &advance ) )
        continue;

      if ( started )
      {
        if ( advance != old_advance )
        {
          same_width = 0;
          break;
        }
      }
      else
      {
        old_advance = advance;
        started = 1;
      }
    }

    metrics->root.digits_have_same_width = same_width;
  }




  static FT_Error
  af_latin_metrics_init( AF_LatinMetrics metrics,
                         FT_Face face )
  {
    FT_CharMap oldmap = face->charmap;


    metrics->units_per_em = face->units_per_EM;

    if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
    {
      af_latin_metrics_init_widths( metrics, face );
      af_latin_metrics_init_blues( metrics, face );
      af_latin_metrics_check_digits( metrics, face );
    }

    FT_Set_Charmap( face, oldmap );
    return FT_Err_Ok;
  }





  static void
  af_latin_metrics_scale_dim( AF_LatinMetrics metrics,
                              AF_Scaler scaler,
                              AF_Dimension dim )
  {
    FT_Fixed scale;
    FT_Pos delta;
    AF_LatinAxis axis;
    FT_UInt nn;


    if ( dim == AF_DIMENSION_HORZ )
    {
      scale = scaler->x_scale;
      delta = scaler->x_delta;
    }
    else
    {
      scale = scaler->y_scale;
      delta = scaler->y_delta;
    }

    axis = &metrics->axis[dim];

    if ( axis->org_scale == scale && axis->org_delta == delta )
      return;

    axis->org_scale = scale;
    axis->org_delta = delta;





    {
      AF_LatinAxis Axis = &metrics->axis[AF_DIMENSION_VERT];
      AF_LatinBlue blue = ((void *)0);


      for ( nn = 0; nn < Axis->blue_count; nn++ )
      {
        if ( Axis->blues[nn].flags & ( 1U << 3 ) )
        {
          blue = &Axis->blues[nn];
          break;
        }
      }

      if ( blue )
      {
        FT_Pos scaled;
        FT_Pos threshold;
        FT_Pos fitted;
        FT_UInt limit;
        FT_UInt ppem;


        scaled = FT_MulFix_arm( (FT_Int32)(blue->shoot.org), (FT_Int32)(scaler->y_scale) );
        ppem = metrics->root.scaler.face->size->metrics.x_ppem;
        limit = metrics->root.globals->increase_x_height;
        threshold = 40;



        if ( limit &&
             ppem <= limit &&
             ppem >= 6 )
          threshold = 52;

        fitted = ( scaled + threshold ) & ~63;

        if ( scaled != fitted )
        {
# 991 "../../../libs/freetype/src/autofit/aflatin.c"
          if ( dim == AF_DIMENSION_VERT )
          {
            FT_Pos max_height;
            FT_Pos dist;
            FT_Fixed new_scale;


            new_scale = FT_MulDiv( scale, fitted, scaled );


            max_height = metrics->units_per_em;

            for ( nn = 0; nn < Axis->blue_count; nn++ )
            {
              max_height = ( (max_height) > (Axis->blues[nn].ascender) ? (max_height) : (Axis->blues[nn].ascender) );
              max_height = ( (max_height) > (-Axis->blues[nn].descender) ? (max_height) : (-Axis->blues[nn].descender) );
            }

            dist = ( (FT_MulFix_arm( (FT_Int32)(max_height), (FT_Int32)(new_scale - scale) )) < 0 ? -(FT_MulFix_arm( (FT_Int32)(max_height), (FT_Int32)(new_scale - scale) )) : (FT_MulFix_arm( (FT_Int32)(max_height), (FT_Int32)(new_scale - scale) )) );
            dist &= ~127;

            if ( dist == 0 )
            {
              scale = new_scale;

              do { } while ( 0 )
# 1025 "../../../libs/freetype/src/autofit/aflatin.c"
                                                     ;
            }
# 1039 "../../../libs/freetype/src/autofit/aflatin.c"
          }
        }
      }
    }

    axis->scale = scale;
    axis->delta = delta;

    if ( dim == AF_DIMENSION_HORZ )
    {
      metrics->root.scaler.x_scale = scale;
      metrics->root.scaler.x_delta = delta;
    }
    else
    {
      metrics->root.scaler.y_scale = scale;
      metrics->root.scaler.y_delta = delta;
    }

    do { } while ( 0 )

                                                                   ;


    for ( nn = 0; nn < axis->width_count; nn++ )
    {
      AF_Width width = axis->widths + nn;


      width->cur = FT_MulFix_arm( (FT_Int32)(width->org), (FT_Int32)(scale) );
      width->fit = width->cur;

      do { } while ( 0 )

                                      ;
    }

    do { } while ( 0 );



    axis->extra_light =
      (FT_Bool)( FT_MulFix_arm( (FT_Int32)(axis->standard_width), (FT_Int32)(scale) ) < 32 + 8 );
# 1090 "../../../libs/freetype/src/autofit/aflatin.c"
    if ( dim == AF_DIMENSION_VERT )
    {







      for ( nn = 0; nn < axis->blue_count; nn++ )
      {
        AF_LatinBlue blue = &axis->blues[nn];
        FT_Pos dist;


        blue->ref.cur = FT_MulFix_arm( (FT_Int32)(blue->ref.org), (FT_Int32)(scale) ) + delta;
        blue->ref.fit = blue->ref.cur;
        blue->shoot.cur = FT_MulFix_arm( (FT_Int32)(blue->shoot.org), (FT_Int32)(scale) ) + delta;
        blue->shoot.fit = blue->shoot.cur;
        blue->flags &= ~( 1U << 0 );


        dist = FT_MulFix_arm( (FT_Int32)(blue->ref.org - blue->shoot.org), (FT_Int32)(scale) );
        if ( dist <= 48 && dist >= -48 )
        {



          FT_Pos delta2;
# 1149 "../../../libs/freetype/src/autofit/aflatin.c"
          delta2 = dist;
          if ( dist < 0 )
            delta2 = -delta2;

          if ( delta2 < 32 )
            delta2 = 0;
          else if ( delta2 < 48 )
            delta2 = 32;
          else
            delta2 = 64;

          if ( dist < 0 )
            delta2 = -delta2;

          blue->ref.fit = ( ((blue->ref.cur) + 32) & ~(__typeof__ ((blue->ref.cur) + 32))63 );
          blue->shoot.fit = blue->ref.fit - delta2;



          blue->flags |= ( 1U << 0 );

          do { } while ( 0 )
# 1181 "../../../libs/freetype/src/autofit/aflatin.c"
                                                                           ;
        }
      }
    }
  }




  static void
  af_latin_metrics_scale( AF_LatinMetrics metrics,
                          AF_Scaler scaler )
  {
    metrics->root.scaler.render_mode = scaler->render_mode;
    metrics->root.scaler.face = scaler->face;
    metrics->root.scaler.flags = scaler->flags;

    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
  }





  static void
  af_latin_get_standard_widths( AF_LatinMetrics metrics,
                                FT_Pos* stdHW,
                                FT_Pos* stdVW )
  {
    if ( stdHW )
      *stdHW = metrics->axis[AF_DIMENSION_VERT].standard_width;

    if ( stdVW )
      *stdVW = metrics->axis[AF_DIMENSION_HORZ].standard_width;
  }
# 1230 "../../../libs/freetype/src/autofit/aflatin.c"
  static FT_Error
  af_latin_hints_compute_segments( AF_GlyphHints hints,
                                   AF_Dimension dim )
  {
    AF_LatinMetrics metrics = (AF_LatinMetrics)hints->metrics;
    AF_AxisHints axis = &hints->axis[dim];
    FT_Memory memory = hints->memory;
    FT_Error error = FT_Err_Ok;
    AF_Segment segment = ((void *)0);
    AF_SegmentRec seg0;
    AF_Point* contour = hints->contours;
    AF_Point* contour_limit = contour + hints->num_contours;
    AF_Direction major_dir, segment_dir;

    FT_Pos flat_threshold = ( metrics->units_per_em / 14 );


    memset( &seg0, 0, (FT_Offset)(sizeof ( *(&seg0) )) );
    seg0.score = 32000;
    seg0.flags = 0;

    major_dir = (AF_Direction)( (axis->major_dir) < 0 ? -(axis->major_dir) : (axis->major_dir) );
    segment_dir = major_dir;

    axis->num_segments = 0;


    if ( dim == AF_DIMENSION_HORZ )
    {
      AF_Point point = hints->points;
      AF_Point limit = point + hints->num_points;


      for ( ; point < limit; point++ )
      {
        point->u = point->fx;
        point->v = point->fy;
      }
    }
    else
    {
      AF_Point point = hints->points;
      AF_Point limit = point + hints->num_points;


      for ( ; point < limit; point++ )
      {
        point->u = point->fy;
        point->v = point->fx;
      }
    }


    for ( ; contour < contour_limit; contour++ )
    {
      AF_Point point = contour[0];
      AF_Point last = point->prev;
      int on_edge = 0;
      FT_Pos min_pos = 32000;
      FT_Pos max_pos = -32000;
      FT_Pos min_on_pos = 32000;
      FT_Pos max_on_pos = -32000;
      FT_Bool passed;


      if ( point == last )
        continue;

      if ( ( (last->out_dir) < 0 ? -(last->out_dir) : (last->out_dir) ) == major_dir &&
           ( (point->out_dir) < 0 ? -(point->out_dir) : (point->out_dir) ) == major_dir )
      {

        last = point;

        for (;;)
        {
          point = point->prev;
          if ( ( (point->out_dir) < 0 ? -(point->out_dir) : (point->out_dir) ) != major_dir )
          {
            point = point->next;
            break;
          }
          if ( point == last )
            break;
        }
      }

      last = point;
      passed = 0;

      for (;;)
      {
        FT_Pos u, v;


        if ( on_edge )
        {
          u = point->u;
          if ( u < min_pos )
            min_pos = u;
          if ( u > max_pos )
            max_pos = u;


          if ( !( point->flags & ( ( 1U << 0 ) | ( 1U << 1 ) ) ) )
          {
            v = point->v;
            if ( v < min_on_pos )
              min_on_pos = v;
            if ( v > max_on_pos )
              max_on_pos = v;
          }

          if ( point->out_dir != segment_dir || point == last )
          {

            segment->last = point;
            segment->pos = (FT_Short)( ( min_pos + max_pos ) >> 1 );




            if ( ( segment->first->flags | point->flags ) & ( ( 1U << 0 ) | ( 1U << 1 ) ) &&
                 ( max_on_pos - min_on_pos ) < flat_threshold )
              segment->flags |= ( 1U << 0 );


            min_pos = max_pos = point->v;

            v = segment->first->v;
            if ( v < min_pos )
              min_pos = v;
            if ( v > max_pos )
              max_pos = v;

            segment->min_coord = (FT_Short)min_pos;
            segment->max_coord = (FT_Short)max_pos;
            segment->height = (FT_Short)( segment->max_coord -
                                             segment->min_coord );

            on_edge = 0;
            segment = ((void *)0);

          }
        }


        if ( point == last )
        {
          if ( passed )
            break;
          passed = 1;
        }

        if ( !on_edge && ( (point->out_dir) < 0 ? -(point->out_dir) : (point->out_dir) ) == major_dir )
        {

          segment_dir = (AF_Direction)point->out_dir;

          error = af_axis_hints_new_segment( axis, memory, &segment );
          if ( error )
            goto Exit;


          segment[0] = seg0;

          segment->dir = (FT_Char)segment_dir;
          segment->first = point;
          segment->last = point;

          min_pos = max_pos = point->u;

          if ( point->flags & ( ( 1U << 0 ) | ( 1U << 1 ) ) )
          {
            min_on_pos = 32000;
            max_on_pos = -32000;
          }
          else
            min_on_pos = max_on_pos = point->v;

          on_edge = 1;
        }

        point = point->next;
      }

    }




    {
      AF_Segment segments = axis->segments;
      AF_Segment segments_end = segments + axis->num_segments;


      for ( segment = segments; segment < segments_end; segment++ )
      {
        AF_Point first = segment->first;
        AF_Point last = segment->last;
        FT_Pos first_v = first->v;
        FT_Pos last_v = last->v;


        if ( first_v < last_v )
        {
          AF_Point p;


          p = first->prev;
          if ( p->v < first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( first_v - p->v ) >> 1 ) );

          p = last->next;
          if ( p->v > last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - last_v ) >> 1 ) );
        }
        else
        {
          AF_Point p;


          p = first->prev;
          if ( p->v > first_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( p->v - first_v ) >> 1 ) );

          p = last->next;
          if ( p->v < last_v )
            segment->height = (FT_Short)( segment->height +
                                          ( ( last_v - p->v ) >> 1 ) );
        }
      }
    }

  Exit:
    return error;
  }





  static void
  af_latin_hints_link_segments( AF_GlyphHints hints,
                                FT_UInt width_count,
                                AF_WidthRec* widths,
                                AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    AF_Segment segments = axis->segments;
    AF_Segment segment_limit = segments + axis->num_segments;
    FT_Pos len_threshold, len_score, dist_score, max_width;
    AF_Segment seg1, seg2;


    if ( width_count )
      max_width = widths[width_count - 1].org;
    else
      max_width = 0;


    len_threshold = ( ( (8) * (FT_Long)( (AF_LatinMetrics)(hints->metrics) )->units_per_em ) / 2048 );
    if ( len_threshold == 0 )
      len_threshold = 1;


    len_score = ( ( (6000) * (FT_Long)( (AF_LatinMetrics)(hints->metrics) )->units_per_em ) / 2048 );




    dist_score = 3000;


    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
    {
      if ( seg1->dir != axis->major_dir )
        continue;



      for ( seg2 = segments; seg2 < segment_limit; seg2++ )
      {
        FT_Pos pos1 = seg1->pos;
        FT_Pos pos2 = seg2->pos;


        if ( seg1->dir + seg2->dir == 0 && pos2 > pos1 )
        {

          FT_Pos min = seg1->min_coord;
          FT_Pos max = seg1->max_coord;
          FT_Pos len;


          if ( min < seg2->min_coord )
            min = seg2->min_coord;

          if ( max > seg2->max_coord )
            max = seg2->max_coord;



          len = max - min;
          if ( len >= len_threshold )
          {
# 1553 "../../../libs/freetype/src/autofit/aflatin.c"
            FT_Pos dist = pos2 - pos1;

            FT_Pos dist_demerit, score;


            if ( max_width )
            {


              FT_Pos delta = ( dist << 10 ) / max_width - ( 1 << 10 );


              if ( delta > 10000 )
                dist_demerit = 32000;
              else if ( delta > 0 )
                dist_demerit = delta * delta / dist_score;
              else
                dist_demerit = 0;
            }
            else
              dist_demerit = dist;

            score = dist_demerit + len_score / len;


            if ( score < seg1->score )
            {
              seg1->score = score;
              seg1->link = seg2;
            }

            if ( score < seg2->score )
            {
              seg2->score = score;
              seg2->link = seg1;
            }
          }
        }
      }
    }


    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
    {
      seg2 = seg1->link;

      if ( seg2 )
      {
        if ( seg2->link != seg1 )
        {
          seg1->link = 0;
          seg1->serif = seg2->link;
        }
      }
    }
  }




  static FT_Error
  af_latin_hints_compute_edges( AF_GlyphHints hints,
                                AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    FT_Error error = FT_Err_Ok;
    FT_Memory memory = hints->memory;
    AF_LatinAxis laxis = &((AF_LatinMetrics)hints->metrics)->axis[dim];

    AF_Segment segments = axis->segments;
    AF_Segment segment_limit = segments + axis->num_segments;
    AF_Segment seg;




    FT_Fixed scale;
    FT_Pos edge_distance_threshold;
    FT_Pos segment_length_threshold;


    axis->num_edges = 0;

    scale = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
                                         : hints->y_scale;
# 1649 "../../../libs/freetype/src/autofit/aflatin.c"
    if ( dim == AF_DIMENSION_HORZ )
        segment_length_threshold = FT_DivFix( 64, hints->y_scale );
    else
        segment_length_threshold = 0;
# 1671 "../../../libs/freetype/src/autofit/aflatin.c"
    edge_distance_threshold = FT_MulFix_arm( (FT_Int32)(laxis->edge_distance_threshold), (FT_Int32)(scale) )
                                                ;
    if ( edge_distance_threshold > 64 / 4 )
      edge_distance_threshold = 64 / 4;

    edge_distance_threshold = FT_DivFix( edge_distance_threshold,
                                         scale );

    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge found = ((void *)0);
      FT_Int ee;


      if ( seg->height < segment_length_threshold )
        continue;



      if ( seg->serif &&
           2 * seg->height < 3 * segment_length_threshold )
        continue;


      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge edge = axis->edges + ee;
        FT_Pos dist;


        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;

        if ( dist < edge_distance_threshold && edge->dir == seg->dir )
        {
          found = edge;
          break;
        }
      }

      if ( !found )
      {
        AF_Edge edge;




        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir,
                                        memory, &edge );
        if ( error )
          goto Exit;


        memset( edge, 0, (FT_Offset)(sizeof ( *(edge) )) );

        edge->first = seg;
        edge->last = seg;
        edge->dir = seg->dir;
        edge->fpos = seg->pos;
        edge->opos = FT_MulFix_arm( (FT_Int32)(seg->pos), (FT_Int32)(scale) );
        edge->pos = edge->opos;
        seg->edge_next = seg;
      }
      else
      {


        seg->edge_next = found->first;
        found->last->edge_next = seg;
        found->last = seg;
      }
    }
# 1767 "../../../libs/freetype/src/autofit/aflatin.c"
    {
      AF_Edge edges = axis->edges;
      AF_Edge edge_limit = edges + axis->num_edges;
      AF_Edge edge;


      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg = seg->edge_next;

          } while ( seg != edge->first );
      }


      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Int is_round = 0;
        FT_Int is_straight = 0;






        seg = edge->first;

        do
        {
          FT_Bool is_serif;



          if ( seg->flags & ( 1U << 0 ) )
            is_round++;
          else
            is_straight++;
# 1819 "../../../libs/freetype/src/autofit/aflatin.c"
          is_serif = (FT_Bool)( seg->serif &&
                                seg->serif->edge &&
                                seg->serif->edge != edge );

          if ( ( seg->link && seg->link->edge != ((void *)0) ) || is_serif )
          {
            AF_Edge edge2;
            AF_Segment seg2;


            edge2 = edge->link;
            seg2 = seg->link;

            if ( is_serif )
            {
              seg2 = seg->serif;
              edge2 = edge->serif;
            }

            if ( edge2 )
            {
              FT_Pos edge_delta;
              FT_Pos seg_delta;


              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;

              seg_delta = seg->pos - seg2->pos;
              if ( seg_delta < 0 )
                seg_delta = -seg_delta;

              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
              edge2 = seg2->edge;

            if ( is_serif )
            {
              edge->serif = edge2;
              edge2->flags |= ( 1U << 1 );
            }
            else
              edge->link = edge2;
          }

          seg = seg->edge_next;

        } while ( seg != edge->first );


        edge->flags = 0;

        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= ( 1U << 0 );
# 1895 "../../../libs/freetype/src/autofit/aflatin.c"
        if ( edge->serif && edge->link )
          edge->serif = ((void *)0);
      }
    }

  Exit:
    return error;
  }




  static FT_Error
  af_latin_hints_detect_features( AF_GlyphHints hints,
                                  FT_UInt width_count,
                                  AF_WidthRec* widths,
                                  AF_Dimension dim )
  {
    FT_Error error;


    error = af_latin_hints_compute_segments( hints, dim );
    if ( !error )
    {
      af_latin_hints_link_segments( hints, width_count, widths, dim );

      error = af_latin_hints_compute_edges( hints, dim );
    }

    return error;
  }




  static void
  af_latin_hints_compute_blue_edges( AF_GlyphHints hints,
                                     AF_LatinMetrics metrics )
  {
    AF_AxisHints axis = &hints->axis[AF_DIMENSION_VERT];
    AF_Edge edge = axis->edges;
    AF_Edge edge_limit = edge + axis->num_edges;
    AF_LatinAxis latin = &metrics->axis[AF_DIMENSION_VERT];
    FT_Fixed scale = latin->scale;






    for ( ; edge < edge_limit; edge++ )
    {
      FT_UInt bb;
      AF_Width best_blue = ((void *)0);
      FT_Bool best_blue_is_neutral = 0;
      FT_Pos best_dist;




      best_dist = FT_MulFix_arm( (FT_Int32)(metrics->units_per_em / 40), (FT_Int32)(scale) );


      if ( best_dist > 64 / 2 )
        best_dist = 64 / 2;

      for ( bb = 0; bb < latin->blue_count; bb++ )
      {
        AF_LatinBlue blue = latin->blues + bb;
        FT_Bool is_top_blue, is_neutral_blue, is_major_dir;



        if ( !( blue->flags & ( 1U << 0 ) ) )
          continue;





        is_top_blue =
          (FT_Byte)( ( blue->flags & ( 1U << 1 ) ) != 0 );
        is_neutral_blue =
          (FT_Byte)( ( blue->flags & ( 1U << 2 ) ) != 0);
        is_major_dir =
          ( (FT_Bool)( edge->dir == axis->major_dir ) );


        if ( is_top_blue ^ is_major_dir || is_neutral_blue )
        {
          FT_Pos dist;



          dist = edge->fpos - blue->ref.org;
          if ( dist < 0 )
            dist = -dist;

          dist = FT_MulFix_arm( (FT_Int32)(dist), (FT_Int32)(scale) );
          if ( dist < best_dist )
          {
            best_dist = dist;
            best_blue = &blue->ref;
            best_blue_is_neutral = is_neutral_blue;
          }






          if ( edge->flags & ( 1U << 0 ) &&
               dist != 0 &&
               !is_neutral_blue )
          {
            FT_Bool is_under_ref = ( (FT_Bool)( edge->fpos < blue->ref.org ) );


            if ( is_top_blue ^ is_under_ref )
            {
              dist = edge->fpos - blue->shoot.org;
              if ( dist < 0 )
                dist = -dist;

              dist = FT_MulFix_arm( (FT_Int32)(dist), (FT_Int32)(scale) );
              if ( dist < best_dist )
              {
                best_dist = dist;
                best_blue = &blue->shoot;
                best_blue_is_neutral = is_neutral_blue;
              }
            }
          }
        }
      }

      if ( best_blue )
      {
        edge->blue_edge = best_blue;
        if ( best_blue_is_neutral )
          edge->flags |= ( 1U << 3 );
      }
    }
  }




  static FT_Error
  af_latin_hints_init( AF_GlyphHints hints,
                       AF_LatinMetrics metrics )
  {
    FT_Render_Mode mode;
    FT_UInt32 scaler_flags, other_flags;
    FT_Face face = metrics->root.scaler.face;


    af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );





    hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
    hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
    hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
    hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;


    mode = metrics->root.scaler.render_mode;






    scaler_flags = hints->scaler_flags;
    other_flags = 0;





    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
      other_flags |= ( 1U << 0 );





    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
      other_flags |= ( 1U << 1 );




    if ( mode != FT_RENDER_MODE_LIGHT )
      other_flags |= ( 1U << 2 );

    if ( mode == FT_RENDER_MODE_MONO )
      other_flags |= ( 1U << 3 );
# 2104 "../../../libs/freetype/src/autofit/aflatin.c"
    if ( mode == FT_RENDER_MODE_LIGHT ||
         ( face->style_flags & ( 1 << 0 ) ) != 0 )
      scaler_flags |= 1U;







    hints->scaler_flags = scaler_flags;
    hints->other_flags = other_flags;

    return FT_Err_Ok;
  }
# 2132 "../../../libs/freetype/src/autofit/aflatin.c"
  static FT_Pos
  af_latin_snap_width( AF_Width widths,
                       FT_UInt count,
                       FT_Pos width )
  {
    FT_UInt n;
    FT_Pos best = 64 + 32 + 2;
    FT_Pos reference = width;
    FT_Pos scaled;


    for ( n = 0; n < count; n++ )
    {
      FT_Pos w;
      FT_Pos dist;


      w = widths[n].cur;
      dist = width - w;
      if ( dist < 0 )
        dist = -dist;
      if ( dist < best )
      {
        best = dist;
        reference = w;
      }
    }

    scaled = ( ((reference) + 32) & ~(__typeof__ ((reference) + 32))63 );

    if ( width >= reference )
    {
      if ( width < scaled + 48 )
        width = reference;
    }
    else
    {
      if ( width > scaled - 48 )
        width = reference;
    }

    return width;
  }






  static FT_Pos
  af_latin_compute_stem_width( AF_GlyphHints hints,
                               AF_Dimension dim,
                               FT_Pos width,
                               FT_UInt base_flags,
                               FT_UInt stem_flags )
  {
    AF_LatinMetrics metrics = (AF_LatinMetrics)hints->metrics;
    AF_LatinAxis axis = &metrics->axis[dim];
    FT_Pos dist = width;
    FT_Int sign = 0;
    FT_Int vertical = ( dim == AF_DIMENSION_VERT );


    if ( !( (hints)->other_flags & (( 1U << 2 )) ) ||
         axis->extra_light )
      return width;

    if ( dist < 0 )
    {
      dist = -width;
      sign = 1;
    }

    if ( ( vertical && !( (hints)->other_flags & (( 1U << 1 )) ) ) ||
         ( !vertical && !( (hints)->other_flags & (( 1U << 0 )) ) ) )
    {



      if ( ( stem_flags & ( 1U << 1 ) ) &&
           vertical &&
           ( dist < 3 * 64 ) )
        goto Done_Width;

      else if ( base_flags & ( 1U << 0 ) )
      {
        if ( dist < 80 )
          dist = 64;
      }
      else if ( dist < 56 )
        dist = 56;

      if ( axis->width_count > 0 )
      {
        FT_Pos delta;



        delta = dist - axis->widths[0].cur;

        if ( delta < 0 )
          delta = -delta;

        if ( delta < 40 )
        {
          dist = axis->widths[0].cur;
          if ( dist < 48 )
            dist = 48;

          goto Done_Width;
        }

        if ( dist < 3 * 64 )
        {
          delta = dist & 63;
          dist &= -64;

          if ( delta < 10 )
            dist += delta;

          else if ( delta < 32 )
            dist += 10;

          else if ( delta < 54 )
            dist += 54;

          else
            dist += delta;
        }
        else
          dist = ( dist + 32 ) & ~63;
      }
    }
    else
    {


      FT_Pos org_dist = dist;


      dist = af_latin_snap_width( axis->widths, axis->width_count, dist );

      if ( vertical )
      {



        if ( dist >= 64 )
          dist = ( dist + 16 ) & ~63;
        else
          dist = 64;
      }
      else
      {
        if ( ( (hints)->other_flags & (( 1U << 3 )) ) )
        {



          if ( dist < 64 )
            dist = 64;
          else
            dist = ( dist + 32 ) & ~63;
        }
        else
        {




          if ( dist < 48 )
            dist = ( dist + 64 ) >> 1;

          else if ( dist < 128 )
          {






            FT_Pos delta;


            dist = ( dist + 22 ) & ~63;
            delta = dist - org_dist;
            if ( delta < 0 )
              delta = -delta;

            if ( delta >= 16 )
            {
              dist = org_dist;
              if ( dist < 48 )
                dist = ( dist + 64 ) >> 1;
            }
          }
          else

            dist = ( dist + 32 ) & ~63;
        }
      }
    }

  Done_Width:
    if ( sign )
      dist = -dist;

    return dist;
  }




  static void
  af_latin_align_linked_edge( AF_GlyphHints hints,
                              AF_Dimension dim,
                              AF_Edge base_edge,
                              AF_Edge stem_edge )
  {
    FT_Pos dist = stem_edge->opos - base_edge->opos;

    FT_Pos fitted_width = af_latin_compute_stem_width( hints, dim, dist,
                                                        base_edge->flags,
                                                        stem_edge->flags );


    stem_edge->pos = base_edge->pos + fitted_width;

    do { } while ( 0 )


                                                                          ;
  }





  static void
  af_latin_align_serif_edge( AF_GlyphHints hints,
                             AF_Edge base,
                             AF_Edge serif )
  {
    ( (hints) = (hints) );

    serif->pos = base->pos + ( serif->opos - base->opos );
  }
# 2394 "../../../libs/freetype/src/autofit/aflatin.c"
  static void
  af_latin_hint_edges( AF_GlyphHints hints,
                       AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    AF_Edge edges = axis->edges;
    AF_Edge edge_limit = edges + axis->num_edges;
    FT_PtrDist n_edges;
    AF_Edge edge;
    AF_Edge anchor = ((void *)0);
    FT_Int has_serifs = 0;






    do { } while ( 0 )

                                                                     ;




    if ( dim == AF_DIMENSION_VERT && 1 )
    {
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        AF_Width blue;
        AF_Edge edge1, edge2;


        if ( edge->flags & ( 1U << 2 ) )
          continue;

        edge1 = ((void *)0);
        edge2 = edge->link;
# 2441 "../../../libs/freetype/src/autofit/aflatin.c"
        if ( edge->blue_edge && edge2 && edge2->blue_edge )
        {
          FT_Byte neutral = edge->flags & ( 1U << 3 );
          FT_Byte neutral2 = edge2->flags & ( 1U << 3 );


          if ( neutral2 )
          {
            edge2->blue_edge = ((void *)0);
            edge2->flags &= ~( 1U << 3 );
          }
          else if ( neutral )
          {
            edge->blue_edge = ((void *)0);
            edge->flags &= ~( 1U << 3 );
          }
        }

        blue = edge->blue_edge;
        if ( blue )
          edge1 = edge;


        else if ( edge2 && edge2->blue_edge )
        {
          blue = edge2->blue_edge;
          edge1 = edge2;
          edge2 = edge;
        }

        if ( !edge1 )
          continue;
# 2489 "../../../libs/freetype/src/autofit/aflatin.c"
        edge1->pos = blue->fit;
        edge1->flags |= ( 1U << 2 );

        if ( edge2 && !edge2->blue_edge )
        {
          af_latin_align_linked_edge( hints, dim, edge1, edge2 );
          edge2->flags |= ( 1U << 2 );




        }

        if ( !anchor )
          anchor = edge;
      }
    }



    for ( edge = edges; edge < edge_limit; edge++ )
    {
      AF_Edge edge2;


      if ( edge->flags & ( 1U << 2 ) )
        continue;


      edge2 = edge->link;
      if ( !edge2 )
      {
        has_serifs++;
        continue;
      }




      if ( edge2->blue_edge )
      {
        do { } while ( 0 );

        af_latin_align_linked_edge( hints, dim, edge2, edge );
        edge->flags |= ( 1U << 2 );




        continue;
      }

      if ( !anchor )
      {


        FT_Pos org_len, org_center, cur_len;
        FT_Pos cur_pos1, error1, error2, u_off, d_off;


        org_len = edge2->opos - edge->opos;
        cur_len = af_latin_compute_stem_width( hints, dim, org_len,
                                               edge->flags,
                                               edge2->flags );




        if ( cur_len <= 64 )
        {

          u_off = 32;
          d_off = 32;
        }
        else
        {

          u_off = 38;
          d_off = 26;
        }

        if ( cur_len < 96 )
        {
          org_center = edge->opos + ( org_len >> 1 );
          cur_pos1 = ( ((org_center) + 32) & ~(__typeof__ ((org_center) + 32))63 );

          error1 = org_center - ( cur_pos1 - u_off );
          if ( error1 < 0 )
            error1 = -error1;

          error2 = org_center - ( cur_pos1 + d_off );
          if ( error2 < 0 )
            error2 = -error2;

          if ( error1 < error2 )
            cur_pos1 -= u_off;
          else
            cur_pos1 += d_off;

          edge->pos = cur_pos1 - cur_len / 2;
          edge2->pos = edge->pos + cur_len;
        }
        else
          edge->pos = ( ((edge->opos) + 32) & ~(__typeof__ ((edge->opos) + 32))63 );

        anchor = edge;
        edge->flags |= ( 1U << 2 );

        do { } while ( 0 )



                                                          ;

        af_latin_align_linked_edge( hints, dim, edge, edge2 );




      }
      else
      {
        FT_Pos org_pos, org_len, org_center, cur_len;
        FT_Pos cur_pos1, cur_pos2, delta1, delta2;


        org_pos = anchor->pos + ( edge->opos - anchor->opos );
        org_len = edge2->opos - edge->opos;
        org_center = org_pos + ( org_len >> 1 );

        cur_len = af_latin_compute_stem_width( hints, dim, org_len,
                                               edge->flags,
                                               edge2->flags );

        if ( edge2->flags & ( 1U << 2 ) )
        {
          do { } while ( 0 )

                                                        ;

          edge->pos = edge2->pos - cur_len;
        }

        else if ( cur_len < 96 )
        {
          FT_Pos u_off, d_off;


          cur_pos1 = ( ((org_center) + 32) & ~(__typeof__ ((org_center) + 32))63 );

          if ( cur_len <= 64 )
          {
            u_off = 32;
            d_off = 32;
          }
          else
          {
            u_off = 38;
            d_off = 26;
          }

          delta1 = org_center - ( cur_pos1 - u_off );
          if ( delta1 < 0 )
            delta1 = -delta1;

          delta2 = org_center - ( cur_pos1 + d_off );
          if ( delta2 < 0 )
            delta2 = -delta2;

          if ( delta1 < delta2 )
            cur_pos1 -= u_off;
          else
            cur_pos1 += d_off;

          edge->pos = cur_pos1 - cur_len / 2;
          edge2->pos = cur_pos1 + cur_len / 2;

          do { } while ( 0 )



                                                            ;
        }

        else
        {
          org_pos = anchor->pos + ( edge->opos - anchor->opos );
          org_len = edge2->opos - edge->opos;
          org_center = org_pos + ( org_len >> 1 );

          cur_len = af_latin_compute_stem_width( hints, dim, org_len,
                                                    edge->flags,
                                                    edge2->flags );

          cur_pos1 = ( ((org_pos) + 32) & ~(__typeof__ ((org_pos) + 32))63 );
          delta1 = cur_pos1 + ( cur_len >> 1 ) - org_center;
          if ( delta1 < 0 )
            delta1 = -delta1;

          cur_pos2 = ( ((org_pos + org_len) + 32) & ~(__typeof__ ((org_pos + org_len) + 32))63 ) - cur_len;
          delta2 = cur_pos2 + ( cur_len >> 1 ) - org_center;
          if ( delta2 < 0 )
            delta2 = -delta2;

          edge->pos = ( delta1 < delta2 ) ? cur_pos1 : cur_pos2;
          edge2->pos = edge->pos + cur_len;

          do { } while ( 0 )



                                                            ;
        }





        edge->flags |= ( 1U << 2 );
        edge2->flags |= ( 1U << 2 );

        if ( edge > edges && edge->pos < edge[-1].pos )
        {







          edge->pos = edge[-1].pos;
        }
      }
    }
# 2739 "../../../libs/freetype/src/autofit/aflatin.c"
    n_edges = edge_limit - edges;
    if ( dim == AF_DIMENSION_HORZ && ( n_edges == 6 || n_edges == 12 ) )
    {
      AF_Edge edge1, edge2, edge3;
      FT_Pos dist1, dist2, span, delta;


      if ( n_edges == 6 )
      {
        edge1 = edges;
        edge2 = edges + 2;
        edge3 = edges + 4;
      }
      else
      {
        edge1 = edges + 1;
        edge2 = edges + 5;
        edge3 = edges + 9;
      }

      dist1 = edge2->opos - edge1->opos;
      dist2 = edge3->opos - edge2->opos;

      span = dist1 - dist2;
      if ( span < 0 )
        span = -span;

      if ( span < 8 )
      {
        delta = edge3->pos - ( 2 * edge2->pos - edge1->pos );
        edge3->pos -= delta;
        if ( edge3->link )
          edge3->link->pos -= delta;


        if ( n_edges == 12 )
        {
          ( edges + 8 )->pos -= delta;
          ( edges + 11 )->pos -= delta;
        }

        edge3->flags |= ( 1U << 2 );
        if ( edge3->link )
          edge3->link->flags |= ( 1U << 2 );
      }
    }

    if ( has_serifs || !anchor )
    {




      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Pos delta;


        if ( edge->flags & ( 1U << 2 ) )
          continue;

        delta = 1000;

        if ( edge->serif )
        {
          delta = edge->serif->opos - edge->opos;
          if ( delta < 0 )
            delta = -delta;
        }

        if ( delta < 64 + 16 )
        {
          af_latin_align_serif_edge( hints, edge->serif, edge );
          do { } while ( 0 )



                                         ;
        }
        else if ( !anchor )
        {
          edge->pos = ( ((edge->opos) + 32) & ~(__typeof__ ((edge->opos) + 32))63 );
          anchor = edge;
          do { } while ( 0 )

                                                                        ;
        }
        else
        {
          AF_Edge before, after;


          for ( before = edge - 1; before >= edges; before-- )
            if ( before->flags & ( 1U << 2 ) )
              break;

          for ( after = edge + 1; after < edge_limit; after++ )
            if ( after->flags & ( 1U << 2 ) )
              break;

          if ( before >= edges && before < edge &&
               after < edge_limit && after > edge )
          {
            if ( after->opos == before->opos )
              edge->pos = before->pos;
            else
              edge->pos = before->pos +
                          FT_MulDiv( edge->opos - before->opos,
                                     after->pos - before->pos,
                                     after->opos - before->opos );

            do { } while ( 0 )



                                                              ;
          }
          else
          {
            edge->pos = anchor->pos +
                        ( ( edge->opos - anchor->opos + 16 ) & ~31 );
            do { } while ( 0 )

                                                                            ;
          }
        }




        edge->flags |= ( 1U << 2 );

        if ( edge > edges && edge->pos < edge[-1].pos )
        {






          edge->pos = edge[-1].pos;
        }

        if ( edge + 1 < edge_limit &&
             edge[1].flags & ( 1U << 2 ) &&
             edge->pos > edge[1].pos )
        {







          edge->pos = edge[1].pos;
        }
      }
    }






  }




  static FT_Error
  af_latin_hints_apply( FT_UInt glyph_index,
                        AF_GlyphHints hints,
                        FT_Outline* outline,
                        AF_LatinMetrics metrics )
  {
    FT_Error error;
    int dim;

    AF_LatinAxis axis;


    error = af_glyph_hints_reload( hints, outline );
    if ( error )
      goto Exit;







    if ( !( (hints)->scaler_flags & (1U) ) )

    {
      axis = &metrics->axis[AF_DIMENSION_HORZ];
      error = af_latin_hints_detect_features( hints,
                                              axis->width_count,
                                              axis->widths,
                                              AF_DIMENSION_HORZ );
      if ( error )
        goto Exit;
    }

    if ( !( (hints)->scaler_flags & (2U) ) )
    {
      axis = &metrics->axis[AF_DIMENSION_VERT];
      error = af_latin_hints_detect_features( hints,
                                              axis->width_count,
                                              axis->widths,
                                              AF_DIMENSION_VERT );
      if ( error )
        goto Exit;


      if ( !( metrics->root.globals->glyph_styles[glyph_index] & 0x4000U ) )
        af_latin_hints_compute_blue_edges( hints, metrics );
    }


    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
    {
# 2978 "../../../libs/freetype/src/autofit/aflatin.c"
      if ( ( dim == AF_DIMENSION_HORZ && !( (hints)->scaler_flags & (1U) ) ) ||
           ( dim == AF_DIMENSION_VERT && !( (hints)->scaler_flags & (2U) ) ) )
      {
        af_latin_hint_edges( hints, (AF_Dimension)dim );
        af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
      }
    }

    af_glyph_hints_save( hints, outline );

  Exit:
    return error;
  }
# 3004 "../../../libs/freetype/src/autofit/aflatin.c"
  const AF_WritingSystemClassRec af_latin_writing_system_class = { AF_WRITING_SYSTEM_LATIN, sizeof ( AF_LatinMetricsRec ), (AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init, (AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale, (AF_WritingSystem_DoneMetricsFunc) ((void *)0), (AF_WritingSystem_GetStdWidthsFunc)af_latin_get_standard_widths, (AF_WritingSystem_InitHintsFunc) af_latin_hints_init, (AF_WritingSystem_ApplyHintsFunc) af_latin_hints_apply };
# 31 "../../../libs/freetype/src/autofit/autofit.c" 2



# 1 "../../../libs/freetype/src/autofit/afcjk.c" 1
# 69 "../../../libs/freetype/src/autofit/afcjk.c"
  static void
  af_cjk_metrics_init_widths( AF_CJKMetrics metrics,
                              FT_Face face )
  {

    AF_GlyphHintsRec hints[1];


    do { } while ( 0 )



                                                                   ;

    af_glyph_hints_init( hints, face->memory );

    metrics->axis[AF_DIMENSION_HORZ].width_count = 0;
    metrics->axis[AF_DIMENSION_VERT].width_count = 0;

    {
      FT_Error error;
      FT_ULong glyph_index;
      FT_Long y_offset;
      int dim;
      AF_CJKMetricsRec dummy[1];
      AF_Scaler scaler = &dummy->root.scaler;





      AF_StyleClass style_class = metrics->root.style_class;
      AF_ScriptClass script_class = af_script_classes
                                       [style_class->script];

      FT_UInt32 standard_char;


      standard_char = script_class->standard_char1;
      af_get_char_index( &metrics->root,
                         standard_char,
                         &glyph_index,
                         &y_offset );
      if ( !glyph_index )
      {
        if ( script_class->standard_char2 )
        {
          standard_char = script_class->standard_char2;
          af_get_char_index( &metrics->root,
                             standard_char,
                             &glyph_index,
                             &y_offset );
          if ( !glyph_index )
          {
            if ( script_class->standard_char3 )
            {
              standard_char = script_class->standard_char3;
              af_get_char_index( &metrics->root,
                                 standard_char,
                                 &glyph_index,
                                 &y_offset );
              if ( !glyph_index )
                goto Exit;
            }
            else
              goto Exit;
          }
        }
        else
          goto Exit;
      }

      do { } while ( 0 )
                                               ;

      error = FT_Load_Glyph( face, glyph_index, ( 1L << 0 ) );
      if ( error || face->glyph->outline.n_points <= 0 )
        goto Exit;

      memset( dummy, 0, (FT_Offset)(sizeof ( *(dummy) )) );

      dummy->units_per_em = metrics->units_per_em;

      scaler->x_scale = 0x10000L;
      scaler->y_scale = 0x10000L;
      scaler->x_delta = 0;
      scaler->y_delta = 0;

      scaler->face = face;
      scaler->render_mode = FT_RENDER_MODE_NORMAL;
      scaler->flags = 0;

      af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );

      error = af_glyph_hints_reload( hints, &face->glyph->outline );
      if ( error )
        goto Exit;

      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_CJKAxis axis = &metrics->axis[dim];
        AF_AxisHints axhints = &hints->axis[dim];
        AF_Segment seg, limit, link;
        FT_UInt num_widths = 0;


        error = af_latin_hints_compute_segments( hints,
                                                 (AF_Dimension)dim );
        if ( error )
          goto Exit;

        af_latin_hints_link_segments( hints,
                                      0,
                                      ((void *)0),
                                      (AF_Dimension)dim );

        seg = axhints->segments;
        limit = seg + axhints->num_segments;

        for ( ; seg < limit; seg++ )
        {
          link = seg->link;


          if ( link && link->link == seg && link > seg )
          {
            FT_Pos dist;


            dist = seg->pos - link->pos;
            if ( dist < 0 )
              dist = -dist;

            if ( num_widths < 16 )
              axis->widths[num_widths++].org = dist;
          }
        }



        af_sort_and_quantize_widths( &num_widths, axis->widths,
                                     dummy->units_per_em / 100 );
        axis->width_count = num_widths;
      }

    Exit:
      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
      {
        AF_CJKAxis axis = &metrics->axis[dim];
        FT_Pos stdw;


        stdw = ( axis->width_count > 0 ) ? axis->widths[0].org
                                         : ( ( (50) * (FT_Long)( (AF_LatinMetrics)(metrics) )->units_per_em ) / 2048 );


        axis->edge_distance_threshold = stdw / 5;
        axis->standard_width = stdw;
        axis->extra_light = 0;
# 245 "../../../libs/freetype/src/autofit/afcjk.c"
      }
    }

    do { } while ( 0 );

    af_glyph_hints_done( hints );
  }




  static void
  af_cjk_metrics_init_blues( AF_CJKMetrics metrics,
                             FT_Face face )
  {
    FT_Pos fills[51];
    FT_Pos flats[51];

    FT_UInt num_fills;
    FT_UInt num_flats;

    FT_Bool fill;

    AF_CJKBlue blue;
    FT_Error error;
    AF_CJKAxis axis;
    FT_Outline outline;

    AF_StyleClass sc = metrics->root.style_class;

    AF_Blue_Stringset bss = sc->blue_stringset;
    const AF_Blue_StringRec* bs = &af_blue_stringsets[bss];






    do { } while ( 0 )

                       ;

    for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
    {
      const char* p = &af_blue_strings[bs->string];
      FT_Pos* blue_ref;
      FT_Pos* blue_shoot;


      if ( ( (bs)->properties & ( 1U << 1 ) ) )
        axis = &metrics->axis[AF_DIMENSION_HORZ];
      else
        axis = &metrics->axis[AF_DIMENSION_VERT];
# 317 "../../../libs/freetype/src/autofit/afcjk.c"
      num_fills = 0;
      num_flats = 0;

      fill = 1;
      do { } while ( 0 );

      while ( *p )
      {
        FT_ULong ch;
        FT_ULong glyph_index;
        FT_Long y_offset;
        FT_Pos best_pos;
        FT_Int best_point;
        FT_Vector* points;


        ch = (unsigned char)*p++; if ( ch >= 0x80 ) { FT_UInt len; if ( ch < 0xE0 ) { len = 1; ch &= 0x1F; } else if ( ch < 0xF0 ) { len = 2; ch &= 0x0F; } else { len = 3; ch &= 0x07; } for ( ; len > 0; len-- ) ch = ( ch << 6 ) | ( *p++ & 0x3F ); };


        if ( ch == '|' )
        {
          fill = 0;
          do { } while ( 0 );
          continue;
        }


        af_get_char_index( &metrics->root, ch, &glyph_index, &y_offset );
        if ( glyph_index == 0 )
        {
          do { } while ( 0 );
          continue;
        }

        error = FT_Load_Glyph( face, glyph_index, ( 1L << 0 ) );
        outline = face->glyph->outline;
        if ( error || outline.n_points <= 0 )
        {
          do { } while ( 0 );
          continue;
        }


        points = outline.points;
        best_point = -1;
        best_pos = 0;

        {
          FT_Int nn;
          FT_Int first = 0;
          FT_Int last = -1;


          for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )
          {
            FT_Int pp;


            last = outline.contours[nn];




            if ( last <= first )
              continue;

            if ( ( (bs)->properties & ( 1U << 1 ) ) )
            {
              if ( ( (bs)->properties & ( 1U << 0 ) ) )
              {
                for ( pp = first; pp <= last; pp++ )
                  if ( best_point < 0 || points[pp].x > best_pos )
                  {
                    best_point = pp;
                    best_pos = points[pp].x;
                  }
              }
              else
              {
                for ( pp = first; pp <= last; pp++ )
                  if ( best_point < 0 || points[pp].x < best_pos )
                  {
                    best_point = pp;
                    best_pos = points[pp].x;
                  }
              }
            }
            else
            {
              if ( ( (bs)->properties & ( 1U << 0 ) ) )
              {
                for ( pp = first; pp <= last; pp++ )
                  if ( best_point < 0 || points[pp].y > best_pos )
                  {
                    best_point = pp;
                    best_pos = points[pp].y;
                  }
              }
              else
              {
                for ( pp = first; pp <= last; pp++ )
                  if ( best_point < 0 || points[pp].y < best_pos )
                  {
                    best_point = pp;
                    best_pos = points[pp].y;
                  }
              }
            }
          }

          do { } while ( 0 );
        }

        if ( fill )
          fills[num_fills++] = best_pos;
        else
          flats[num_flats++] = best_pos;
      }

      if ( num_flats == 0 && num_fills == 0 )
      {




        do { } while ( 0 );
        continue;
      }




      af_sort_pos( num_fills, fills );
      af_sort_pos( num_flats, flats );

      blue = &axis->blues[axis->blue_count];
      blue_ref = &blue->ref.org;
      blue_shoot = &blue->shoot.org;

      axis->blue_count++;

      if ( num_flats == 0 )
      {
        *blue_ref =
        *blue_shoot = fills[num_fills / 2];
      }
      else if ( num_fills == 0 )
      {
        *blue_ref =
        *blue_shoot = flats[num_flats / 2];
      }
      else
      {
        *blue_ref = fills[num_fills / 2];
        *blue_shoot = flats[num_flats / 2];
      }



      if ( *blue_shoot != *blue_ref )
      {
        FT_Pos ref = *blue_ref;
        FT_Pos shoot = *blue_shoot;
        FT_Bool under_ref = ( (FT_Bool)( shoot < ref ) );



        if ( ( (bs)->properties & ( 1U << 0 ) ) ^ under_ref )
        {
          *blue_ref =
          *blue_shoot = ( shoot + ref ) / 2;

          do { } while ( 0 )
                                                ;
        }
      }

      blue->flags = 0;
      if ( ( (bs)->properties & ( 1U << 0 ) ) )
        blue->flags |= ( 1U << 1 );

      do { } while ( 0 )

                                           ;
    }

    do { } while ( 0 );

    return;
  }




  static void
  af_cjk_metrics_check_digits( AF_CJKMetrics metrics,
                               FT_Face face )
  {
    FT_UInt i;
    FT_Bool started = 0, same_width = 1;
    FT_Fixed advance, old_advance = 0;



    for ( i = 0x30; i <= 0x39; i++ )
    {
      FT_ULong glyph_index;
      FT_Long y_offset;


      af_get_char_index( &metrics->root, i, &glyph_index, &y_offset );
      if ( glyph_index == 0 )
        continue;

      if ( FT_Get_Advance( face, glyph_index,
                           ( 1L << 0 ) |
                           ( 1L << 1 ) |
                           ( 1L << 11 ),
                           &advance ) )
        continue;

      if ( started )
      {
        if ( advance != old_advance )
        {
          same_width = 0;
          break;
        }
      }
      else
      {
        old_advance = advance;
        started = 1;
      }
    }

    metrics->root.digits_have_same_width = same_width;
  }




  static FT_Error
  af_cjk_metrics_init( AF_CJKMetrics metrics,
                       FT_Face face )
  {
    FT_CharMap oldmap = face->charmap;


    metrics->units_per_em = face->units_per_EM;

    if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
    {
      af_cjk_metrics_init_widths( metrics, face );
      af_cjk_metrics_init_blues( metrics, face );
      af_cjk_metrics_check_digits( metrics, face );
    }

    FT_Set_Charmap( face, oldmap );
    return FT_Err_Ok;
  }





  static void
  af_cjk_metrics_scale_dim( AF_CJKMetrics metrics,
                            AF_Scaler scaler,
                            AF_Dimension dim )
  {
    FT_Fixed scale;
    FT_Pos delta;
    AF_CJKAxis axis;
    FT_UInt nn;


    if ( dim == AF_DIMENSION_HORZ )
    {
      scale = scaler->x_scale;
      delta = scaler->x_delta;
    }
    else
    {
      scale = scaler->y_scale;
      delta = scaler->y_delta;
    }

    axis = &metrics->axis[dim];

    if ( axis->org_scale == scale && axis->org_delta == delta )
      return;

    axis->org_scale = scale;
    axis->org_delta = delta;

    axis->scale = scale;
    axis->delta = delta;


    for ( nn = 0; nn < axis->blue_count; nn++ )
    {
      AF_CJKBlue blue = &axis->blues[nn];
      FT_Pos dist;


      blue->ref.cur = FT_MulFix_arm( (FT_Int32)(blue->ref.org), (FT_Int32)(scale) ) + delta;
      blue->ref.fit = blue->ref.cur;
      blue->shoot.cur = FT_MulFix_arm( (FT_Int32)(blue->shoot.org), (FT_Int32)(scale) ) + delta;
      blue->shoot.fit = blue->shoot.cur;
      blue->flags &= ~( 1U << 0 );


      dist = FT_MulFix_arm( (FT_Int32)(blue->ref.org - blue->shoot.org), (FT_Int32)(scale) );
      if ( dist <= 48 && dist >= -48 )
      {
        FT_Pos delta1, delta2;


        blue->ref.fit = ( ((blue->ref.cur) + 32) & ~(__typeof__ ((blue->ref.cur) + 32))63 );


        delta1 = FT_DivFix( blue->ref.fit, scale ) - blue->shoot.org;
        delta2 = delta1;
        if ( delta1 < 0 )
          delta2 = -delta2;

        delta2 = FT_MulFix_arm( (FT_Int32)(delta2), (FT_Int32)(scale) );

        do { } while ( 0 );
        if ( delta2 < 32 )
          delta2 = 0;




        else
          delta2 = ( ((delta2) + 32) & ~(__typeof__ ((delta2) + 32))63 );
        do { } while ( 0 );

        if ( delta1 < 0 )
          delta2 = -delta2;

        blue->shoot.fit = blue->ref.fit - delta2;

        do { } while ( 0 )





                                                                     ;

        blue->flags |= ( 1U << 0 );
      }
    }
  }




  static void
  af_cjk_metrics_scale( AF_CJKMetrics metrics,
                        AF_Scaler scaler )
  {


    metrics->root.scaler = *scaler;

    af_cjk_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
    af_cjk_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
  }





  static void
  af_cjk_get_standard_widths( AF_CJKMetrics metrics,
                              FT_Pos* stdHW,
                              FT_Pos* stdVW )
  {
    if ( stdHW )
      *stdHW = metrics->axis[AF_DIMENSION_VERT].standard_width;

    if ( stdVW )
      *stdVW = metrics->axis[AF_DIMENSION_HORZ].standard_width;
  }
# 718 "../../../libs/freetype/src/autofit/afcjk.c"
  static FT_Error
  af_cjk_hints_compute_segments( AF_GlyphHints hints,
                                 AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    AF_Segment segments = axis->segments;
    AF_Segment segment_limit = segments + axis->num_segments;
    FT_Error error;
    AF_Segment seg;


    error = af_latin_hints_compute_segments( hints, dim );
    if ( error )
      return error;



    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Point pt = seg->first;
      AF_Point last = seg->last;
      FT_UInt f0 = pt->flags & ( ( 1U << 0 ) | ( 1U << 1 ) );
      FT_UInt f1;


      seg->flags &= ~( 1U << 0 );

      for ( ; pt != last; f0 = f1 )
      {
        pt = pt->next;
        f1 = pt->flags & ( ( 1U << 0 ) | ( 1U << 1 ) );

        if ( !f0 && !f1 )
          break;

        if ( pt == last )
          seg->flags |= ( 1U << 0 );
      }
    }

    return FT_Err_Ok;
  }


  static void
  af_cjk_hints_link_segments( AF_GlyphHints hints,
                              AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    AF_Segment segments = axis->segments;
    AF_Segment segment_limit = segments + axis->num_segments;
    AF_Direction major_dir = axis->major_dir;
    AF_Segment seg1, seg2;
    FT_Pos len_threshold;
    FT_Pos dist_threshold;


    len_threshold = ( ( (8) * (FT_Long)( (AF_LatinMetrics)(hints->metrics) )->units_per_em ) / 2048 );

    dist_threshold = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
                                                  : hints->y_scale;
    dist_threshold = FT_DivFix( 64 * 3, dist_threshold );


    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
    {
      if ( seg1->dir != major_dir )
        continue;

      for ( seg2 = segments; seg2 < segment_limit; seg2++ )
        if ( seg2 != seg1 && seg1->dir + seg2->dir == 0 )
        {
          FT_Pos dist = seg2->pos - seg1->pos;


          if ( dist < 0 )
            continue;

          {
            FT_Pos min = seg1->min_coord;
            FT_Pos max = seg1->max_coord;
            FT_Pos len;


            if ( min < seg2->min_coord )
              min = seg2->min_coord;

            if ( max > seg2->max_coord )
              max = seg2->max_coord;

            len = max - min;
            if ( len >= len_threshold )
            {
              if ( dist * 8 < seg1->score * 9 &&
                   ( dist * 8 < seg1->score * 7 || seg1->len < len ) )
              {
                seg1->score = dist;
                seg1->len = len;
                seg1->link = seg2;
              }

              if ( dist * 8 < seg2->score * 9 &&
                   ( dist * 8 < seg2->score * 7 || seg2->len < len ) )
              {
                seg2->score = dist;
                seg2->len = len;
                seg2->link = seg1;
              }
            }
          }
        }
    }
# 840 "../../../libs/freetype/src/autofit/afcjk.c"
    {
      AF_Segment link1, link2;


      for ( seg1 = segments; seg1 < segment_limit; seg1++ )
      {
        link1 = seg1->link;
        if ( !link1 || link1->link != seg1 || link1->pos <= seg1->pos )
          continue;

        if ( seg1->score >= dist_threshold )
          continue;

        for ( seg2 = segments; seg2 < segment_limit; seg2++ )
        {
          if ( seg2->pos > seg1->pos || seg1 == seg2 )
            continue;

          link2 = seg2->link;
          if ( !link2 || link2->link != seg2 || link2->pos < link1->pos )
            continue;

          if ( seg1->pos == seg2->pos && link1->pos == link2->pos )
            continue;

          if ( seg2->score <= seg1->score || seg1->score * 4 <= seg2->score )
            continue;



          if ( seg1->len >= seg2->len * 3 )
          {
            AF_Segment seg;


            for ( seg = segments; seg < segment_limit; seg++ )
            {
              AF_Segment link = seg->link;


              if ( link == seg2 )
              {
                seg->link = ((void *)0);
                seg->serif = link1;
              }
              else if ( link == link2 )
              {
                seg->link = ((void *)0);
                seg->serif = seg1;
              }
            }
          }
          else
          {
            seg1->link = link1->link = ((void *)0);

            break;
          }
        }
      }
    }

    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
    {
      seg2 = seg1->link;

      if ( seg2 )
      {
        seg2->num_linked++;
        if ( seg2->link != seg1 )
        {
          seg1->link = ((void *)0);

          if ( seg2->score < dist_threshold || seg1->score < seg2->score * 4 )
            seg1->serif = seg2->link;
          else
            seg2->num_linked--;
        }
      }
    }
  }


  static FT_Error
  af_cjk_hints_compute_edges( AF_GlyphHints hints,
                              AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    FT_Error error = FT_Err_Ok;
    FT_Memory memory = hints->memory;
    AF_CJKAxis laxis = &((AF_CJKMetrics)hints->metrics)->axis[dim];

    AF_Segment segments = axis->segments;
    AF_Segment segment_limit = segments + axis->num_segments;
    AF_Segment seg;

    FT_Fixed scale;
    FT_Pos edge_distance_threshold;


    axis->num_edges = 0;

    scale = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
                                         : hints->y_scale;
# 961 "../../../libs/freetype/src/autofit/afcjk.c"
    edge_distance_threshold = FT_MulFix_arm( (FT_Int32)(laxis->edge_distance_threshold), (FT_Int32)(scale) )
                                                ;
    if ( edge_distance_threshold > 64 / 4 )
      edge_distance_threshold = FT_DivFix( 64 / 4, scale );
    else
      edge_distance_threshold = laxis->edge_distance_threshold;

    for ( seg = segments; seg < segment_limit; seg++ )
    {
      AF_Edge found = ((void *)0);
      FT_Pos best = 0xFFFFU;
      FT_Int ee;



      for ( ee = 0; ee < axis->num_edges; ee++ )
      {
        AF_Edge edge = axis->edges + ee;
        FT_Pos dist;


        if ( edge->dir != seg->dir )
          continue;

        dist = seg->pos - edge->fpos;
        if ( dist < 0 )
          dist = -dist;

        if ( dist < edge_distance_threshold && dist < best )
        {
          AF_Segment link = seg->link;




          if ( link )
          {
            AF_Segment seg1 = edge->first;
            FT_Pos dist2 = 0;


            do
            {
              AF_Segment link1 = seg1->link;


              if ( link1 )
              {
                dist2 = ( ( (link)->pos > (link1)->pos ) ? (link)->pos - (link1)->pos : (link1)->pos - (link)->pos );
                if ( dist2 >= edge_distance_threshold )
                  break;
              }

            } while ( ( seg1 = seg1->edge_next ) != edge->first );

            if ( dist2 >= edge_distance_threshold )
              continue;
          }

          best = dist;
          found = edge;
        }
      }

      if ( !found )
      {
        AF_Edge edge;




        error = af_axis_hints_new_edge( axis, seg->pos,
                                        (AF_Direction)seg->dir,
                                        memory, &edge );
        if ( error )
          goto Exit;


        memset( edge, 0, (FT_Offset)(sizeof ( *(edge) )) );

        edge->first = seg;
        edge->last = seg;
        edge->dir = seg->dir;
        edge->fpos = seg->pos;
        edge->opos = FT_MulFix_arm( (FT_Int32)(seg->pos), (FT_Int32)(scale) );
        edge->pos = edge->opos;
        seg->edge_next = seg;
      }
      else
      {


        seg->edge_next = found->first;
        found->last->edge_next = seg;
        found->last = seg;
      }
    }
# 1079 "../../../libs/freetype/src/autofit/afcjk.c"
    {
      AF_Edge edges = axis->edges;
      AF_Edge edge_limit = edges + axis->num_edges;
      AF_Edge edge;


      for ( edge = edges; edge < edge_limit; edge++ )
      {
        seg = edge->first;
        if ( seg )
          do
          {
            seg->edge = edge;
            seg = seg->edge_next;

          } while ( seg != edge->first );
      }


      for ( edge = edges; edge < edge_limit; edge++ )
      {
        FT_Int is_round = 0;
        FT_Int is_straight = 0;


        seg = edge->first;

        do
        {
          FT_Bool is_serif;



          if ( seg->flags & ( 1U << 0 ) )
            is_round++;
          else
            is_straight++;



          is_serif = (FT_Bool)( seg->serif && seg->serif->edge != edge );

          if ( seg->link || is_serif )
          {
            AF_Edge edge2;
            AF_Segment seg2;


            edge2 = edge->link;
            seg2 = seg->link;

            if ( is_serif )
            {
              seg2 = seg->serif;
              edge2 = edge->serif;
            }

            if ( edge2 )
            {
              FT_Pos edge_delta;
              FT_Pos seg_delta;


              edge_delta = edge->fpos - edge2->fpos;
              if ( edge_delta < 0 )
                edge_delta = -edge_delta;

              seg_delta = ( ( (seg)->pos > (seg2)->pos ) ? (seg)->pos - (seg2)->pos : (seg2)->pos - (seg)->pos );

              if ( seg_delta < edge_delta )
                edge2 = seg2->edge;
            }
            else
              edge2 = seg2->edge;

            if ( is_serif )
            {
              edge->serif = edge2;
              edge2->flags |= ( 1U << 1 );
            }
            else
              edge->link = edge2;
          }

          seg = seg->edge_next;

        } while ( seg != edge->first );


        edge->flags = 0;

        if ( is_round > 0 && is_round >= is_straight )
          edge->flags |= ( 1U << 0 );





        if ( edge->serif && edge->link )
          edge->serif = ((void *)0);
      }
    }

  Exit:
    return error;
  }




  static FT_Error
  af_cjk_hints_detect_features( AF_GlyphHints hints,
                                AF_Dimension dim )
  {
    FT_Error error;


    error = af_cjk_hints_compute_segments( hints, dim );
    if ( !error )
    {
      af_cjk_hints_link_segments( hints, dim );

      error = af_cjk_hints_compute_edges( hints, dim );
    }
    return error;
  }




  static void
  af_cjk_hints_compute_blue_edges( AF_GlyphHints hints,
                                   AF_CJKMetrics metrics,
                                   AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    AF_Edge edge = axis->edges;
    AF_Edge edge_limit = edge + axis->num_edges;
    AF_CJKAxis cjk = &metrics->axis[dim];
    FT_Fixed scale = cjk->scale;
    FT_Pos best_dist0;



    best_dist0 = FT_MulFix_arm( (FT_Int32)(metrics->units_per_em / 40), (FT_Int32)(scale) );

    if ( best_dist0 > 64 / 2 )
      best_dist0 = 64 / 2;
# 1235 "../../../libs/freetype/src/autofit/afcjk.c"
    for ( ; edge < edge_limit; edge++ )
    {
      FT_UInt bb;
      AF_Width best_blue = ((void *)0);
      FT_Pos best_dist = best_dist0;


      for ( bb = 0; bb < cjk->blue_count; bb++ )
      {
        AF_CJKBlue blue = cjk->blues + bb;
        FT_Bool is_top_right_blue, is_major_dir;



        if ( !( blue->flags & ( 1U << 0 ) ) )
          continue;





        is_top_right_blue =
          (FT_Byte)( ( blue->flags & ( 1U << 1 ) ) != 0 );
        is_major_dir =
          ( (FT_Bool)( edge->dir == axis->major_dir ) );




        if ( is_top_right_blue ^ is_major_dir )
        {
          FT_Pos dist;
          AF_Width compare;



          if ( ( (edge->fpos - blue->ref.org) < 0 ? -(edge->fpos - blue->ref.org) : (edge->fpos - blue->ref.org) ) >
               ( (edge->fpos - blue->shoot.org) < 0 ? -(edge->fpos - blue->shoot.org) : (edge->fpos - blue->shoot.org) ) )
            compare = &blue->shoot;
          else
            compare = &blue->ref;

          dist = edge->fpos - compare->org;
          if ( dist < 0 )
            dist = -dist;

          dist = FT_MulFix_arm( (FT_Int32)(dist), (FT_Int32)(scale) );
          if ( dist < best_dist )
          {
            best_dist = dist;
            best_blue = compare;
          }
        }
      }

      if ( best_blue )
        edge->blue_edge = best_blue;
    }
  }




  static FT_Error
  af_cjk_hints_init( AF_GlyphHints hints,
                     AF_CJKMetrics metrics )
  {
    FT_Render_Mode mode;
    FT_UInt32 scaler_flags, other_flags;


    af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );





    hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
    hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
    hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
    hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;


    mode = metrics->root.scaler.render_mode;






    scaler_flags = hints->scaler_flags;
    other_flags = 0;





    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
      other_flags |= ( 1U << 0 );





    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
      other_flags |= ( 1U << 1 );




    if ( mode != FT_RENDER_MODE_LIGHT )
      other_flags |= ( 1U << 2 );

    if ( mode == FT_RENDER_MODE_MONO )
      other_flags |= ( 1U << 3 );

    scaler_flags |= 4U;







    hints->scaler_flags = scaler_flags;
    hints->other_flags = other_flags;

    return FT_Err_Ok;
  }
# 1377 "../../../libs/freetype/src/autofit/afcjk.c"
  static FT_Pos
  af_cjk_snap_width( AF_Width widths,
                     FT_UInt count,
                     FT_Pos width )
  {
    FT_UInt n;
    FT_Pos best = 64 + 32 + 2;
    FT_Pos reference = width;
    FT_Pos scaled;


    for ( n = 0; n < count; n++ )
    {
      FT_Pos w;
      FT_Pos dist;


      w = widths[n].cur;
      dist = width - w;
      if ( dist < 0 )
        dist = -dist;
      if ( dist < best )
      {
        best = dist;
        reference = w;
      }
    }

    scaled = ( ((reference) + 32) & ~(__typeof__ ((reference) + 32))63 );

    if ( width >= reference )
    {
      if ( width < scaled + 48 )
        width = reference;
    }
    else
    {
      if ( width > scaled - 48 )
        width = reference;
    }

    return width;
  }






  static FT_Pos
  af_cjk_compute_stem_width( AF_GlyphHints hints,
                             AF_Dimension dim,
                             FT_Pos width,
                             FT_UInt base_flags,
                             FT_UInt stem_flags )
  {
    AF_CJKMetrics metrics = (AF_CJKMetrics)hints->metrics;
    AF_CJKAxis axis = &metrics->axis[dim];
    FT_Pos dist = width;
    FT_Int sign = 0;
    FT_Bool vertical = ( (FT_Bool)( dim == AF_DIMENSION_VERT ) );

    ( (base_flags) = (base_flags) );
    ( (stem_flags) = (stem_flags) );


    if ( !( (hints)->other_flags & (( 1U << 2 )) ) )
      return width;

    if ( dist < 0 )
    {
      dist = -width;
      sign = 1;
    }

    if ( ( vertical && !( (hints)->other_flags & (( 1U << 1 )) ) ) ||
         ( !vertical && !( (hints)->other_flags & (( 1U << 0 )) ) ) )
    {


      if ( axis->width_count > 0 )
      {
        if ( ( (dist - axis->widths[0].cur) < 0 ? -(dist - axis->widths[0].cur) : (dist - axis->widths[0].cur) ) < 40 )
        {
          dist = axis->widths[0].cur;
          if ( dist < 48 )
            dist = 48;

          goto Done_Width;
        }
      }

      if ( dist < 54 )
        dist += ( 54 - dist ) / 2 ;
      else if ( dist < 3 * 64 )
      {
        FT_Pos delta;


        delta = dist & 63;
        dist &= -64;

        if ( delta < 10 )
          dist += delta;
        else if ( delta < 22 )
          dist += 10;
        else if ( delta < 42 )
          dist += delta;
        else if ( delta < 54 )
          dist += 54;
        else
          dist += delta;
      }
    }
    else
    {


      dist = af_cjk_snap_width( axis->widths, axis->width_count, dist );

      if ( vertical )
      {



        if ( dist >= 64 )
          dist = ( dist + 16 ) & ~63;
        else
          dist = 64;
      }
      else
      {
        if ( ( (hints)->other_flags & (( 1U << 3 )) ) )
        {



          if ( dist < 64 )
            dist = 64;
          else
            dist = ( dist + 32 ) & ~63;
        }
        else
        {




          if ( dist < 48 )
            dist = ( dist + 64 ) >> 1;

          else if ( dist < 128 )
            dist = ( dist + 22 ) & ~63;
          else

            dist = ( dist + 32 ) & ~63;
        }
      }
    }

  Done_Width:
    if ( sign )
      dist = -dist;

    return dist;
  }




  static void
  af_cjk_align_linked_edge( AF_GlyphHints hints,
                            AF_Dimension dim,
                            AF_Edge base_edge,
                            AF_Edge stem_edge )
  {
    FT_Pos dist = stem_edge->opos - base_edge->opos;

    FT_Pos fitted_width = af_cjk_compute_stem_width( hints, dim, dist,
                                                      base_edge->flags,
                                                      stem_edge->flags );


    stem_edge->pos = base_edge->pos + fitted_width;

    do { } while ( 0 )



                                                   ;
  }





  static void
  af_cjk_align_serif_edge( AF_GlyphHints hints,
                           AF_Edge base,
                           AF_Edge serif )
  {
    ( (hints) = (hints) );

    serif->pos = base->pos + ( serif->opos - base->opos );
  }
# 1600 "../../../libs/freetype/src/autofit/afcjk.c"
  static FT_Pos
  af_hint_normal_stem( AF_GlyphHints hints,
                       AF_Edge edge,
                       AF_Edge edge2,
                       FT_Pos anchor,
                       AF_Dimension dim )
  {
    FT_Pos org_len, cur_len, org_center;
    FT_Pos cur_pos1, cur_pos2;
    FT_Pos d_off1, u_off1, d_off2, u_off2, delta;
    FT_Pos offset;
    FT_Pos threshold = 64;


    if ( !( (hints)->other_flags & (( 1U << 2 )) ) )
    {
      if ( ( edge->flags & ( 1U << 0 ) ) &&
           ( edge2->flags & ( 1U << 0 ) ) )
      {
        if ( dim == AF_DIMENSION_VERT )
          threshold = 64 - 9;
        else
          threshold = 64 - 15;
      }
      else
      {
        if ( dim == AF_DIMENSION_VERT )
          threshold = 64 - 9 / 3;
        else
          threshold = 64 - 15 / 3;
      }
    }

    org_len = edge2->opos - edge->opos;
    cur_len = af_cjk_compute_stem_width( hints, dim, org_len,
                                            edge->flags,
                                            edge2->flags );

    org_center = ( edge->opos + edge2->opos ) / 2 + anchor;
    cur_pos1 = org_center - cur_len / 2;
    cur_pos2 = cur_pos1 + cur_len;
    d_off1 = cur_pos1 - ( (cur_pos1) & ~(__typeof__ (cur_pos1))63 );
    d_off2 = cur_pos2 - ( (cur_pos2) & ~(__typeof__ (cur_pos2))63 );
    u_off1 = 64 - d_off1;
    u_off2 = 64 - d_off2;
    delta = 0;


    if ( d_off1 == 0 || d_off2 == 0 )
      goto Exit;

    if ( cur_len <= threshold )
    {
      if ( d_off2 < cur_len )
      {
        if ( u_off1 <= d_off2 )
          delta = u_off1;
        else
          delta = -d_off2;
      }

      goto Exit;
    }

    if ( threshold < 64 )
    {
      if ( d_off1 >= threshold || u_off1 >= threshold ||
           d_off2 >= threshold || u_off2 >= threshold )
        goto Exit;
    }

    offset = cur_len & 63;

    if ( offset < 32 )
    {
      if ( u_off1 <= offset || d_off2 <= offset )
        goto Exit;
    }
    else
      offset = 64 - threshold;

    d_off1 = threshold - u_off1;
    u_off1 = u_off1 - offset;
    u_off2 = threshold - d_off2;
    d_off2 = d_off2 - offset;

    if ( d_off1 <= u_off1 )
      u_off1 = -d_off1;

    if ( d_off2 <= u_off2 )
      u_off2 = -d_off2;

    if ( ( (u_off1) < 0 ? -(u_off1) : (u_off1) ) <= ( (u_off2) < 0 ? -(u_off2) : (u_off2) ) )
      delta = u_off1;
    else
      delta = u_off2;

  Exit:


    if ( !( (hints)->other_flags & (( 1U << 2 )) ) )
    {
      if ( delta > 14 )
        delta = 14;
      else if ( delta < -14 )
        delta = -14;
    }


    cur_pos1 += delta;

    if ( edge->opos < edge2->opos )
    {
      edge->pos = cur_pos1;
      edge2->pos = cur_pos1 + cur_len;
    }
    else
    {
      edge->pos = cur_pos1 + cur_len;
      edge2->pos = cur_pos1;
    }

    return delta;
  }




  static void
  af_cjk_hint_edges( AF_GlyphHints hints,
                     AF_Dimension dim )
  {
    AF_AxisHints axis = &hints->axis[dim];
    AF_Edge edges = axis->edges;
    AF_Edge edge_limit = edges + axis->num_edges;
    FT_PtrDist n_edges;
    AF_Edge edge;
    AF_Edge anchor = ((void *)0);
    FT_Pos delta = 0;
    FT_Int skipped = 0;
    FT_Bool has_last_stem = 0;
    FT_Pos last_stem_pos = 0;






    do { } while ( 0 )

                                                                     ;



    if ( 1 )
    {
      for ( edge = edges; edge < edge_limit; edge++ )
      {
        AF_Width blue;
        AF_Edge edge1, edge2;


        if ( edge->flags & ( 1U << 2 ) )
          continue;

        blue = edge->blue_edge;
        edge1 = ((void *)0);
        edge2 = edge->link;

        if ( blue )
        {
          edge1 = edge;
        }
        else if ( edge2 && edge2->blue_edge )
        {
          blue = edge2->blue_edge;
          edge1 = edge2;
          edge2 = edge;
        }

        if ( !edge1 )
          continue;
# 1792 "../../../libs/freetype/src/autofit/afcjk.c"
        edge1->pos = blue->fit;
        edge1->flags |= ( 1U << 2 );

        if ( edge2 && !edge2->blue_edge )
        {
          af_cjk_align_linked_edge( hints, dim, edge1, edge2 );
          edge2->flags |= ( 1U << 2 );




        }

        if ( !anchor )
          anchor = edge;
      }
    }


    for ( edge = edges; edge < edge_limit; edge++ )
    {
      AF_Edge edge2;


      if ( edge->flags & ( 1U << 2 ) )
        continue;


      edge2 = edge->link;
      if ( !edge2 )
      {
        skipped++;
        continue;
      }
# 1835 "../../../libs/freetype/src/autofit/afcjk.c"
      if ( has_last_stem &&
           ( edge->pos < last_stem_pos + 64 ||
             edge2->pos < last_stem_pos + 64 ) )
      {
        skipped++;
        continue;
      }




      if ( edge2->blue_edge )
      {
        do { } while ( 0 );

        af_cjk_align_linked_edge( hints, dim, edge2, edge );
        edge->flags |= ( 1U << 2 );





        continue;
      }

      if ( edge2 < edge )
      {
        af_cjk_align_linked_edge( hints, dim, edge2, edge );
        edge->flags |= ( 1U << 2 );
# 1873 "../../../libs/freetype/src/autofit/afcjk.c"
        has_last_stem = 1;
        last_stem_pos = edge->pos;
        continue;
      }

      if ( dim != AF_DIMENSION_VERT && !anchor )
      {
# 1951 "../../../libs/freetype/src/autofit/afcjk.c"
          delta = af_hint_normal_stem( hints, edge, edge2, 0,
                                       AF_DIMENSION_HORZ );
      }
      else
        af_hint_normal_stem( hints, edge, edge2, delta, dim );
# 1964 "../../../libs/freetype/src/autofit/afcjk.c"
      anchor = edge;
      edge->flags |= ( 1U << 2 );
      edge2->flags |= ( 1U << 2 );
      has_last_stem = 1;
      last_stem_pos = edge2->pos;
    }
# 1986 "../../../libs/freetype/src/autofit/afcjk.c"
    n_edges = edge_limit - edges;
    if ( dim == AF_DIMENSION_HORZ && ( n_edges == 6 || n_edges == 12 ) )
    {
      AF_Edge edge1, edge2, edge3;
      FT_Pos dist1, dist2, span;


      if ( n_edges == 6 )
      {
        edge1 = edges;
        edge2 = edges + 2;
        edge3 = edges + 4;
      }
      else
      {
        edge1 = edges + 1;
        edge2 = edges + 5;
        edge3 = edges + 9;
      }

      dist1 = edge2->opos - edge1->opos;
      dist2 = edge3->opos - edge2->opos;

      span = dist1 - dist2;
      if ( span < 0 )
        span = -span;

      if ( edge1->link == edge1 + 1 &&
           edge2->link == edge2 + 1 &&
           edge3->link == edge3 + 1 && span < 8 )
      {
        delta = edge3->pos - ( 2 * edge2->pos - edge1->pos );
        edge3->pos -= delta;
        if ( edge3->link )
          edge3->link->pos -= delta;


        if ( n_edges == 12 )
        {
          ( edges + 8 )->pos -= delta;
          ( edges + 11 )->pos -= delta;
        }

        edge3->flags |= ( 1U << 2 );
        if ( edge3->link )
          edge3->link->flags |= ( 1U << 2 );
      }
    }

    if ( !skipped )
      goto Exit;





    for ( edge = edges; edge < edge_limit; edge++ )
    {
      if ( edge->flags & ( 1U << 2 ) )
        continue;

      if ( edge->serif )
      {
        af_cjk_align_serif_edge( hints, edge->serif, edge );
        edge->flags |= ( 1U << 2 );
        skipped--;
      }
    }

    if ( !skipped )
      goto Exit;

    for ( edge = edges; edge < edge_limit; edge++ )
    {
      AF_Edge before, after;


      if ( edge->flags & ( 1U << 2 ) )
        continue;

      before = after = edge;

      while ( --before >= edges )
        if ( before->flags & ( 1U << 2 ) )
          break;

      while ( ++after < edge_limit )
        if ( after->flags & ( 1U << 2 ) )
          break;

      if ( before >= edges || after < edge_limit )
      {
        if ( before < edges )
          af_cjk_align_serif_edge( hints, after, edge );
        else if ( after >= edge_limit )
          af_cjk_align_serif_edge( hints, before, edge );
        else
        {
          if ( after->fpos == before->fpos )
            edge->pos = before->pos;
          else
            edge->pos = before->pos +
                        FT_MulDiv( edge->fpos - before->fpos,
                                   after->pos - before->pos,
                                   after->fpos - before->fpos );
        }
      }
    }

  Exit:







    return;
  }


  static void
  af_cjk_align_edge_points( AF_GlyphHints hints,
                            AF_Dimension dim )
  {
    AF_AxisHints axis = & hints->axis[dim];
    AF_Edge edges = axis->edges;
    AF_Edge edge_limit = edges + axis->num_edges;
    AF_Edge edge;
    FT_Bool snapping;


    snapping = ( (FT_Bool)( ( dim == AF_DIMENSION_HORZ && ( (hints)->other_flags & (( 1U << 0 )) ) ) || ( dim == AF_DIMENSION_VERT && ( (hints)->other_flags & (( 1U << 1 )) ) ) ) )


                                                                   ;

    for ( edge = edges; edge < edge_limit; edge++ )
    {


      AF_Segment seg = edge->first;


      if ( snapping )
      {
        do
        {
          AF_Point point = seg->first;


          for (;;)
          {
            if ( dim == AF_DIMENSION_HORZ )
            {
              point->x = edge->pos;
              point->flags |= ( 1U << 2 );
            }
            else
            {
              point->y = edge->pos;
              point->flags |= ( 1U << 3 );
            }

            if ( point == seg->last )
              break;

            point = point->next;
          }

          seg = seg->edge_next;

        } while ( seg != edge->first );
      }
      else
      {
        FT_Pos delta = edge->pos - edge->opos;


        do
        {
          AF_Point point = seg->first;


          for (;;)
          {
            if ( dim == AF_DIMENSION_HORZ )
            {
              point->x += delta;
              point->flags |= ( 1U << 2 );
            }
            else
            {
              point->y += delta;
              point->flags |= ( 1U << 3 );
            }

            if ( point == seg->last )
              break;

            point = point->next;
          }

          seg = seg->edge_next;

        } while ( seg != edge->first );
      }
    }
  }




  static FT_Error
  af_cjk_hints_apply( FT_UInt glyph_index,
                      AF_GlyphHints hints,
                      FT_Outline* outline,
                      AF_CJKMetrics metrics )
  {
    FT_Error error;
    int dim;

    ( (metrics) = (metrics) );
    ( (glyph_index) = (glyph_index) );


    error = af_glyph_hints_reload( hints, outline );
    if ( error )
      goto Exit;







    if ( !( (hints)->scaler_flags & (1U) ) )

    {
      error = af_cjk_hints_detect_features( hints, AF_DIMENSION_HORZ );
      if ( error )
        goto Exit;

      af_cjk_hints_compute_blue_edges( hints, metrics, AF_DIMENSION_HORZ );
    }

    if ( !( (hints)->scaler_flags & (2U) ) )
    {
      error = af_cjk_hints_detect_features( hints, AF_DIMENSION_VERT );
      if ( error )
        goto Exit;

      af_cjk_hints_compute_blue_edges( hints, metrics, AF_DIMENSION_VERT );
    }


    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
    {
      if ( ( dim == AF_DIMENSION_HORZ && !( (hints)->scaler_flags & (1U) ) ) ||
           ( dim == AF_DIMENSION_VERT && !( (hints)->scaler_flags & (2U) ) ) )
      {
# 2266 "../../../libs/freetype/src/autofit/afcjk.c"
        af_cjk_hint_edges( hints, (AF_Dimension)dim );
        af_cjk_align_edge_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
      }
    }

    af_glyph_hints_save( hints, outline );

  Exit:
    return error;
  }
# 2289 "../../../libs/freetype/src/autofit/afcjk.c"
  const AF_WritingSystemClassRec af_cjk_writing_system_class = { AF_WRITING_SYSTEM_CJK, sizeof ( AF_CJKMetricsRec ), (AF_WritingSystem_InitMetricsFunc) af_cjk_metrics_init, (AF_WritingSystem_ScaleMetricsFunc)af_cjk_metrics_scale, (AF_WritingSystem_DoneMetricsFunc) ((void *)0), (AF_WritingSystem_GetStdWidthsFunc)af_cjk_get_standard_widths, (AF_WritingSystem_InitHintsFunc) af_cjk_hints_init, (AF_WritingSystem_ApplyHintsFunc) af_cjk_hints_apply };
# 35 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afindic.c" 1
# 35 "../../../libs/freetype/src/autofit/afindic.c"
  static FT_Error
  af_indic_metrics_init( AF_CJKMetrics metrics,
                         FT_Face face )
  {

    FT_CharMap oldmap = face->charmap;


    metrics->units_per_em = face->units_per_EM;

    if ( FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
      face->charmap = ((void *)0);
    else
    {
      af_cjk_metrics_init_widths( metrics, face );




      af_cjk_metrics_check_digits( metrics, face );
    }

    FT_Set_Charmap( face, oldmap );

    return FT_Err_Ok;
  }


  static void
  af_indic_metrics_scale( AF_CJKMetrics metrics,
                          AF_Scaler scaler )
  {

    af_cjk_metrics_scale( metrics, scaler );
  }


  static FT_Error
  af_indic_hints_init( AF_GlyphHints hints,
                       AF_CJKMetrics metrics )
  {

    return af_cjk_hints_init( hints, metrics );
  }


  static FT_Error
  af_indic_hints_apply( FT_UInt glyph_index,
                        AF_GlyphHints hints,
                        FT_Outline* outline,
                        AF_CJKMetrics metrics )
  {

    return af_cjk_hints_apply( glyph_index, hints, outline, metrics );
  }





  static void
  af_indic_get_standard_widths( AF_CJKMetrics metrics,
                                FT_Pos* stdHW,
                                FT_Pos* stdVW )
  {
    if ( stdHW )
      *stdHW = metrics->axis[AF_DIMENSION_VERT].standard_width;

    if ( stdVW )
      *stdVW = metrics->axis[AF_DIMENSION_HORZ].standard_width;
  }
# 117 "../../../libs/freetype/src/autofit/afindic.c"
  const AF_WritingSystemClassRec af_indic_writing_system_class = { AF_WRITING_SYSTEM_INDIC, sizeof ( AF_CJKMetricsRec ), (AF_WritingSystem_InitMetricsFunc) af_indic_metrics_init, (AF_WritingSystem_ScaleMetricsFunc)af_indic_metrics_scale, (AF_WritingSystem_DoneMetricsFunc) ((void *)0), (AF_WritingSystem_GetStdWidthsFunc)af_indic_get_standard_widths, (AF_WritingSystem_InitHintsFunc) af_indic_hints_init, (AF_WritingSystem_ApplyHintsFunc) af_indic_hints_apply };
# 36 "../../../libs/freetype/src/autofit/autofit.c" 2

# 1 "../../../libs/freetype/src/autofit/hbshim.c" 1
# 69 "../../../libs/freetype/src/autofit/hbshim.c"
# 1 "../../../libs/freetype/src/autofit/afcover.h" 1
# 35 "../../../libs/freetype/src/autofit/afcover.h"
  static const hb_tag_t petite_capitals_from_capitals_coverage[] = { ((hb_tag_t)((((uint8_t)('c'))<<24)|(((uint8_t)('2'))<<16)|(((uint8_t)('c'))<<8)|((uint8_t)('p')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t small_capitals_from_capitals_coverage[] = { ((hb_tag_t)((((uint8_t)('c'))<<24)|(((uint8_t)('2'))<<16)|(((uint8_t)('s'))<<8)|((uint8_t)('c')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };
# 66 "../../../libs/freetype/src/autofit/afcover.h"
  static const hb_tag_t ordinals_coverage[] = { ((hb_tag_t)((((uint8_t)('o'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('d'))<<8)|((uint8_t)('n')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t petite_capitals_coverage[] = { ((hb_tag_t)((((uint8_t)('p'))<<24)|(((uint8_t)('c'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('p')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t ruby_coverage[] = { ((hb_tag_t)((((uint8_t)('r'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('y')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t scientific_inferiors_coverage[] = { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('f')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t small_capitals_coverage[] = { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('m'))<<16)|(((uint8_t)('c'))<<8)|((uint8_t)('p')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t subscript_coverage[] = { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('s')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t superscript_coverage[] = { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('p'))<<8)|((uint8_t)('s')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };



  static const hb_tag_t titling_coverage[] = { ((hb_tag_t)((((uint8_t)('t'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('t'))<<8)|((uint8_t)('l')))), ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };
# 70 "../../../libs/freetype/src/autofit/hbshim.c" 2
# 79 "../../../libs/freetype/src/autofit/hbshim.c"
  static const hb_tag_t* coverages[] =
  {
# 1 "../../../libs/freetype/src/autofit/afcover.h" 1
# 35 "../../../libs/freetype/src/autofit/afcover.h"
  petite_capitals_from_capitals_coverage,



  small_capitals_from_capitals_coverage,
# 66 "../../../libs/freetype/src/autofit/afcover.h"
  ordinals_coverage,



  petite_capitals_coverage,



  ruby_coverage,



  scientific_inferiors_coverage,



  small_capitals_coverage,



  subscript_coverage,



  superscript_coverage,



  titling_coverage,
# 82 "../../../libs/freetype/src/autofit/hbshim.c" 2

    ((void *)0)
  };







  static const hb_script_t scripts[] =
  {
# 1 "../../../libs/freetype/src/autofit/afscript.h" 1
# 33 "../../../libs/freetype/src/autofit/afscript.h"
  HB_SCRIPT_ARABIC,




  HB_SCRIPT_CYRILLIC,




  HB_SCRIPT_DEVANAGARI,




  HB_SCRIPT_GREEK,




  HB_SCRIPT_HEBREW,





  HB_SCRIPT_LAO,




  HB_SCRIPT_LATIN,




  HB_SCRIPT_INVALID,




  HB_SCRIPT_INVALID,




  HB_SCRIPT_INVALID,





  HB_SCRIPT_TELUGU,




  HB_SCRIPT_THAI,






  HB_SCRIPT_BENGALI,




  HB_SCRIPT_GUJARATI,




  HB_SCRIPT_GURMUKHI,




  HB_SCRIPT_KANNADA,




  HB_SCRIPT_LIMBU,




  HB_SCRIPT_MALAYALAM,




  HB_SCRIPT_ORIYA,




  HB_SCRIPT_SINHALA,




  HB_SCRIPT_SUNDANESE,




  HB_SCRIPT_SYLOTI_NAGRI,




  HB_SCRIPT_TAMIL,




  HB_SCRIPT_TIBETAN,
# 161 "../../../libs/freetype/src/autofit/afscript.h"
  HB_SCRIPT_HAN,
# 95 "../../../libs/freetype/src/autofit/hbshim.c" 2
  };


  FT_Error
  af_get_coverage( AF_FaceGlobals globals,
                   AF_StyleClass style_class,
                   FT_UShort* gstyles )
  {
    hb_face_t* face;

    hb_set_t* gsub_lookups;
    hb_set_t* gsub_glyphs;
    hb_set_t* gpos_lookups;
    hb_set_t* gpos_glyphs;

    hb_script_t script;
    const hb_tag_t* coverage_tags;
    hb_tag_t script_tags[] = { ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))),
                                       ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))),
                                       ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))),
                                       ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) };

    hb_codepoint_t idx;





    if ( !globals || !style_class || !gstyles )
      return AF_Err_Invalid_Argument;

    face = hb_font_get_face( globals->hb_font );

    gsub_lookups = hb_set_create();
    gsub_glyphs = hb_set_create();
    gpos_lookups = hb_set_create();
    gpos_glyphs = hb_set_create();

    coverage_tags = coverages[style_class->coverage];
    script = scripts[style_class->script];




    hb_ot_tags_from_script( script,
                            &script_tags[0],
                            &script_tags[1] );




    if ( style_class->script == globals->module->default_script &&
         style_class->coverage == AF_COVERAGE_DEFAULT )
    {
      if ( script_tags[0] == ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) )
        script_tags[0] = ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('F'))<<16)|(((uint8_t)('L'))<<8)|((uint8_t)('T'))));
      else
      {
        if ( script_tags[1] == ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0)))) )
          script_tags[1] = ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('F'))<<16)|(((uint8_t)('L'))<<8)|((uint8_t)('T'))));
        else if ( script_tags[1] != ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('F'))<<16)|(((uint8_t)('L'))<<8)|((uint8_t)('T')))) )
          script_tags[2] = ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('F'))<<16)|(((uint8_t)('L'))<<8)|((uint8_t)('T'))));
      }
    }
    else
    {
      if ( script_tags[1] == ((hb_tag_t)((((uint8_t)('D'))<<24)|(((uint8_t)('F'))<<16)|(((uint8_t)('L'))<<8)|((uint8_t)('T')))) )
        script_tags[1] = ((hb_tag_t)((((uint8_t)(0))<<24)|(((uint8_t)(0))<<16)|(((uint8_t)(0))<<8)|((uint8_t)(0))));
    }

    hb_ot_layout_collect_lookups( face,
                                  ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('S'))<<16)|(((uint8_t)('U'))<<8)|((uint8_t)('B')))),
                                  script_tags,
                                  ((void *)0),
                                  coverage_tags,
                                  gsub_lookups );

    if ( hb_set_is_empty( gsub_lookups ) )
      goto Exit;

    hb_ot_layout_collect_lookups( face,
                                  ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('P'))<<16)|(((uint8_t)('O'))<<8)|((uint8_t)('S')))),
                                  script_tags,
                                  ((void *)0),
                                  coverage_tags,
                                  gpos_lookups );

    do { } while ( 0 )

                                                     ;





    for ( idx = ((hb_codepoint_t) -1); hb_set_next( gsub_lookups, &idx ); )
    {






      hb_ot_layout_lookup_collect_glyphs( face,
                                          ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('S'))<<16)|(((uint8_t)('U'))<<8)|((uint8_t)('B')))),
                                          idx,
                                          ((void *)0),
                                          ((void *)0),
                                          ((void *)0),
                                          gsub_glyphs );
    }







    do { } while ( 0 )

                                                     ;





    for ( idx = ((hb_codepoint_t) -1); hb_set_next( gpos_lookups, &idx ); )
    {






      hb_ot_layout_lookup_collect_glyphs( face,
                                          ((hb_tag_t)((((uint8_t)('G'))<<24)|(((uint8_t)('P'))<<16)|(((uint8_t)('O'))<<8)|((uint8_t)('S')))),
                                          idx,
                                          ((void *)0),
                                          gpos_glyphs,
                                          ((void *)0),
                                          ((void *)0) );
    }
# 250 "../../../libs/freetype/src/autofit/hbshim.c"
    if ( style_class->coverage != AF_COVERAGE_DEFAULT )
    {
      AF_Blue_Stringset bss = style_class->blue_stringset;
      const AF_Blue_StringRec* bs = &af_blue_stringsets[bss];

      FT_Bool found = 0;


      for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
      {
        const char* p = &af_blue_strings[bs->string];


        while ( *p )
        {
          hb_codepoint_t ch;


          ch = (unsigned char)*p++; if ( ch >= 0x80 ) { FT_UInt len; if ( ch < 0xE0 ) { len = 1; ch &= 0x1F; } else if ( ch < 0xF0 ) { len = 2; ch &= 0x0F; } else { len = 3; ch &= 0x07; } for ( ; len > 0; len-- ) ch = ( ch << 6 ) | ( *p++ & 0x3F ); };

          for ( idx = ((hb_codepoint_t) -1); hb_set_next( gsub_lookups,
                                                         &idx ); )
          {
            hb_codepoint_t gidx = FT_Get_Char_Index( globals->face, ch );


            if ( hb_ot_layout_lookup_would_substitute( face, idx,
                                                       &gidx, 1, 1 ) )
            {
              found = 1;
              break;
            }
          }
        }
      }

      if ( !found )
      {
        do { } while ( 0 );
        goto Exit;
      }
    }
# 340 "../../../libs/freetype/src/autofit/hbshim.c"
    if ( style_class->coverage != AF_COVERAGE_DEFAULT )
      hb_set_subtract( gsub_glyphs, gpos_glyphs );






    for ( idx = ((hb_codepoint_t) -1); hb_set_next( gsub_glyphs, &idx ); )
    {
# 362 "../../../libs/freetype/src/autofit/hbshim.c"
      if ( idx >= (hb_codepoint_t)globals->glyph_count )
        continue;

      if ( gstyles[idx] == 0x3FFF )
        gstyles[idx] = (FT_UShort)style_class->style;




    }
# 380 "../../../libs/freetype/src/autofit/hbshim.c"
  Exit:
    hb_set_destroy( gsub_lookups );
    hb_set_destroy( gsub_glyphs );
    hb_set_destroy( gpos_lookups );
    hb_set_destroy( gpos_glyphs );

    return FT_Err_Ok;
  }
# 403 "../../../libs/freetype/src/autofit/hbshim.c"
# 1 "../../../libs/freetype/src/autofit/afcover.h" 1
# 35 "../../../libs/freetype/src/autofit/afcover.h"
  static const hb_feature_t petite_capitals_from_capitals_feature[] = { { ((hb_tag_t)((((uint8_t)('c'))<<24)|(((uint8_t)('2'))<<16)|(((uint8_t)('c'))<<8)|((uint8_t)('p')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t small_capitals_from_capitals_feature[] = { { ((hb_tag_t)((((uint8_t)('c'))<<24)|(((uint8_t)('2'))<<16)|(((uint8_t)('s'))<<8)|((uint8_t)('c')))), 1, 0, (unsigned int)-1 } };
# 66 "../../../libs/freetype/src/autofit/afcover.h"
  static const hb_feature_t ordinals_feature[] = { { ((hb_tag_t)((((uint8_t)('o'))<<24)|(((uint8_t)('r'))<<16)|(((uint8_t)('d'))<<8)|((uint8_t)('n')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t petite_capitals_feature[] = { { ((hb_tag_t)((((uint8_t)('p'))<<24)|(((uint8_t)('c'))<<16)|(((uint8_t)('a'))<<8)|((uint8_t)('p')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t ruby_feature[] = { { ((hb_tag_t)((((uint8_t)('r'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('y')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t scientific_inferiors_feature[] = { { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('n'))<<8)|((uint8_t)('f')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t small_capitals_feature[] = { { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('m'))<<16)|(((uint8_t)('c'))<<8)|((uint8_t)('p')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t subscript_feature[] = { { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('b'))<<8)|((uint8_t)('s')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t superscript_feature[] = { { ((hb_tag_t)((((uint8_t)('s'))<<24)|(((uint8_t)('u'))<<16)|(((uint8_t)('p'))<<8)|((uint8_t)('s')))), 1, 0, (unsigned int)-1 } };



  static const hb_feature_t titling_feature[] = { { ((hb_tag_t)((((uint8_t)('t'))<<24)|(((uint8_t)('i'))<<16)|(((uint8_t)('t'))<<8)|((uint8_t)('l')))), 1, 0, (unsigned int)-1 } };
# 404 "../../../libs/freetype/src/autofit/hbshim.c" 2
# 413 "../../../libs/freetype/src/autofit/hbshim.c"
  static const hb_feature_t* features[] =
  {
# 1 "../../../libs/freetype/src/autofit/afcover.h" 1
# 35 "../../../libs/freetype/src/autofit/afcover.h"
  petite_capitals_from_capitals_feature,



  small_capitals_from_capitals_feature,
# 66 "../../../libs/freetype/src/autofit/afcover.h"
  ordinals_feature,



  petite_capitals_feature,



  ruby_feature,



  scientific_inferiors_feature,



  small_capitals_feature,



  subscript_feature,



  superscript_feature,



  titling_feature,
# 416 "../../../libs/freetype/src/autofit/hbshim.c" 2

    ((void *)0)
  };


  FT_Error
  af_get_char_index( AF_StyleMetrics metrics,
                     FT_ULong charcode,
                     FT_ULong *codepoint,
                     FT_Long *y_offset )
  {
    AF_StyleClass style_class;

    const hb_feature_t* feature;

    FT_ULong in_idx, out_idx;


    if ( !metrics )
      return AF_Err_Invalid_Argument;

    in_idx = FT_Get_Char_Index( metrics->globals->face, charcode );

    style_class = metrics->style_class;

    feature = features[style_class->coverage];

    if ( feature )
    {
      FT_Int upem = (FT_Int)metrics->globals->face->units_per_EM;

      hb_font_t* font = metrics->globals->hb_font;
      hb_buffer_t* buf = hb_buffer_create();

      uint32_t c = (uint32_t)charcode;

      hb_glyph_info_t* ginfo;
      hb_glyph_position_t* gpos;
      unsigned int gcount;



      hb_font_set_scale( font, upem, upem );


      hb_buffer_set_direction( buf, HB_DIRECTION_LTR );
      hb_buffer_set_script( buf, scripts[style_class->script] );


      hb_buffer_add_utf32( buf, &c, 1, 0, 1 );


      hb_shape( font, buf, feature, 1 );

      ginfo = hb_buffer_get_glyph_infos( buf, &gcount );
      gpos = hb_buffer_get_glyph_positions( buf, &gcount );

      out_idx = ginfo[0].codepoint;



      if ( in_idx == out_idx )
      {
        *codepoint = 0;
        *y_offset = 0;
      }
      else
      {
        *codepoint = out_idx;
        *y_offset = gpos[0].y_offset;
      }

      hb_buffer_destroy( buf );






    }
    else
    {
      *codepoint = in_idx;
      *y_offset = 0;
    }

    return FT_Err_Ok;
  }
# 38 "../../../libs/freetype/src/autofit/autofit.c" 2

# 1 "../../../libs/freetype/src/autofit/afloader.c" 1
# 20 "../../../libs/freetype/src/autofit/afloader.c"
# 1 "../../../libs/freetype/src/autofit/afloader.h" 1
# 27 "../../../libs/freetype/src/autofit/afloader.h"

# 37 "../../../libs/freetype/src/autofit/afloader.h"
  typedef struct AF_LoaderRec_
  {

    FT_Face face;
    AF_FaceGlobals globals;


    AF_GlyphHints hints;
    AF_StyleMetrics metrics;
    FT_Bool transformed;
    FT_Matrix trans_matrix;
    FT_Vector trans_delta;
    FT_Vector pp1;
    FT_Vector pp2;


  } AF_LoaderRec, *AF_Loader;


  static void
  af_loader_init( AF_Loader loader,
                  AF_GlyphHints hints );


  static FT_Error
  af_loader_reset( AF_Loader loader,
                   AF_Module module,
                   FT_Face face );


  static void
  af_loader_done( AF_Loader loader );


  static FT_Error
  af_loader_load_glyph( AF_Loader loader,
                        AF_Module module,
                        FT_Face face,
                        FT_UInt gindex,
                        FT_Int32 load_flags );

  static FT_Int32
  af_loader_compute_darkening( AF_Loader loader,
                               FT_Face face,
                               FT_Pos standard_width );





# 21 "../../../libs/freetype/src/autofit/afloader.c" 2
# 31 "../../../libs/freetype/src/autofit/afloader.c"
  static void
  af_loader_init( AF_Loader loader,
                  AF_GlyphHints hints )
  {
    memset( loader, 0, (FT_Offset)(sizeof ( *(loader) )) );

    loader->hints = hints;
  }




  static FT_Error
  af_loader_reset( AF_Loader loader,
                   AF_Module module,
                   FT_Face face )
  {
    FT_Error error = FT_Err_Ok;


    loader->face = face;
    loader->globals = (AF_FaceGlobals)face->autohint.data;

    if ( loader->globals == ((void *)0) )
    {
      error = af_face_globals_new( face, &loader->globals, module );
      if ( !error )
      {
        face->autohint.data =
          (FT_Pointer)loader->globals;
        face->autohint.finalizer =
          (FT_Generic_Finalizer)af_face_globals_free;
      }
    }

    return error;
  }




  static void
  af_loader_done( AF_Loader loader )
  {
    loader->face = ((void *)0);
    loader->globals = ((void *)0);
    loader->hints = ((void *)0);
  }
# 95 "../../../libs/freetype/src/autofit/afloader.c"
  static FT_Error
  af_loader_load_g( AF_Loader loader,
                    AF_Scaler scaler,
                    FT_UInt glyph_index,
                    FT_Int32 load_flags )
  {
    AF_Module module = loader->globals->module;

    FT_Error error;
    FT_Face face = loader->face;
    AF_StyleMetrics metrics = loader->metrics;
    AF_GlyphHints hints = loader->hints;
    FT_GlyphSlot slot = face->glyph;
    FT_Slot_Internal internal = slot->internal;
    FT_GlyphLoader gloader = internal->loader;
    FT_Int32 flags;


    flags = load_flags | ( 1L << 13 );
    error = FT_Load_Glyph( face, glyph_index, flags );
    if ( error )
      goto Exit;
# 138 "../../../libs/freetype/src/autofit/afloader.c"
    if ( !module->no_stem_darkening )
    {
      AF_FaceGlobals globals = loader->globals;
      AF_WritingSystemClass writing_system_class;

      FT_Pos stdVW = 0;
      FT_Pos stdHW = 0;

      FT_Bool size_changed = face->size->metrics.x_ppem
                                != globals->stem_darkening_for_ppem;

      FT_Fixed em_size = ( (FT_Fixed)( (FT_UInt32)(face->units_per_EM) << 16 ) );
      FT_Fixed em_ratio = FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(1000) << 16 ) ), em_size );

      FT_Matrix scale_down_matrix = { 0x10000L, 0, 0, 0x10000L };



      if ( !face->units_per_EM )
        goto After_Emboldening;






      writing_system_class =
        af_writing_system_classes[metrics->style_class->writing_system];

      if ( writing_system_class->style_metrics_getstdw )
        writing_system_class->style_metrics_getstdw( metrics,
                                                     &stdHW,
                                                     &stdVW );
      else
        goto After_Emboldening;


      if ( size_changed ||
           ( stdVW > 0 && stdVW != globals->standard_vertical_width ) )
      {
        FT_Fixed darken_by_font_units_x, darken_x;


        darken_by_font_units_x =
          ( (FT_Fixed)( (FT_UInt32)(af_loader_compute_darkening( loader, face, stdVW )) << 16 ) )

                                                               ;
        darken_x = FT_DivFix( FT_MulFix_arm( (FT_Int32)(darken_by_font_units_x), (FT_Int32)(face->size->metrics.x_scale) )
                                                                      ,
                              em_ratio );

        globals->standard_vertical_width = stdVW;
        globals->stem_darkening_for_ppem = face->size->metrics.x_ppem;
        globals->darken_x = ( (FT_Short)( ( (FT_UInt32)(darken_x) + 0x8000U ) >> 16 ) );
      }

      if ( size_changed ||
           ( stdHW > 0 && stdHW != globals->standard_horizontal_width ) )
      {
        FT_Fixed darken_by_font_units_y, darken_y;


        darken_by_font_units_y =
          ( (FT_Fixed)( (FT_UInt32)(af_loader_compute_darkening( loader, face, stdHW )) << 16 ) )

                                                               ;
        darken_y = FT_DivFix( FT_MulFix_arm( (FT_Int32)(darken_by_font_units_y), (FT_Int32)(face->size->metrics.y_scale) )
                                                                      ,
                              em_ratio );

        globals->standard_horizontal_width = stdHW;
        globals->stem_darkening_for_ppem = face->size->metrics.x_ppem;
        globals->darken_y = ( (FT_Short)( ( (FT_UInt32)(darken_y) + 0x8000U ) >> 16 ) );
# 230 "../../../libs/freetype/src/autofit/afloader.c"
        globals->scale_down_factor =
          FT_DivFix( em_size - ( darken_by_font_units_y + ( (FT_Fixed)( (FT_UInt32)(8) << 16 ) ) ),
                     em_size );
      }

      FT_Outline_EmboldenXY( &slot->outline,
                             globals->darken_x,
                             globals->darken_y );

      scale_down_matrix.yy = globals->scale_down_factor;
      FT_Outline_Transform( &slot->outline, &scale_down_matrix );
    }

  After_Emboldening:
    loader->transformed = internal->glyph_transformed;
    if ( loader->transformed )
    {
      FT_Matrix inverse;


      loader->trans_matrix = internal->glyph_matrix;
      loader->trans_delta = internal->glyph_delta;

      inverse = loader->trans_matrix;
      if ( !FT_Matrix_Invert( &inverse ) )
        FT_Vector_Transform( &loader->trans_delta, &inverse );
    }

    switch ( slot->format )
    {
    case FT_GLYPH_FORMAT_OUTLINE:

      if ( loader->transformed )
        FT_Outline_Translate( &slot->outline,
                              loader->trans_delta.x,
                              loader->trans_delta.y );



      loader->pp1.x = hints->x_delta;
      loader->pp1.y = hints->y_delta;
      loader->pp2.x = FT_MulFix_arm( (FT_Int32)(slot->metrics.horiAdvance), (FT_Int32)(hints->x_scale) )
                                                  + hints->x_delta;
      loader->pp2.y = hints->y_delta;


      if ( slot->outline.n_points == 0 )
        goto Hint_Metrics;



      {



        AF_StyleClass style_class = metrics->style_class;
        AF_WritingSystemClass writing_system_class =
          af_writing_system_classes[style_class->writing_system];


        if ( writing_system_class->style_hints_apply )
          writing_system_class->style_hints_apply( glyph_index,
                                                   hints,
                                                   &gloader->base.outline,
                                                   metrics );
      }



      if ( scaler->render_mode != FT_RENDER_MODE_LIGHT )
      {
        FT_Pos old_rsb, old_lsb, new_lsb;
        FT_Pos pp1x_uh, pp2x_uh;
        AF_AxisHints axis = &hints->axis[AF_DIMENSION_HORZ];
        AF_Edge edge1 = axis->edges;
        AF_Edge edge2 = edge1 +
                              axis->num_edges - 1;


        if ( axis->num_edges > 1 && !( (hints)->scaler_flags & (4U) ) )
        {
          old_rsb = loader->pp2.x - edge2->opos;
          old_lsb = edge1->opos;
          new_lsb = edge1->pos;




          pp1x_uh = new_lsb - old_lsb;
          pp2x_uh = edge2->pos + old_rsb;




          if ( old_lsb < 24 )
            pp1x_uh -= 8;

          if ( old_rsb < 24 )
            pp2x_uh += 8;

          loader->pp1.x = ( ((pp1x_uh) + 32) & ~(__typeof__ ((pp1x_uh) + 32))63 );
          loader->pp2.x = ( ((pp2x_uh) + 32) & ~(__typeof__ ((pp2x_uh) + 32))63 );

          if ( loader->pp1.x >= new_lsb && old_lsb > 0 )
            loader->pp1.x -= 64;

          if ( loader->pp2.x <= edge2->pos && old_rsb > 0 )
            loader->pp2.x += 64;

          slot->lsb_delta = loader->pp1.x - pp1x_uh;
          slot->rsb_delta = loader->pp2.x - pp2x_uh;
        }
        else
        {
          FT_Pos pp1x = loader->pp1.x;
          FT_Pos pp2x = loader->pp2.x;


          loader->pp1.x = ( ((pp1x) + 32) & ~(__typeof__ ((pp1x) + 32))63 );
          loader->pp2.x = ( ((pp2x) + 32) & ~(__typeof__ ((pp2x) + 32))63 );

          slot->lsb_delta = loader->pp1.x - pp1x;
          slot->rsb_delta = loader->pp2.x - pp2x;
        }
      }
      else
      {
        FT_Pos pp1x = loader->pp1.x;
        FT_Pos pp2x = loader->pp2.x;


        loader->pp1.x = ( ((pp1x + hints->xmin_delta) + 32) & ~(__typeof__ ((pp1x + hints->xmin_delta) + 32))63 );
        loader->pp2.x = ( ((pp2x + hints->xmax_delta) + 32) & ~(__typeof__ ((pp2x + hints->xmax_delta) + 32))63 );

        slot->lsb_delta = loader->pp1.x - pp1x;
        slot->rsb_delta = loader->pp2.x - pp2x;
      }

      break;

    default:

      error = AF_Err_Unimplemented_Feature;
    }

  Hint_Metrics:
    {
      FT_BBox bbox;
      FT_Vector vvector;


      vvector.x = slot->metrics.vertBearingX - slot->metrics.horiBearingX;
      vvector.y = slot->metrics.vertBearingY - slot->metrics.horiBearingY;
      vvector.x = FT_MulFix_arm( (FT_Int32)(vvector.x), (FT_Int32)(metrics->scaler.x_scale) );
      vvector.y = FT_MulFix_arm( (FT_Int32)(vvector.y), (FT_Int32)(metrics->scaler.y_scale) );


      if ( loader->transformed )
      {
        FT_Outline_Transform( &gloader->base.outline, &loader->trans_matrix );
        FT_Vector_Transform( &vvector, &loader->trans_matrix );
      }



      if ( loader->pp1.x )
        FT_Outline_Translate( &gloader->base.outline, -loader->pp1.x, 0 );

      FT_Outline_Get_CBox( &gloader->base.outline, &bbox );

      bbox.xMin = ( (bbox.xMin) & ~(__typeof__ (bbox.xMin))63 );
      bbox.yMin = ( (bbox.yMin) & ~(__typeof__ (bbox.yMin))63 );
      bbox.xMax = ( ((bbox.xMax) + 63) & ~(__typeof__ ((bbox.xMax) + 63))63 );
      bbox.yMax = ( ((bbox.yMax) + 63) & ~(__typeof__ ((bbox.yMax) + 63))63 );

      slot->metrics.width = bbox.xMax - bbox.xMin;
      slot->metrics.height = bbox.yMax - bbox.yMin;
      slot->metrics.horiBearingX = bbox.xMin;
      slot->metrics.horiBearingY = bbox.yMax;

      slot->metrics.vertBearingX = ( (bbox.xMin + vvector.x) & ~(__typeof__ (bbox.xMin + vvector.x))63 );
      slot->metrics.vertBearingY = ( (bbox.yMax + vvector.y) & ~(__typeof__ (bbox.yMax + vvector.y))63 );
# 423 "../../../libs/freetype/src/autofit/afloader.c"
      if ( scaler->render_mode != FT_RENDER_MODE_LIGHT &&
           ( ( slot->face->face_flags & ( 1L << 2 ) ) ||
             ( af_face_globals_is_digit( loader->globals, glyph_index ) &&
               metrics->digits_have_same_width ) ) )
      {
        slot->metrics.horiAdvance = FT_MulFix_arm( (FT_Int32)(slot->metrics.horiAdvance), (FT_Int32)(metrics->scaler.x_scale) )
                                                                        ;



        slot->lsb_delta = 0;
        slot->rsb_delta = 0;
      }
      else
      {

        if ( slot->metrics.horiAdvance )
          slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;
      }


      slot->metrics.vertAdvance = FT_MulFix_arm( (FT_Int32)(slot->metrics.vertAdvance), (FT_Int32)(metrics->scaler.y_scale) )
                                                                      ;

      slot->metrics.horiAdvance = ( ((slot->metrics.horiAdvance) + 32) & ~(__typeof__ ((slot->metrics.horiAdvance) + 32))63 );
      slot->metrics.vertAdvance = ( ((slot->metrics.vertAdvance) + 32) & ~(__typeof__ ((slot->metrics.vertAdvance) + 32))63 );
# 459 "../../../libs/freetype/src/autofit/afloader.c"
      slot->format = FT_GLYPH_FORMAT_OUTLINE;
    }

  Exit:
    return error;
  }




  static FT_Error
  af_loader_load_glyph( AF_Loader loader,
                        AF_Module module,
                        FT_Face face,
                        FT_UInt gindex,
                        FT_Int32 load_flags )
  {
    FT_Error error;
    FT_Size size = face->size;
    AF_ScalerRec scaler;


    if ( !size )
      return AF_Err_Invalid_Size_Handle;

    memset( &scaler, 0, (FT_Offset)(sizeof ( *(&scaler) )) );

    scaler.face = face;
    scaler.x_scale = size->metrics.x_scale;
    scaler.x_delta = 0;
    scaler.y_scale = size->metrics.y_scale;
    scaler.y_delta = 0;

    scaler.render_mode = ( (FT_Render_Mode)( ( (load_flags) >> 16 ) & 15 ) );
    scaler.flags = 0;

    error = af_loader_reset( loader, module, face );
    if ( !error )
    {
      AF_StyleMetrics metrics;
      FT_UInt options = AF_STYLE_NONE_DFLT;
# 508 "../../../libs/freetype/src/autofit/afloader.c"
      error = af_face_globals_get_metrics( loader->globals, gindex,
                                           options, &metrics );
      if ( !error )
      {



        AF_StyleClass style_class = metrics->style_class;
        AF_WritingSystemClass writing_system_class =
          af_writing_system_classes[style_class->writing_system];


        loader->metrics = metrics;

        if ( writing_system_class->style_metrics_scale )
          writing_system_class->style_metrics_scale( metrics, &scaler );
        else
          metrics->scaler = scaler;

        load_flags |= ( 1L << 0 ) | ( 1L << 11 );
        load_flags &= ~( 1L << 2 );

        if ( writing_system_class->style_hints_init )
        {
          error = writing_system_class->style_hints_init( loader->hints,
                                                          metrics );
          if ( error )
            goto Exit;
        }

        error = af_loader_load_g( loader, &scaler, gindex, load_flags );
      }
    }
  Exit:
    return error;
  }
# 553 "../../../libs/freetype/src/autofit/afloader.c"
  static FT_Int32
  af_loader_compute_darkening( AF_Loader loader,
                               FT_Face face,
                               FT_Pos standard_width )
  {
    AF_Module module = loader->globals->module;

    FT_UShort units_per_EM;
    FT_Fixed ppem, em_ratio;
    FT_Fixed stem_width, stem_width_per_1000, scaled_stem, darken_amount;
    FT_Int log_base_2;
    FT_Int x1, y1, x2, y2, x3, y3, x4, y4;


    ppem = ( (( (FT_Fixed)( (FT_UInt32)(4) << 16 ) )) > (( (FT_Fixed)( (FT_UInt32)(face->size->metrics.x_ppem) << 16 ) )) ? (( (FT_Fixed)( (FT_UInt32)(4) << 16 ) )) : (( (FT_Fixed)( (FT_UInt32)(face->size->metrics.x_ppem) << 16 ) )) )
                                                                        ;
    units_per_EM = face->units_per_EM;

    em_ratio = FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(1000) << 16 ) ),
                          ( (FT_Fixed)( (FT_UInt32)(units_per_EM) << 16 ) ) );
    if ( em_ratio < ( (FT_Fixed)( (.01) * 65536.0 + 0.5 ) ) )
    {

      return 0;
    }

    x1 = module->darken_params[0];
    y1 = module->darken_params[1];
    x2 = module->darken_params[2];
    y2 = module->darken_params[3];
    x3 = module->darken_params[4];
    y3 = module->darken_params[5];
    x4 = module->darken_params[6];
    y4 = module->darken_params[7];

    if ( standard_width <= 0 )
    {
      stem_width = ( (FT_Fixed)( (FT_UInt32)(75) << 16 ) );
      stem_width_per_1000 = stem_width;
    }
    else
    {
      stem_width = ( (FT_Fixed)( (FT_UInt32)(standard_width) << 16 ) );
      stem_width_per_1000 = FT_MulFix_arm( (FT_Int32)(stem_width), (FT_Int32)(em_ratio) );
    }

    log_base_2 = ( 31 - __builtin_clz( (FT_UInt32)stem_width_per_1000 ) ) +
                 ( 31 - __builtin_clz( (FT_UInt32)ppem ) );

    if ( log_base_2 >= 46 )
    {

      scaled_stem = ( (FT_Fixed)( (FT_UInt32)(x4) << 16 ) );
    }
    else
      scaled_stem = FT_MulFix_arm( (FT_Int32)(stem_width_per_1000), (FT_Int32)(ppem) );


    if ( scaled_stem < ( (FT_Fixed)( (FT_UInt32)(x1) << 16 ) ) )
      darken_amount = FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(y1) << 16 ) ), ppem );

    else if ( scaled_stem < ( (FT_Fixed)( (FT_UInt32)(x2) << 16 ) ) )
    {
      FT_Int xdelta = x2 - x1;
      FT_Int ydelta = y2 - y1;
      FT_Int x = stem_width_per_1000 -
                       FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(x1) << 16 ) ), ppem );


      if ( !xdelta )
        goto Try_x3;

      darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                      FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(y1) << 16 ) ), ppem );
    }

    else if ( scaled_stem < ( (FT_Fixed)( (FT_UInt32)(x3) << 16 ) ) )
    {
    Try_x3:
      {
        FT_Int xdelta = x3 - x2;
        FT_Int ydelta = y3 - y2;
        FT_Int x = stem_width_per_1000 -
                         FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(x2) << 16 ) ), ppem );


        if ( !xdelta )
          goto Try_x4;

        darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                        FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(y2) << 16 ) ), ppem );
      }
    }

    else if ( scaled_stem < ( (FT_Fixed)( (FT_UInt32)(x4) << 16 ) ) )
    {
    Try_x4:
      {
        FT_Int xdelta = x4 - x3;
        FT_Int ydelta = y4 - y3;
        FT_Int x = stem_width_per_1000 -
                         FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(x3) << 16 ) ), ppem );


        if ( !xdelta )
          goto Use_y4;

        darken_amount = FT_MulDiv( x, ydelta, xdelta ) +
                        FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(y3) << 16 ) ), ppem );
      }
    }

    else
    {
    Use_y4:
      darken_amount = FT_DivFix( ( (FT_Fixed)( (FT_UInt32)(y4) << 16 ) ), ppem );
    }


    return ( (FT_Short)( ( (FT_UInt32)(FT_DivFix( darken_amount, em_ratio )) + 0x8000U ) >> 16 ) );
  }
# 40 "../../../libs/freetype/src/autofit/autofit.c" 2
# 1 "../../../libs/freetype/src/autofit/afmodule.c" 1
# 59 "../../../libs/freetype/src/autofit/afmodule.c"
# 1 "../../../libs/freetype/include/freetype/ftautoh.h" 1
# 32 "../../../libs/freetype/include/freetype/ftautoh.h"

# 248 "../../../libs/freetype/include/freetype/ftautoh.h"
  typedef struct FT_Prop_GlyphToScriptMap_
  {
    FT_Face face;
    FT_UShort* map;

  } FT_Prop_GlyphToScriptMap;
# 387 "../../../libs/freetype/include/freetype/ftautoh.h"
  typedef struct FT_Prop_IncreaseXHeight_
  {
    FT_Face face;
    FT_UInt limit;

  } FT_Prop_IncreaseXHeight;
# 498 "../../../libs/freetype/include/freetype/ftautoh.h"

# 60 "../../../libs/freetype/src/autofit/afmodule.c" 2
# 1 "../../../libs/freetype/include/freetype/internal/services/svprop.h" 1
# 23 "../../../libs/freetype/include/freetype/internal/services/svprop.h"






  typedef FT_Error
  (*FT_Properties_SetFunc)( FT_Module module,
                            const char* property_name,
                            const void* value );

  typedef FT_Error
  (*FT_Properties_GetFunc)( FT_Module module,
                            const char* property_name,
                            void* value );


  typedef struct FT_Service_PropertiesRec_ FT_Service_PropertiesRec ; typedef struct FT_Service_PropertiesRec_ const * FT_Service_Properties ; struct FT_Service_PropertiesRec_
  {
    FT_Properties_SetFunc set_property;
    FT_Properties_GetFunc get_property;
  };
# 75 "../../../libs/freetype/include/freetype/internal/services/svprop.h"

# 61 "../../../libs/freetype/src/autofit/afmodule.c" 2
# 73 "../../../libs/freetype/src/autofit/afmodule.c"
  static FT_Error
  af_property_get_face_globals( FT_Face face,
                                AF_FaceGlobals* aglobals,
                                AF_Module module )
  {
    FT_Error error = FT_Err_Ok;
    AF_FaceGlobals globals;


    if ( !face )
      return AF_Err_Invalid_Face_Handle;

    globals = (AF_FaceGlobals)face->autohint.data;
    if ( !globals )
    {


      error = af_face_globals_new( face, &globals, module );
      if ( !error )
      {
        face->autohint.data =
          (FT_Pointer)globals;
        face->autohint.finalizer =
          (FT_Generic_Finalizer)af_face_globals_free;
      }
    }

    if ( !error )
      *aglobals = globals;

    return error;
  }


  static FT_Error
  af_property_set( FT_Module ft_module,
                   const char* property_name,
                   const void* value )
  {
    FT_Error error = FT_Err_Ok;
    AF_Module module = (AF_Module)ft_module;


    if ( !strcmp( property_name, "fallback-script" ) )
    {
      FT_UInt* fallback_script = (FT_UInt*)value;

      FT_UInt ss;





      for ( ss = 0; af_style_classes[ss]; ss++ )
      {
        AF_StyleClass style_class = af_style_classes[ss];


        if ( (FT_UInt)style_class->script == *fallback_script &&
             style_class->coverage == AF_COVERAGE_DEFAULT )
        {
          module->fallback_style = ss;
          break;
        }
      }

      if ( !af_style_classes[ss] )
      {
        do { } while ( 0 )
                                                     ;
        return AF_Err_Invalid_Argument;
      }

      return error;
    }
    else if ( !strcmp( property_name, "default-script" ) )
    {
      FT_UInt* default_script = (FT_UInt*)value;


      module->default_script = *default_script;

      return error;
    }
    else if ( !strcmp( property_name, "increase-x-height" ) )
    {
      FT_Prop_IncreaseXHeight* prop = (FT_Prop_IncreaseXHeight*)value;
      AF_FaceGlobals globals;


      error = af_property_get_face_globals( prop->face, &globals, module );
      if ( !error )
        globals->increase_x_height = prop->limit;

      return error;
    }
# 180 "../../../libs/freetype/src/autofit/afmodule.c"
    else if ( !strcmp( property_name, "darkening-parameters" ) )
    {
      FT_Int* darken_params = (FT_Int*)value;

      FT_Int x1 = darken_params[0];
      FT_Int y1 = darken_params[1];
      FT_Int x2 = darken_params[2];
      FT_Int y2 = darken_params[3];
      FT_Int x3 = darken_params[4];
      FT_Int y3 = darken_params[5];
      FT_Int x4 = darken_params[6];
      FT_Int y4 = darken_params[7];


      if ( x1 < 0 || x2 < 0 || x3 < 0 || x4 < 0 ||
           y1 < 0 || y2 < 0 || y3 < 0 || y4 < 0 ||
           x1 > x2 || x2 > x3 || x3 > x4 ||
           y1 > 500 || y2 > 500 || y3 > 500 || y4 > 500 )
        return AF_Err_Invalid_Argument;

      module->darken_params[0] = x1;
      module->darken_params[1] = y1;
      module->darken_params[2] = x2;
      module->darken_params[3] = y2;
      module->darken_params[4] = x3;
      module->darken_params[5] = y3;
      module->darken_params[6] = x4;
      module->darken_params[7] = y4;

      return error;
    }
    else if ( !strcmp( property_name, "no-stem-darkening" ) )
    {
      FT_Bool* no_stem_darkening = (FT_Bool*)value;


      module->no_stem_darkening = *no_stem_darkening;

      return error;
    }

    do { } while ( 0 )
                                ;
    return AF_Err_Missing_Property;
  }


  static FT_Error
  af_property_get( FT_Module ft_module,
                   const char* property_name,
                   void* value )
  {
    FT_Error error = FT_Err_Ok;
    AF_Module module = (AF_Module)ft_module;
    FT_UInt fallback_style = module->fallback_style;
    FT_UInt default_script = module->default_script;





    if ( !strcmp( property_name, "glyph-to-script-map" ) )
    {
      FT_Prop_GlyphToScriptMap* prop = (FT_Prop_GlyphToScriptMap*)value;
      AF_FaceGlobals globals;


      error = af_property_get_face_globals( prop->face, &globals, module );
      if ( !error )
        prop->map = globals->glyph_styles;

      return error;
    }
    else if ( !strcmp( property_name, "fallback-script" ) )
    {
      FT_UInt* val = (FT_UInt*)value;

      AF_StyleClass style_class = af_style_classes[fallback_style];


      *val = style_class->script;

      return error;
    }
    else if ( !strcmp( property_name, "default-script" ) )
    {
      FT_UInt* val = (FT_UInt*)value;


      *val = default_script;

      return error;
    }
    else if ( !strcmp( property_name, "increase-x-height" ) )
    {
      FT_Prop_IncreaseXHeight* prop = (FT_Prop_IncreaseXHeight*)value;
      AF_FaceGlobals globals;


      error = af_property_get_face_globals( prop->face, &globals, module );
      if ( !error )
        prop->limit = globals->increase_x_height;

      return error;
    }
# 296 "../../../libs/freetype/src/autofit/afmodule.c"
    else if ( !strcmp( property_name, "darkening-parameters" ) )
    {
      FT_Int* darken_params = module->darken_params;
      FT_Int* val = (FT_Int*)value;


      val[0] = darken_params[0];
      val[1] = darken_params[1];
      val[2] = darken_params[2];
      val[3] = darken_params[3];
      val[4] = darken_params[4];
      val[5] = darken_params[5];
      val[6] = darken_params[6];
      val[7] = darken_params[7];

      return error;
    }
    else if ( !strcmp( property_name, "no-stem-darkening" ) )
    {
      FT_Bool no_stem_darkening = module->no_stem_darkening;
      FT_Bool* val = (FT_Bool*)value;


      *val = no_stem_darkening;

      return error;
    }

    do { } while ( 0 )
                                ;
    return AF_Err_Missing_Property;
  }


  static const FT_Service_PropertiesRec af_service_properties = { (FT_Properties_SetFunc)af_property_set, (FT_Properties_GetFunc)af_property_get };





  static const FT_ServiceDescRec af_services[] = { { "properties", &af_service_properties }, { ((void *)0), ((void *)0) } };




  static FT_Module_Interface
  af_get_interface( FT_Module module,
                    const char* module_interface )
  {
# 356 "../../../libs/freetype/src/autofit/afmodule.c"
    ( (module) = (module) );


    return ft_service_list_lookup( af_services, module_interface );
  }


  static FT_Error
  af_autofitter_init( FT_Module ft_module )
  {
    AF_Module module = (AF_Module)ft_module;


    module->fallback_style = AF_STYLE_HANI_DFLT;
    module->default_script = AF_SCRIPT_LATN;



    module->no_stem_darkening = 1;

    module->darken_params[0] = 500;
    module->darken_params[1] = 400;
    module->darken_params[2] = 1000;
    module->darken_params[3] = 275;
    module->darken_params[4] = 1667;
    module->darken_params[5] = 275;
    module->darken_params[6] = 2333;
    module->darken_params[7] = 0;

    return FT_Err_Ok;
  }


  static void
  af_autofitter_done( FT_Module ft_module )
  {
    ( (ft_module) = (ft_module) );





  }


  static FT_Error
  af_autofitter_load_glyph( AF_Module module,
                            FT_GlyphSlot slot,
                            FT_Size size,
                            FT_UInt glyph_index,
                            FT_Int32 load_flags )
  {
    FT_Error error = FT_Err_Ok;
    FT_Memory memory = module->root.library->memory;
# 440 "../../../libs/freetype/src/autofit/afmodule.c"
    AF_GlyphHintsRec hints[1];
    AF_LoaderRec loader[1];

    ( (size) = (size) );


    af_glyph_hints_init( hints, memory );
    af_loader_init( loader, hints );

    error = af_loader_load_glyph( loader, module, slot->face,
                                  glyph_index, load_flags );

    af_loader_done( loader );
    af_glyph_hints_done( hints );

    return error;


  }


  const FT_AutoHinter_InterfaceRec af_autofitter_interface = { ((void *)0), ((void *)0), ((void *)0), (FT_AutoHinter_GlyphLoadFunc)af_autofitter_load_glyph };







  const FT_Module_Class autofit_module_class = { 4, sizeof ( AF_ModuleRec ), "autofitter", 0x10000L, 0x20000L, (const void*)&af_autofitter_interface, (FT_Module_Constructor)af_autofitter_init, (FT_Module_Destructor) af_autofitter_done, (FT_Module_Requester) af_get_interface, };
# 41 "../../../libs/freetype/src/autofit/autofit.c" 2
